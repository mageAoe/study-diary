/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/css-loader/index.js!./node_modules/less-loader/dist/cjs.js!./src/style.less":
/*!*****************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/less-loader/dist/cjs.js!./src/style.less ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \"#app .font {\\n  font-size: 36px;\\n  color: pink;\\n}\\n\", \"\"]);\n\n// exports\n\n\n//# sourceURL=webpack:///./src/style.less?./node_modules/css-loader!./node_modules/less-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js?!./src/app.vue?vue&type=style&index=0&id=5ef48958&scoped=true&lang=css&":
/*!*******************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib??vue-loader-options!./src/app.vue?vue&type=style&index=0&id=5ef48958&scoped=true&lang=css& ***!
  \*******************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\", \"\"]);\n\n// exports\n\n\n//# sourceURL=webpack:///./src/app.vue?./node_modules/css-loader!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/style.css":
/*!*************************************************!*\
  !*** ./node_modules/css-loader!./src/style.css ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \"\\r\\n#app{width: 300px;height:300px;background: red;}\\r\\n\", \"\"]);\n\n// exports\n\n\n//# sourceURL=webpack:///./src/style.css?./node_modules/css-loader");

/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n\n//# sourceURL=webpack:///./node_modules/css-loader/lib/css-base.js?");

/***/ }),

/***/ "./node_modules/style-loader/index.js!./node_modules/css-loader/index.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js?!./src/app.vue?vue&type=style&index=0&id=5ef48958&scoped=true&lang=css&":
/*!***********************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader!./node_modules/css-loader!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib??vue-loader-options!./src/app.vue?vue&type=style&index=0&id=5ef48958&scoped=true&lang=css& ***!
  \***********************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../node_modules/css-loader!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/vue-loader/lib??vue-loader-options!./app.vue?vue&type=style&index=0&id=5ef48958&scoped=true&lang=css& */ \"./node_modules/css-loader/index.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js?!./src/app.vue?vue&type=style&index=0&id=5ef48958&scoped=true&lang=css&\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack:///./src/app.vue?./node_modules/style-loader!./node_modules/css-loader!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ \"./node_modules/style-loader/lib/urls.js\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (false) {}\n\n\treturn __webpack_require__.nc;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === 'function'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n\n\n//# sourceURL=webpack:///./node_modules/style-loader/lib/addStyles.js?");

/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n\n\n//# sourceURL=webpack:///./node_modules/style-loader/lib/urls.js?");

/***/ }),

/***/ "./node_modules/vue-loader/lib/index.js?!./src/app.vue?vue&type=script&lang=js&":
/*!************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib??vue-loader-options!./src/app.vue?vue&type=script&lang=js& ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    \n});\n\n\n//# sourceURL=webpack:///./src/app.vue?./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/app.vue?vue&type=template&id=5ef48958&scoped=true&":
/*!**********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/app.vue?vue&type=template&id=5ef48958&scoped=true& ***!
  \**********************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return staticRenderFns; });\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _vm._m(0)\n}\nvar staticRenderFns = [\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"div\", { attrs: { id: \"app\" } }, [\n      _c(\"h1\", { staticClass: \"font\" }, [_vm._v(\"demo\")]),\n      _vm._v(\" \"),\n      _c(\"img\", { attrs: { src: __webpack_require__(/*! ./ass/4efbc0992ccdbfb4.jpg */ \"./src/ass/4efbc0992ccdbfb4.jpg\") } })\n    ])\n  }\n]\nrender._withStripped = true\n\n\n\n//# sourceURL=webpack:///./src/app.vue?./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js":
/*!********************************************************************!*\
  !*** ./node_modules/vue-loader/lib/runtime/componentNormalizer.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return normalizeComponent; });\n/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nfunction normalizeComponent (\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier, /* server only */\n  shadowMode /* vue-cli only */\n) {\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = 'data-v-' + scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functioal component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/vue-loader/lib/runtime/componentNormalizer.js?");

/***/ }),

/***/ "./node_modules/vue/dist/vue.esm.js":
/*!******************************************!*\
  !*** ./node_modules/vue/dist/vue.esm.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!\n * Vue.js v2.5.17\n * (c) 2014-2018 Evan You\n * Released under the MIT License.\n */\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n// these helpers produces better vm code in JS engines due to their\n// explicitness and function inlining\nfunction isUndef (v) {\n  return v === undefined || v === null\n}\n\nfunction isDef (v) {\n  return v !== undefined && v !== null\n}\n\nfunction isTrue (v) {\n  return v === true\n}\n\nfunction isFalse (v) {\n  return v === false\n}\n\n/**\n * Check if value is primitive\n */\nfunction isPrimitive (value) {\n  return (\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    // $flow-disable-line\n    typeof value === 'symbol' ||\n    typeof value === 'boolean'\n  )\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * Get the raw type string of a value e.g. [object Object]\n */\nvar _toString = Object.prototype.toString;\n\nfunction toRawType (value) {\n  return _toString.call(value).slice(8, -1)\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject (obj) {\n  return _toString.call(obj) === '[object Object]'\n}\n\nfunction isRegExp (v) {\n  return _toString.call(v) === '[object RegExp]'\n}\n\n/**\n * Check if val is a valid array index.\n */\nfunction isValidArrayIndex (val) {\n  var n = parseFloat(String(val));\n  return n >= 0 && Math.floor(n) === n && isFinite(val)\n}\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString (val) {\n  return val == null\n    ? ''\n    : typeof val === 'object'\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Check if a attribute is a reserved attribute.\n */\nvar isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n\n/**\n * Remove an item from an array\n */\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /\\B([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str.replace(hyphenateRE, '-$1').toLowerCase()\n});\n\n/**\n * Simple bind polyfill for environments that do not support it... e.g.\n * PhantomJS 1.x. Technically we don't need this anymore since native bind is\n * now more performant in most browsers, but removing it would be breaking for\n * code that was able to run in PhantomJS 1.x, so this must be kept for\n * backwards compatibility.\n */\n\n/* istanbul ignore next */\nfunction polyfillBind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n\n  boundFn._length = fn.length;\n  return boundFn\n}\n\nfunction nativeBind (fn, ctx) {\n  return fn.bind(ctx)\n}\n\nvar bind = Function.prototype.bind\n  ? nativeBind\n  : polyfillBind;\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/**\n * Perform no operation.\n * Stubbing args to make Flow happy without leaving useless transpiled code\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)\n */\nfunction noop (a, b, c) {}\n\n/**\n * Always return false.\n */\nvar no = function (a, b, c) { return false; };\n\n/**\n * Return same value\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a static keys string from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  if (a === b) { return true }\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      var isArrayA = Array.isArray(a);\n      var isArrayB = Array.isArray(b);\n      if (isArrayA && isArrayB) {\n        return a.length === b.length && a.every(function (e, i) {\n          return looseEqual(e, b[i])\n        })\n      } else if (!isArrayA && !isArrayB) {\n        var keysA = Object.keys(a);\n        var keysB = Object.keys(b);\n        return keysA.length === keysB.length && keysA.every(function (key) {\n          return looseEqual(a[key], b[key])\n        })\n      } else {\n        /* istanbul ignore next */\n        return false\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      return false\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  }\n}\n\nvar SSR_ATTR = 'data-server-rendered';\n\nvar ASSET_TYPES = [\n  'component',\n  'directive',\n  'filter'\n];\n\nvar LIFECYCLE_HOOKS = [\n  'beforeCreate',\n  'created',\n  'beforeMount',\n  'mounted',\n  'beforeUpdate',\n  'updated',\n  'beforeDestroy',\n  'destroyed',\n  'activated',\n  'deactivated',\n  'errorCaptured'\n];\n\n/*  */\n\nvar config = ({\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  // $flow-disable-line\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: \"development\" !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: \"development\" !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Warn handler for watcher warns\n   */\n  warnHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  // $flow-disable-line\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n})\n\n/*  */\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return }\n      obj = obj[segments[i]];\n    }\n    return obj\n  }\n}\n\n/*  */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\nvar weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');\nvar isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n\n// Firefox has a \"watch\" function on Object.prototype...\nvar nativeWatch = ({}).watch;\n\nvar supportsPassive = false;\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', ({\n      get: function get () {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    })); // https://github.com/facebook/flow/issues/285\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n}\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && !inWeex && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n}\n\nvar hasSymbol =\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\nvar _Set;\n/* istanbul ignore if */ // $flow-disable-line\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = (function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\n/*  */\n\nvar warn = noop;\nvar tip = noop;\nvar generateComponentTrace = (noop); // work around flow check\nvar formatComponentName = (noop);\n\nif (true) {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function (str) { return str\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\n    .replace(/[-_]/g, ''); };\n\n  warn = function (msg, vm) {\n    var trace = vm ? generateComponentTrace(vm) : '';\n\n    if (config.warnHandler) {\n      config.warnHandler.call(null, msg, vm, trace);\n    } else if (hasConsole && (!config.silent)) {\n      console.error((\"[Vue warn]: \" + msg + trace));\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.warn(\"[Vue tip]: \" + msg + (\n        vm ? generateComponentTrace(vm) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>'\n    }\n    var options = typeof vm === 'function' && vm.cid != null\n      ? vm.options\n      : vm._isVue\n        ? vm.$options || vm.constructor.options\n        : vm || {};\n    var name = options.name || options._componentTag;\n    var file = options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (\n      (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n      (file && includeFile !== false ? (\" at \" + file) : '')\n    )\n  };\n\n  var repeat = function (str, n) {\n    var res = '';\n    while (n) {\n      if (n % 2 === 1) { res += str; }\n      if (n > 1) { str += str; }\n      n >>= 1;\n    }\n    return res\n  };\n\n  generateComponentTrace = function (vm) {\n    if (vm._isVue && vm.$parent) {\n      var tree = [];\n      var currentRecursiveSequence = 0;\n      while (vm) {\n        if (tree.length > 0) {\n          var last = tree[tree.length - 1];\n          if (last.constructor === vm.constructor) {\n            currentRecursiveSequence++;\n            vm = vm.$parent;\n            continue\n          } else if (currentRecursiveSequence > 0) {\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\n            currentRecursiveSequence = 0;\n          }\n        }\n        tree.push(vm);\n        vm = vm.$parent;\n      }\n      return '\\n\\nfound in\\n\\n' + tree\n        .map(function (vm, i) { return (\"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)\n            ? ((formatComponentName(vm[0])) + \"... (\" + (vm[1]) + \" recursive calls)\")\n            : formatComponentName(vm))); })\n        .join('\\n')\n    } else {\n      return (\"\\n\\n(found in \" + (formatComponentName(vm)) + \")\")\n    }\n  };\n}\n\n/*  */\n\n\nvar uid = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (_target) {\n  if (Dep.target) { targetStack.push(Dep.target); }\n  Dep.target = _target;\n}\n\nfunction popTarget () {\n  Dep.target = targetStack.pop();\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions,\n  asyncFactory\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.fnContext = undefined;\n  this.fnOptions = undefined;\n  this.fnScopeId = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n  this.asyncFactory = asyncFactory;\n  this.asyncMeta = undefined;\n  this.isAsyncPlaceholder = false;\n};\n\nvar prototypeAccessors = { child: { configurable: true } };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function (text) {\n  if ( text === void 0 ) text = '';\n\n  var node = new VNode();\n  node.text = text;\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions,\n    vnode.asyncFactory\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.fnContext = vnode.fnContext;\n  cloned.fnOptions = vnode.fnOptions;\n  cloned.fnScopeId = vnode.fnScopeId;\n  cloned.isCloned = true;\n  return cloned\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);\n\nvar methodsToPatch = [\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n];\n\n/**\n * Intercept mutating methods and emit events\n */\nmethodsToPatch.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * In some cases we may want to disable observation inside a component's\n * update computation.\n */\nvar shouldObserve = true;\n\nfunction toggleObserving (value) {\n  shouldObserve = value;\n}\n\n/**\n * Observer class that is attached to each observed\n * object. Once attached, the observer converts the target\n * object's property keys into getter/setters that\n * collect dependencies and dispatch updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto\n      ? protoAugment\n      : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive(obj, keys[i]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src, keys) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value) || value instanceof VNode) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    shouldObserve &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive (\n  obj,\n  key,\n  val,\n  customSetter,\n  shallow\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  if (!getter && arguments.length === 2) {\n    val = obj[key];\n  }\n  var setter = property && property.set;\n\n  var childOb = !shallow && observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n          if (Array.isArray(value)) {\n            dependArray(value);\n          }\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (\"development\" !== 'production' && customSetter) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = !shallow && observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (target, key, val) {\n  if (\"development\" !== 'production' &&\n    (isUndef(target) || isPrimitive(target))\n  ) {\n    warn((\"Cannot set reactive property on undefined, null, or primitive value: \" + ((target))));\n  }\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (key in target && !(key in Object.prototype)) {\n    target[key] = val;\n    return val\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    \"development\" !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (target, key) {\n  if (\"development\" !== 'production' &&\n    (isUndef(target) || isPrimitive(target))\n  ) {\n    warn((\"Cannot delete reactive property on undefined, null, or primitive value: \" + ((target))));\n  }\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.splice(key, 1);\n    return\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    \"development\" !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(target, key)) {\n    return\n  }\n  delete target[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (true) {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nfunction mergeDataOrFn (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        typeof childVal === 'function' ? childVal.call(this, this) : childVal,\n        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal\n      )\n    }\n  } else {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm, vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm, vm)\n        : parentVal;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n}\n\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    if (childVal && typeof childVal !== 'function') {\n      \"development\" !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n\n      return parentVal\n    }\n    return mergeDataOrFn(parentVal, childVal)\n  }\n\n  return mergeDataOrFn(parentVal, childVal, vm)\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  var res = Object.create(parentVal || null);\n  if (childVal) {\n    \"development\" !== 'production' && assertObjectType(key, childVal, vm);\n    return extend(res, childVal)\n  } else {\n    return res\n  }\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  // work around Firefox's Object.prototype.watch...\n  if (parentVal === nativeWatch) { parentVal = undefined; }\n  if (childVal === nativeWatch) { childVal = undefined; }\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (true) {\n    assertObjectType(key, childVal, vm);\n  }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key$1 in childVal) {\n    var parent = ret[key$1];\n    var child = childVal[key$1];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key$1] = parent\n      ? parent.concat(child)\n      : Array.isArray(child) ? child : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.inject =\nstrats.computed = function (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  if (childVal && \"development\" !== 'production') {\n    assertObjectType(key, childVal, vm);\n  }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  if (childVal) { extend(ret, childVal); }\n  return ret\n};\nstrats.provide = mergeDataOrFn;\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    validateComponentName(key);\n  }\n}\n\nfunction validateComponentName (name) {\n  if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n    warn(\n      'Invalid component name: \"' + name + '\". Component names ' +\n      'can only contain alphanumeric characters and the hyphen, ' +\n      'and must start with a letter.'\n    );\n  }\n  if (isBuiltInTag(name) || config.isReservedTag(name)) {\n    warn(\n      'Do not use built-in or reserved HTML elements as component ' +\n      'id: ' + name\n    );\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options, vm) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (true) {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  } else if (true) {\n    warn(\n      \"Invalid value for option \\\"props\\\": expected an Array or an Object, \" +\n      \"but got \" + (toRawType(props)) + \".\",\n      vm\n    );\n  }\n  options.props = res;\n}\n\n/**\n * Normalize all injections into Object-based format\n */\nfunction normalizeInject (options, vm) {\n  var inject = options.inject;\n  if (!inject) { return }\n  var normalized = options.inject = {};\n  if (Array.isArray(inject)) {\n    for (var i = 0; i < inject.length; i++) {\n      normalized[inject[i]] = { from: inject[i] };\n    }\n  } else if (isPlainObject(inject)) {\n    for (var key in inject) {\n      var val = inject[key];\n      normalized[key] = isPlainObject(val)\n        ? extend({ from: key }, val)\n        : { from: val };\n    }\n  } else if (true) {\n    warn(\n      \"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" +\n      \"but got \" + (toRawType(inject)) + \".\",\n      vm\n    );\n  }\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\nfunction assertObjectType (name, value, vm) {\n  if (!isPlainObject(value)) {\n    warn(\n      \"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" +\n      \"but got \" + (toRawType(value)) + \".\",\n      vm\n    );\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (true) {\n    checkComponents(child);\n  }\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child, vm);\n  normalizeInject(child, vm);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      parent = mergeOptions(parent, child.mixins[i], vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (\"development\" !== 'production' && warnMissing && !res) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // boolean casting\n  var booleanIndex = getTypeIndex(Boolean, prop.type);\n  if (booleanIndex > -1) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (value === '' || value === hyphenate(key)) {\n      // only cast empty string / same name to boolean if\n      // boolean has higher priority\n      var stringIndex = getTypeIndex(String, prop.type);\n      if (stringIndex < 0 || booleanIndex < stringIndex) {\n        value = true;\n      }\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldObserve = shouldObserve;\n    toggleObserving(true);\n    observe(value);\n    toggleObserving(prevShouldObserve);\n  }\n  if (\n    true\n  ) {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (\"development\" !== 'production' && isObject(def)) {\n    warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm._props[key] !== undefined\n  ) {\n    return vm._props[key]\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn(\n      \"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" +\n      \" Expected \" + (expectedTypes.map(capitalize).join(', ')) +\n      \", got \" + (toRawType(value)) + \".\",\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (simpleCheckRE.test(expectedType)) {\n    var t = typeof value;\n    valid = t === expectedType.toLowerCase();\n    // for primitive wrapper objects\n    if (!valid && t === 'object') {\n      valid = value instanceof type;\n    }\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : ''\n}\n\nfunction isSameType (a, b) {\n  return getType(a) === getType(b)\n}\n\nfunction getTypeIndex (type, expectedTypes) {\n  if (!Array.isArray(expectedTypes)) {\n    return isSameType(expectedTypes, type) ? 0 : -1\n  }\n  for (var i = 0, len = expectedTypes.length; i < len; i++) {\n    if (isSameType(expectedTypes[i], type)) {\n      return i\n    }\n  }\n  return -1\n}\n\n/*  */\n\nfunction handleError (err, vm, info) {\n  if (vm) {\n    var cur = vm;\n    while ((cur = cur.$parent)) {\n      var hooks = cur.$options.errorCaptured;\n      if (hooks) {\n        for (var i = 0; i < hooks.length; i++) {\n          try {\n            var capture = hooks[i].call(cur, err, vm, info) === false;\n            if (capture) { return }\n          } catch (e) {\n            globalHandleError(e, cur, 'errorCaptured hook');\n          }\n        }\n      }\n    }\n  }\n  globalHandleError(err, vm, info);\n}\n\nfunction globalHandleError (err, vm, info) {\n  if (config.errorHandler) {\n    try {\n      return config.errorHandler.call(null, err, vm, info)\n    } catch (e) {\n      logError(e, null, 'config.errorHandler');\n    }\n  }\n  logError(err, vm, info);\n}\n\nfunction logError (err, vm, info) {\n  if (true) {\n    warn((\"Error in \" + info + \": \\\"\" + (err.toString()) + \"\\\"\"), vm);\n  }\n  /* istanbul ignore else */\n  if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n    console.error(err);\n  } else {\n    throw err\n  }\n}\n\n/*  */\n/* globals MessageChannel */\n\nvar callbacks = [];\nvar pending = false;\n\nfunction flushCallbacks () {\n  pending = false;\n  var copies = callbacks.slice(0);\n  callbacks.length = 0;\n  for (var i = 0; i < copies.length; i++) {\n    copies[i]();\n  }\n}\n\n// Here we have async deferring wrappers using both microtasks and (macro) tasks.\n// In < 2.4 we used microtasks everywhere, but there are some scenarios where\n// microtasks have too high a priority and fire in between supposedly\n// sequential events (e.g. #4521, #6690) or even between bubbling of the same\n// event (#6566). However, using (macro) tasks everywhere also has subtle problems\n// when state is changed right before repaint (e.g. #6813, out-in transitions).\n// Here we use microtask by default, but expose a way to force (macro) task when\n// needed (e.g. in event handlers attached by v-on).\nvar microTimerFunc;\nvar macroTimerFunc;\nvar useMacroTask = false;\n\n// Determine (macro) task defer implementation.\n// Technically setImmediate should be the ideal choice, but it's only available\n// in IE. The only polyfill that consistently queues the callback after all DOM\n// events triggered in the same loop is by using MessageChannel.\n/* istanbul ignore if */\nif (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  macroTimerFunc = function () {\n    setImmediate(flushCallbacks);\n  };\n} else if (typeof MessageChannel !== 'undefined' && (\n  isNative(MessageChannel) ||\n  // PhantomJS\n  MessageChannel.toString() === '[object MessageChannelConstructor]'\n)) {\n  var channel = new MessageChannel();\n  var port = channel.port2;\n  channel.port1.onmessage = flushCallbacks;\n  macroTimerFunc = function () {\n    port.postMessage(1);\n  };\n} else {\n  /* istanbul ignore next */\n  macroTimerFunc = function () {\n    setTimeout(flushCallbacks, 0);\n  };\n}\n\n// Determine microtask defer implementation.\n/* istanbul ignore next, $flow-disable-line */\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  var p = Promise.resolve();\n  microTimerFunc = function () {\n    p.then(flushCallbacks);\n    // in problematic UIWebViews, Promise.then doesn't completely break, but\n    // it can get stuck in a weird state where callbacks are pushed into the\n    // microtask queue but the queue isn't being flushed, until the browser\n    // needs to do some other work, e.g. handle a timer. Therefore we can\n    // \"force\" the microtask queue to be flushed by adding an empty timer.\n    if (isIOS) { setTimeout(noop); }\n  };\n} else {\n  // fallback to macro\n  microTimerFunc = macroTimerFunc;\n}\n\n/**\n * Wrap a function so that if any code inside triggers state change,\n * the changes are queued using a (macro) task instead of a microtask.\n */\nfunction withMacroTask (fn) {\n  return fn._withTask || (fn._withTask = function () {\n    useMacroTask = true;\n    var res = fn.apply(null, arguments);\n    useMacroTask = false;\n    return res\n  })\n}\n\nfunction nextTick (cb, ctx) {\n  var _resolve;\n  callbacks.push(function () {\n    if (cb) {\n      try {\n        cb.call(ctx);\n      } catch (e) {\n        handleError(e, ctx, 'nextTick');\n      }\n    } else if (_resolve) {\n      _resolve(ctx);\n    }\n  });\n  if (!pending) {\n    pending = true;\n    if (useMacroTask) {\n      macroTimerFunc();\n    } else {\n      microTimerFunc();\n    }\n  }\n  // $flow-disable-line\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(function (resolve) {\n      _resolve = resolve;\n    })\n  }\n}\n\n/*  */\n\nvar mark;\nvar measure;\n\nif (true) {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (\n    perf &&\n    perf.mark &&\n    perf.measure &&\n    perf.clearMarks &&\n    perf.clearMeasures\n  ) {\n    mark = function (tag) { return perf.mark(tag); };\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      perf.clearMeasures(name);\n    };\n  }\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (true) {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      'referenced during render. Make sure that this property is reactive, ' +\n      'either in the data option, or for class-based components, by ' +\n      'initializing the property. ' +\n      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' && isNative(Proxy);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warnNonPresent(target, key);\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        warnNonPresent(target, key);\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\nvar seenObjects = new _Set();\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nfunction traverse (val) {\n  _traverse(val, seenObjects);\n  seenObjects.clear();\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  }\n});\n\nfunction createFnInvoker (fns) {\n  function invoker () {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      var cloned = fns.slice();\n      for (var i = 0; i < cloned.length; i++) {\n        cloned[i].apply(null, arguments$1);\n      }\n    } else {\n      // return handler return value for single handlers\n      return fns.apply(null, arguments)\n    }\n  }\n  invoker.fns = fns;\n  return invoker\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  vm\n) {\n  var name, def, cur, old, event;\n  for (name in on) {\n    def = cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    /* istanbul ignore if */\n    if (isUndef(cur)) {\n      \"development\" !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur);\n      }\n      add(event.name, cur, event.once, event.capture, event.passive, event.params);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook) {\n  if (def instanceof VNode) {\n    def = def.data.hook || (def.data.hook = {});\n  }\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook () {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\nfunction extractPropsFromVNodeData (\n  data,\n  Ctor,\n  tag\n) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (isUndef(propOptions)) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (true) {\n        var keyInLowerCase = key.toLowerCase();\n        if (\n          key !== keyInLowerCase &&\n          attrs && hasOwn(attrs, keyInLowerCase)\n        ) {\n          tip(\n            \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n            (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n            \" \\\"\" + key + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and camelCased \" +\n            \"props need to use their kebab-case equivalents when using in-DOM \" +\n            \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n          );\n        }\n      }\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey, false);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction isTextNode (node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, lastIndex, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (isUndef(c) || typeof c === 'boolean') { continue }\n    lastIndex = res.length - 1;\n    last = res[lastIndex];\n    //  nested\n    if (Array.isArray(c)) {\n      if (c.length > 0) {\n        c = normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i));\n        // merge adjacent text nodes\n        if (isTextNode(c[0]) && isTextNode(last)) {\n          res[lastIndex] = createTextVNode(last.text + (c[0]).text);\n          c.shift();\n        }\n        res.push.apply(res, c);\n      }\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        res[lastIndex] = createTextVNode(last.text + c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[lastIndex] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) &&\n          isDef(c.tag) &&\n          isUndef(c.key) &&\n          isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction ensureCtor (comp, base) {\n  if (\n    comp.__esModule ||\n    (hasSymbol && comp[Symbol.toStringTag] === 'Module')\n  ) {\n    comp = comp.default;\n  }\n  return isObject(comp)\n    ? base.extend(comp)\n    : comp\n}\n\nfunction createAsyncPlaceholder (\n  factory,\n  data,\n  context,\n  children,\n  tag\n) {\n  var node = createEmptyVNode();\n  node.asyncFactory = factory;\n  node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n  return node\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor,\n  context\n) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp\n  }\n\n  if (isDef(factory.contexts)) {\n    // already pending\n    factory.contexts.push(context);\n  } else {\n    var contexts = factory.contexts = [context];\n    var sync = true;\n\n    var forceRender = function () {\n      for (var i = 0, l = contexts.length; i < l; i++) {\n        contexts[i].$forceUpdate();\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor);\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender();\n      }\n    });\n\n    var reject = once(function (reason) {\n      \"development\" !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender();\n      }\n    });\n\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (typeof res.then === 'function') {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isDef(res.component) && typeof res.component.then === 'function') {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            setTimeout(function () {\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender();\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          setTimeout(function () {\n            if (isUndef(factory.resolved)) {\n              reject(\n                 true\n                  ? (\"timeout (\" + (res.timeout) + \"ms)\")\n                  : undefined\n              );\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.loading\n      ? factory.loadingComp\n      : factory.resolved\n  }\n}\n\n/*  */\n\nfunction isAsyncPlaceholder (node) {\n  return node.isComment && node.asyncFactory\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n        return c\n      }\n    }\n  }\n}\n\n/*  */\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add (event, fn, once) {\n  if (once) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\nfunction remove$1 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n  target = undefined;\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$off(event[i], fn);\n      }\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (!fn) {\n      vm._events[event] = null;\n      return vm\n    }\n    if (fn) {\n      // specific handler\n      var cb;\n      var i$1 = cbs.length;\n      while (i$1--) {\n        cb = cbs[i$1];\n        if (cb === fn || cb.fn === fn) {\n          cbs.splice(i$1, 1);\n          break\n        }\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (true) {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\n          \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n          (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n          \"Note that HTML attributes are case-insensitive and you cannot use \" +\n          \"v-on to listen to camelCase events when using in-DOM templates. \" +\n          \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n        );\n      }\n    }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        try {\n          cbs[i].apply(vm, args);\n        } catch (e) {\n          handleError(e, vm, (\"event handler for \\\"\" + event + \"\\\"\"));\n        }\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\n\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots (\n  children,\n  context\n) {\n  var slots = {};\n  if (!children) {\n    return slots\n  }\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    var data = child.data;\n    // remove slot attribute if the node is resolved as a Vue slot node\n    if (data && data.attrs && data.attrs.slot) {\n      delete data.attrs.slot;\n    }\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.fnContext === context) &&\n      data && data.slot != null\n    ) {\n      var name = data.slot;\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children || []);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      (slots.default || (slots.default = [])).push(child);\n    }\n  }\n  // ignore slots that contains only whitespace\n  for (var name$1 in slots) {\n    if (slots[name$1].every(isWhitespace)) {\n      delete slots[name$1];\n    }\n  }\n  return slots\n}\n\nfunction isWhitespace (node) {\n  return (node.isComment && !node.asyncFactory) || node.text === ' '\n}\n\nfunction resolveScopedSlots (\n  fns, // see flow/vnode\n  res\n) {\n  res = res || {};\n  for (var i = 0; i < fns.length; i++) {\n    if (Array.isArray(fns[i])) {\n      resolveScopedSlots(fns[i], res);\n    } else {\n      res[fns[i].key] = fns[i].fn;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar activeInstance = null;\nvar isUpdatingChildComponent = false;\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      );\n      // no need for the ref nodes after initial patch\n      // this prevents keeping a detached DOM tree in memory (#5851)\n      vm.$options._parentElm = vm.$options._refElm = null;\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // release circular reference (#6759)\n    if (vm.$vnode) {\n      vm.$vnode.parent = null;\n    }\n  };\n}\n\nfunction mountComponent (\n  vm,\n  el,\n  hydrating\n) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (true) {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        );\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        );\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (\"development\" !== 'production' && config.performance && mark) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure((\"vue \" + name + \" render\"), startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure((\"vue \" + name + \" patch\"), startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n  new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm\n}\n\nfunction updateChildComponent (\n  vm,\n  propsData,\n  listeners,\n  parentVnode,\n  renderChildren\n) {\n  if (true) {\n    isUpdatingChildComponent = true;\n  }\n\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren\n  var hasChildren = !!(\n    renderChildren ||               // has new static slots\n    vm.$options._renderChildren ||  // has old static slots\n    parentVnode.data.scopedSlots || // has new scoped slots\n    vm.$scopedSlots !== emptyObject // has old scoped slots\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n  if (vm._vnode) { // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update $attrs and $listeners hash\n  // these are also reactive so they may trigger child update if the child\n  // used them during render\n  vm.$attrs = parentVnode.data.attrs || emptyObject;\n  vm.$listeners = listeners || emptyObject;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    toggleObserving(false);\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      var propOptions = vm.$options.props; // wtf flow?\n      props[key] = validateProp(key, propOptions, propsData, vm);\n    }\n    toggleObserving(true);\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n\n  // update listeners\n  listeners = listeners || emptyObject;\n  var oldListeners = vm.$options._parentListeners;\n  vm.$options._parentListeners = listeners;\n  updateComponentListeners(vm, listeners, oldListeners);\n\n  // resolve slots + force update if has children\n  if (hasChildren) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n\n  if (true) {\n    isUpdatingChildComponent = false;\n  }\n}\n\nfunction isInInactiveTree (vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) { return true }\n  }\n  return false\n}\n\nfunction activateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  } else if (vm._directInactive) {\n    return\n  }\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook (vm, hook) {\n  // #7573 disable dep collection when invoking lifecycle hooks\n  pushTarget();\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      try {\n        handlers[i].call(vm);\n      } catch (e) {\n        handleError(e, vm, (hook + \" hook\"));\n      }\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n  popTarget();\n}\n\n/*  */\n\n\nvar MAX_UPDATE_COUNT = 100;\n\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n  if (true) {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  flushing = true;\n  var watcher, id;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (\"development\" !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n\n  resetSchedulerState();\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue);\n  callUpdatedHooks(updatedQueue);\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdatedHooks (queue) {\n  var i = queue.length;\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent (vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks (queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true /* true */);\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$1 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options,\n  isRenderWatcher\n) {\n  this.vm = vm;\n  if (isRenderWatcher) {\n    vm._watcher = this;\n  }\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$1; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression =  true\n    ? expOrFn.toString()\n    : undefined;\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      \"development\" !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  try {\n    value = this.getter.call(vm, vm);\n  } catch (e) {\n    if (this.user) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    } else {\n      throw e\n    }\n  } finally {\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    if (this.deep) {\n      traverse(value);\n    }\n    popTarget();\n    this.cleanupDeps();\n  }\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n    var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  };\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch);\n  }\n}\n\nfunction initProps (vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  if (!isRoot) {\n    toggleObserving(false);\n  }\n  var loop = function ( key ) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (true) {\n      var hyphenatedKey = hyphenate(key);\n      if (isReservedAttribute(hyphenatedKey) ||\n          config.isReservedAttr(hyphenatedKey)) {\n        warn(\n          (\"\\\"\" + hyphenatedKey + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive(props, key, value, function () {\n        if (vm.$parent && !isUpdatingChildComponent) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {}\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop( key );\n  toggleObserving(true);\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    \"development\" !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var methods = vm.$options.methods;\n  var i = keys.length;\n  while (i--) {\n    var key = keys[i];\n    if (true) {\n      if (methods && hasOwn(methods, key)) {\n        warn(\n          (\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\"),\n          vm\n        );\n      }\n    }\n    if (props && hasOwn(props, key)) {\n      \"development\" !== 'production' && warn(\n        \"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else if (!isReserved(key)) {\n      proxy(vm, \"_data\", key);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData (data, vm) {\n  // #7573 disable dep collection when invoking data getters\n  pushTarget();\n  try {\n    return data.call(vm, vm)\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {}\n  } finally {\n    popTarget();\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed (vm, computed) {\n  // $flow-disable-line\n  var watchers = vm._computedWatchers = Object.create(null);\n  // computed properties are just getters during SSR\n  var isSSR = isServerRendering();\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if (\"development\" !== 'production' && getter == null) {\n      warn(\n        (\"Getter is missing for computed property \\\"\" + key + \"\\\".\"),\n        vm\n      );\n    }\n\n    if (!isSSR) {\n      // create internal watcher for the computed property.\n      watchers[key] = new Watcher(\n        vm,\n        getter || noop,\n        noop,\n        computedWatcherOptions\n      );\n    }\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (true) {\n      if (key in vm.$data) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined in data.\"), vm);\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\"), vm);\n      }\n    }\n  }\n}\n\nfunction defineComputed (\n  target,\n  key,\n  userDef\n) {\n  var shouldCache = !isServerRendering();\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = shouldCache\n      ? createComputedGetter(key)\n      : userDef;\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? shouldCache && userDef.cache !== false\n        ? createComputedGetter(key)\n        : userDef.get\n      : noop;\n    sharedPropertyDefinition.set = userDef.set\n      ? userDef.set\n      : noop;\n  }\n  if (\"development\" !== 'production' &&\n      sharedPropertyDefinition.set === noop) {\n    sharedPropertyDefinition.set = function () {\n      warn(\n        (\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\"),\n        this\n      );\n    };\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value\n    }\n  }\n}\n\nfunction initMethods (vm, methods) {\n  var props = vm.$options.props;\n  for (var key in methods) {\n    if (true) {\n      if (methods[key] == null) {\n        warn(\n          \"Method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\n          \"Did you reference the function correctly?\",\n          vm\n        );\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          (\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n          vm\n        );\n      }\n      if ((key in vm) && isReserved(key)) {\n        warn(\n          \"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" +\n          \"Avoid defining component methods that start with _ or $.\"\n        );\n      }\n    }\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n  }\n}\n\nfunction initWatch (vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (\n  vm,\n  expOrFn,\n  handler,\n  options\n) {\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  return vm.$watch(expOrFn, handler, options)\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () { return this._data };\n  var propsDef = {};\n  propsDef.get = function () { return this._props };\n  if (true) {\n    dataDef.set = function (newData) {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    if (isPlainObject(cb)) {\n      return createWatcher(vm, expOrFn, cb, options)\n    }\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\n/*  */\n\nfunction initProvide (vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide;\n  }\n}\n\nfunction initInjections (vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n  if (result) {\n    toggleObserving(false);\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (true) {\n        defineReactive(vm, key, result[key], function () {\n          warn(\n            \"Avoid mutating an injected value directly since the changes will be \" +\n            \"overwritten whenever the provided component re-renders. \" +\n            \"injection being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        });\n      } else {}\n    });\n    toggleObserving(true);\n  }\n}\n\nfunction resolveInject (inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    var result = Object.create(null);\n    var keys = hasSymbol\n      ? Reflect.ownKeys(inject).filter(function (key) {\n        /* istanbul ignore next */\n        return Object.getOwnPropertyDescriptor(inject, key).enumerable\n      })\n      : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var provideKey = inject[key].from;\n      var source = vm;\n      while (source) {\n        if (source._provided && hasOwn(source._provided, provideKey)) {\n          result[key] = source._provided[provideKey];\n          break\n        }\n        source = source.$parent;\n      }\n      if (!source) {\n        if ('default' in inject[key]) {\n          var provideDefault = inject[key].default;\n          result[key] = typeof provideDefault === 'function'\n            ? provideDefault.call(vm)\n            : provideDefault;\n        } else if (true) {\n          warn((\"Injection \\\"\" + key + \"\\\" not found\"), vm);\n        }\n      }\n    }\n    return result\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList (\n  val,\n  render\n) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    keys = Object.keys(val);\n    ret = new Array(keys.length);\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i];\n      ret[i] = render(val[key], key, i);\n    }\n  }\n  if (isDef(ret)) {\n    (ret)._isVList = true;\n  }\n  return ret\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  var nodes;\n  if (scopedSlotFn) { // scoped slot\n    props = props || {};\n    if (bindObject) {\n      if (\"development\" !== 'production' && !isObject(bindObject)) {\n        warn(\n          'slot v-bind without argument expects an Object',\n          this\n        );\n      }\n      props = extend(extend({}, bindObject), props);\n    }\n    nodes = scopedSlotFn(props) || fallback;\n  } else {\n    var slotNodes = this.$slots[name];\n    // warn duplicate slot usage\n    if (slotNodes) {\n      if (\"development\" !== 'production' && slotNodes._rendered) {\n        warn(\n          \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n          \"- this will likely cause render errors.\",\n          this\n        );\n      }\n      slotNodes._rendered = true;\n    }\n    nodes = slotNodes || fallback;\n  }\n\n  var target = props && props.slot;\n  if (target) {\n    return this.$createElement('template', { slot: target }, nodes)\n  } else {\n    return nodes\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n/*  */\n\nfunction isKeyNotMatch (expect, actual) {\n  if (Array.isArray(expect)) {\n    return expect.indexOf(actual) === -1\n  } else {\n    return expect !== actual\n  }\n}\n\n/**\n * Runtime helper for checking keyCodes from config.\n * exposed as Vue.prototype._k\n * passing in eventKeyName as last argument separately for backwards compat\n */\nfunction checkKeyCodes (\n  eventKeyCode,\n  key,\n  builtInKeyCode,\n  eventKeyName,\n  builtInKeyName\n) {\n  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n    return isKeyNotMatch(builtInKeyName, eventKeyName)\n  } else if (mappedKeyCode) {\n    return isKeyNotMatch(mappedKeyCode, eventKeyCode)\n  } else if (eventKeyName) {\n    return hyphenate(eventKeyName) !== key\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps (\n  data,\n  tag,\n  value,\n  asProp,\n  isSync\n) {\n  if (value) {\n    if (!isObject(value)) {\n      \"development\" !== 'production' && warn(\n        'v-bind without argument expects an Object or Array value',\n        this\n      );\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      var loop = function ( key ) {\n        if (\n          key === 'class' ||\n          key === 'style' ||\n          isReservedAttribute(key)\n        ) {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key)\n            ? data.domProps || (data.domProps = {})\n            : data.attrs || (data.attrs = {});\n        }\n        if (!(key in hash)) {\n          hash[key] = value[key];\n\n          if (isSync) {\n            var on = data.on || (data.on = {});\n            on[(\"update:\" + key)] = function ($event) {\n              value[key] = $event;\n            };\n          }\n        }\n      };\n\n      for (var key in value) loop( key );\n    }\n  }\n  return data\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic (\n  index,\n  isInFor\n) {\n  var cached = this._staticTrees || (this._staticTrees = []);\n  var tree = cached[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree.\n  if (tree && !isInFor) {\n    return tree\n  }\n  // otherwise, render a fresh tree.\n  tree = cached[index] = this.$options.staticRenderFns[index].call(\n    this._renderProxy,\n    null,\n    this // for render fns generated for functional component templates\n  );\n  markStatic(tree, (\"__static__\" + index), false);\n  return tree\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce (\n  tree,\n  index,\n  key\n) {\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n  return tree\n}\n\nfunction markStatic (\n  tree,\n  key,\n  isOnce\n) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode (node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction bindObjectListeners (data, value) {\n  if (value) {\n    if (!isPlainObject(value)) {\n      \"development\" !== 'production' && warn(\n        'v-on without argument expects an Object value',\n        this\n      );\n    } else {\n      var on = data.on = data.on ? extend({}, data.on) : {};\n      for (var key in value) {\n        var existing = on[key];\n        var ours = value[key];\n        on[key] = existing ? [].concat(existing, ours) : ours;\n      }\n    }\n  }\n  return data\n}\n\n/*  */\n\nfunction installRenderHelpers (target) {\n  target._o = markOnce;\n  target._n = toNumber;\n  target._s = toString;\n  target._l = renderList;\n  target._t = renderSlot;\n  target._q = looseEqual;\n  target._i = looseIndexOf;\n  target._m = renderStatic;\n  target._f = resolveFilter;\n  target._k = checkKeyCodes;\n  target._b = bindObjectProps;\n  target._v = createTextVNode;\n  target._e = createEmptyVNode;\n  target._u = resolveScopedSlots;\n  target._g = bindObjectListeners;\n}\n\n/*  */\n\nfunction FunctionalRenderContext (\n  data,\n  props,\n  children,\n  parent,\n  Ctor\n) {\n  var options = Ctor.options;\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var contextVm;\n  if (hasOwn(parent, '_uid')) {\n    contextVm = Object.create(parent);\n    // $flow-disable-line\n    contextVm._original = parent;\n  } else {\n    // the context vm passed in is a functional context as well.\n    // in this case we want to make sure we are able to get a hold to the\n    // real context instance.\n    contextVm = parent;\n    // $flow-disable-line\n    parent = parent._original;\n  }\n  var isCompiled = isTrue(options._compiled);\n  var needNormalization = !isCompiled;\n\n  this.data = data;\n  this.props = props;\n  this.children = children;\n  this.parent = parent;\n  this.listeners = data.on || emptyObject;\n  this.injections = resolveInject(options.inject, parent);\n  this.slots = function () { return resolveSlots(children, parent); };\n\n  // support for compiled functional template\n  if (isCompiled) {\n    // exposing $options for renderStatic()\n    this.$options = options;\n    // pre-resolve slots for renderSlot()\n    this.$slots = this.slots();\n    this.$scopedSlots = data.scopedSlots || emptyObject;\n  }\n\n  if (options._scopeId) {\n    this._c = function (a, b, c, d) {\n      var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n      if (vnode && !Array.isArray(vnode)) {\n        vnode.fnScopeId = options._scopeId;\n        vnode.fnContext = parent;\n      }\n      return vnode\n    };\n  } else {\n    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };\n  }\n}\n\ninstallRenderHelpers(FunctionalRenderContext.prototype);\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  contextVm,\n  children\n) {\n  var options = Ctor.options;\n  var props = {};\n  var propOptions = options.props;\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || emptyObject);\n    }\n  } else {\n    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\n    if (isDef(data.props)) { mergeProps(props, data.props); }\n  }\n\n  var renderContext = new FunctionalRenderContext(\n    data,\n    props,\n    children,\n    contextVm,\n    Ctor\n  );\n\n  var vnode = options.render.call(null, renderContext._c, renderContext);\n\n  if (vnode instanceof VNode) {\n    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options)\n  } else if (Array.isArray(vnode)) {\n    var vnodes = normalizeChildren(vnode) || [];\n    var res = new Array(vnodes.length);\n    for (var i = 0; i < vnodes.length; i++) {\n      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options);\n    }\n    return res\n  }\n}\n\nfunction cloneAndMarkFunctionalResult (vnode, data, contextVm, options) {\n  // #7817 clone node before setting fnContext, otherwise if the node is reused\n  // (e.g. it was from a cached normal slot) the fnContext causes named slots\n  // that should not be matched to match.\n  var clone = cloneVNode(vnode);\n  clone.fnContext = contextVm;\n  clone.fnOptions = options;\n  if (data.slot) {\n    (clone.data || (clone.data = {})).slot = data.slot;\n  }\n  return clone\n}\n\nfunction mergeProps (to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n\n/*  */\n\n\n\n\n// Register the component hook to weex native render engine.\n// The hook will be triggered by native, not javascript.\n\n\n// Updates the state of the component to weex native render engine.\n\n/*  */\n\n// https://github.com/Hanks10100/weex-native-directive/tree/master/component\n\n// listening on native callback\n\n/*  */\n\n/*  */\n\n// inline hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init (\n    vnode,\n    hydrating,\n    parentElm,\n    refElm\n  ) {\n    if (\n      vnode.componentInstance &&\n      !vnode.componentInstance._isDestroyed &&\n      vnode.data.keepAlive\n    ) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    } else {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance,\n        parentElm,\n        refElm\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    }\n  },\n\n  prepatch: function prepatch (oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    );\n  },\n\n  insert: function insert (vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  },\n\n  destroy: function destroy (vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (isUndef(Ctor)) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n\n  // plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  // if at this stage it's not a constructor or an async component factory,\n  // reject.\n  if (typeof Ctor !== 'function') {\n    if (true) {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  var asyncFactory;\n  if (isUndef(Ctor.cid)) {\n    asyncFactory = Ctor;\n    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);\n    if (Ctor === undefined) {\n      // return a placeholder node for async component, which is rendered\n      // as a comment node but preserves all the raw information for the node.\n      // the information will be used for async server-rendering and hydration.\n      return createAsyncPlaceholder(\n        asyncFactory,\n        data,\n        context,\n        children,\n        tag\n      )\n    }\n  }\n\n  data = data || {};\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  // transform component v-model data into props & events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n  // functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  // so it gets processed during parent component patch.\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners & slot\n\n    // work around flow\n    var slot = data.slot;\n    data = {};\n    if (slot) {\n      data.slot = slot;\n    }\n  }\n\n  // install component management hooks onto the placeholder node\n  installComponentHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },\n    asyncFactory\n  );\n\n  // Weex specific: invoke recycle-list optimized @render function for\n  // extracting cell-slot template.\n  // https://github.com/Hanks10100/weex-native-directive/tree/master/component\n  /* istanbul ignore if */\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent, // activeInstance in lifecycle state\n  parentElm,\n  refElm\n) {\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    _parentVnode: vnode,\n    _parentElm: parentElm || null,\n    _refElm: refElm || null\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnode.componentOptions.Ctor(options)\n}\n\nfunction installComponentHooks (data) {\n  var hooks = data.hook || (data.hook = {});\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    hooks[key] = componentVNodeHooks[key];\n  }\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel (options, data) {\n  var prop = (options.model && options.model.prop) || 'value';\n  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  if (isDef(on[event])) {\n    on[event] = [data.model.callback].concat(on[event]);\n  } else {\n    on[event] = data.model.callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (isDef(data) && isDef((data).__ob__)) {\n    \"development\" !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  // object syntax in v-bind\n  if (isDef(data) && isDef(data.is)) {\n    tag = data.is;\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // warn against non-primitive key\n  if (\"development\" !== 'production' &&\n    isDef(data) && isDef(data.key) && !isPrimitive(data.key)\n  ) {\n    {\n      warn(\n        'Avoid using non-primitive value as key, ' +\n        'use string/number value instead.',\n        context\n      );\n    }\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n    typeof children[0] === 'function'\n  ) {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (Array.isArray(vnode)) {\n    return vnode\n  } else if (isDef(vnode)) {\n    if (isDef(ns)) { applyNS(vnode, ns); }\n    if (isDef(data)) { registerDeepBindings(data); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns, force) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    ns = undefined;\n    force = true;\n  }\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (isDef(child.tag) && (\n        isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {\n        applyNS(child, ns, force);\n      }\n    }\n  }\n}\n\n// ref #5318\n// necessary to ensure parent re-render when deep bindings like :style and\n// :class are used on slot nodes\nfunction registerDeepBindings (data) {\n  if (isObject(data.style)) {\n    traverse(data.style);\n  }\n  if (isObject(data.class)) {\n    traverse(data.class);\n  }\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null; // v-once cached trees\n  var options = vm.$options;\n  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n\n  // $attrs & $listeners are exposed for easier HOC creation.\n  // they need to be reactive so that HOCs using them are always updated\n  var parentData = parentVnode && parentVnode.data;\n\n  /* istanbul ignore else */\n  if (true) {\n    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n    }, true);\n    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n    }, true);\n  } else {}\n}\n\nfunction renderMixin (Vue) {\n  // install runtime convenience helpers\n  installRenderHelpers(Vue.prototype);\n\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var _parentVnode = ref._parentVnode;\n\n    // reset _rendered flag on slots for duplicate slot check\n    if (true) {\n      for (var key in vm.$slots) {\n        // $flow-disable-line\n        vm.$slots[key]._rendered = false;\n      }\n    }\n\n    if (_parentVnode) {\n      vm.$scopedSlots = _parentVnode.data.scopedSlots || emptyObject;\n    }\n\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (true) {\n        if (vm.$options.renderError) {\n          try {\n            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n          } catch (e) {\n            handleError(e, vm, \"renderError\");\n            vnode = vm._vnode;\n          }\n        } else {\n          vnode = vm._vnode;\n        }\n      } else {}\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (\"development\" !== 'production' && Array.isArray(vnode)) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n}\n\n/*  */\n\nvar uid$3 = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid$3++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if (\"development\" !== 'production' && config.performance && mark) {\n      startTag = \"vue-perf-start:\" + (vm._uid);\n      endTag = \"vue-perf-end:\" + (vm._uid);\n      mark(startTag);\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (true) {\n      initProxy(vm);\n    } else {}\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (\"development\" !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure((\"vue \" + (vm._name) + \" init\"), startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  var parentVnode = options._parentVnode;\n  opts.parent = options.parent;\n  opts._parentVnode = parentVnode;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n\n  var vnodeComponentOptions = parentVnode.componentOptions;\n  opts.propsData = vnodeComponentOptions.propsData;\n  opts._parentListeners = vnodeComponentOptions.listeners;\n  opts._renderChildren = vnodeComponentOptions.children;\n  opts._componentTag = vnodeComponentOptions.tag;\n\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var extended = Ctor.extendOptions;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) { modified = {}; }\n      modified[key] = dedupe(latest[key], extended[key], sealed[key]);\n    }\n  }\n  return modified\n}\n\nfunction dedupe (latest, extended, sealed) {\n  // compare latest and sealed to ensure lifecycle hooks won't be duplicated\n  // between merges\n  if (Array.isArray(latest)) {\n    var res = [];\n    sealed = Array.isArray(sealed) ? sealed : [sealed];\n    extended = Array.isArray(extended) ? extended : [extended];\n    for (var i = 0; i < latest.length; i++) {\n      // push original options and not sealed options to exclude duplicated options\n      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {\n        res.push(latest[i]);\n      }\n    }\n    return res\n  } else {\n    return latest\n  }\n}\n\nfunction Vue (options) {\n  if (\"development\" !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue);\nstateMixin(Vue);\neventsMixin(Vue);\nlifecycleMixin(Vue);\nrenderMixin(Vue);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));\n    if (installedPlugins.indexOf(plugin) > -1) {\n      return this\n    }\n\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    installedPlugins.push(plugin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (\"development\" !== 'production' && name) {\n      validateComponentName(name);\n    }\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (\"development\" !== 'production' && type === 'component') {\n          validateComponentName(id);\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (Array.isArray(pattern)) {\n    return pattern.indexOf(name) > -1\n  } else if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction pruneCache (keepAliveInstance, filter) {\n  var cache = keepAliveInstance.cache;\n  var keys = keepAliveInstance.keys;\n  var _vnode = keepAliveInstance._vnode;\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        pruneCacheEntry(cache, key, keys, _vnode);\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (\n  cache,\n  key,\n  keys,\n  current\n) {\n  var cached$$1 = cache[key];\n  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\n    cached$$1.componentInstance.$destroy();\n  }\n  cache[key] = null;\n  remove(keys, key);\n}\n\nvar patternTypes = [String, RegExp, Array];\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes,\n    max: [String, Number]\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n    this.keys = [];\n  },\n\n  destroyed: function destroyed () {\n    var this$1 = this;\n\n    for (var key in this$1.cache) {\n      pruneCacheEntry(this$1.cache, key, this$1.keys);\n    }\n  },\n\n  mounted: function mounted () {\n    var this$1 = this;\n\n    this.$watch('include', function (val) {\n      pruneCache(this$1, function (name) { return matches(val, name); });\n    });\n    this.$watch('exclude', function (val) {\n      pruneCache(this$1, function (name) { return !matches(val, name); });\n    });\n  },\n\n  render: function render () {\n    var slot = this.$slots.default;\n    var vnode = getFirstComponentChild(slot);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      var ref = this;\n      var include = ref.include;\n      var exclude = ref.exclude;\n      if (\n        // not included\n        (include && (!name || !matches(include, name))) ||\n        // excluded\n        (exclude && name && matches(exclude, name))\n      ) {\n        return vnode\n      }\n\n      var ref$1 = this;\n      var cache = ref$1.cache;\n      var keys = ref$1.keys;\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (cache[key]) {\n        vnode.componentInstance = cache[key].componentInstance;\n        // make current key freshest\n        remove(keys, key);\n        keys.push(key);\n      } else {\n        cache[key] = vnode;\n        keys.push(key);\n        // prune oldest entry\n        if (this.max && keys.length > parseInt(this.max)) {\n          pruneCacheEntry(cache, keys[0], keys, this._vnode);\n        }\n      }\n\n      vnode.data.keepAlive = true;\n    }\n    return vnode || (slot && slot[0])\n  }\n}\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n}\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (true) {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue);\n\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n  get: function get () {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext\n  }\n});\n\n// expose FunctionalRenderContext for ssr runtime helper installation\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\n  value: FunctionalRenderContext\n});\n\nVue.version = '2.5.17';\n\n/*  */\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nvar isReservedAttr = makeMap('style,class');\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select,progress');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode && childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode && parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return renderClass(data.staticClass, data.class)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class)\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction renderClass (\n  staticClass,\n  dynamicClass\n) {\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  if (Array.isArray(value)) {\n    return stringifyArray(value)\n  }\n  if (isObject(value)) {\n    return stringifyObject(value)\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction stringifyArray (value) {\n  var res = '';\n  var stringified;\n  for (var i = 0, l = value.length; i < l; i++) {\n    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n      if (res) { res += ' '; }\n      res += stringified;\n    }\n  }\n  return res\n}\n\nfunction stringifyObject (value) {\n  var res = '';\n  for (var key in value) {\n    if (value[key]) {\n      if (res) { res += ' '; }\n      res += key;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template,blockquote,iframe,tfoot'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isPreTag = function (tag) { return tag === 'pre'; };\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      \"development\" !== 'production' && warn(\n        'Cannot find element: ' + el\n      );\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setStyleScope (node, scopeId) {\n  node.setAttribute(scopeId, '');\n}\n\n\nvar nodeOps = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateElementNS: createElementNS,\n\tcreateTextNode: createTextNode,\n\tcreateComment: createComment,\n\tinsertBefore: insertBefore,\n\tremoveChild: removeChild,\n\tappendChild: appendChild,\n\tparentNode: parentNode,\n\tnextSibling: nextSibling,\n\ttagName: tagName,\n\tsetTextContent: setTextContent,\n\tsetStyleScope: setStyleScope\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n}\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!isDef(key)) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (!Array.isArray(refs[key])) {\n        refs[key] = [ref];\n      } else if (refs[key].indexOf(ref) < 0) {\n        // $flow-disable-line\n        refs[key].push(ref);\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key && (\n      (\n        a.tag === b.tag &&\n        a.isComment === b.isComment &&\n        isDef(a.data) === isDef(b.data) &&\n        sameInputType(a, b)\n      ) || (\n        isTrue(a.isAsyncPlaceholder) &&\n        a.asyncFactory === b.asyncFactory &&\n        isUndef(b.asyncFactory.error)\n      )\n    )\n  )\n}\n\nfunction sameInputType (a, b) {\n  if (a.tag !== 'input') { return true }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove () {\n      if (--remove.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove.listeners = listeners;\n    return remove\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  function isUnknownElement$$1 (vnode, inVPre) {\n    return (\n      !inVPre &&\n      !vnode.ns &&\n      !(\n        config.ignoredElements.length &&\n        config.ignoredElements.some(function (ignore) {\n          return isRegExp(ignore)\n            ? ignore.test(vnode.tag)\n            : ignore === vnode.tag\n        })\n      ) &&\n      config.isUnknownElement(vnode.tag)\n    )\n  }\n\n  var creatingElmInVPre = 0;\n\n  function createElm (\n    vnode,\n    insertedVnodeQueue,\n    parentElm,\n    refElm,\n    nested,\n    ownerArray,\n    index\n  ) {\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\n      // This vnode was used in a previous render!\n      // now it's used as a new node, overwriting its elm would cause\n      // potential patch errors down the road when it's used as an insertion\n      // reference node. Instead, we clone the node on-demand before creating\n      // associated DOM element for it.\n      vnode = ownerArray[index] = cloneVNode(vnode);\n    }\n\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (true) {\n        if (data && data.pre) {\n          creatingElmInVPre++;\n        }\n        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (\"development\" !== 'production' && data && data.pre) {\n        creatingElmInVPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */, parentElm, refElm);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      vnode.data.pendingInsert = null;\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref$$1) {\n    if (isDef(parent)) {\n      if (isDef(ref$$1)) {\n        if (ref$$1.parentNode === parent) {\n          nodeOps.insertBefore(parent, elm, ref$$1);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      if (true) {\n        checkDuplicateKeys(children);\n      }\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    if (isDef(i = vnode.fnScopeId)) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    } else {\n      var ancestor = vnode;\n      while (ancestor) {\n        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n          nodeOps.setStyleScope(vnode.elm, i);\n        }\n        ancestor = ancestor.parent;\n      }\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) &&\n      i !== vnode.context &&\n      i !== vnode.fnContext &&\n      isDef(i = i.$options._scopeId)\n    ) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    if (true) {\n      checkDuplicateKeys(newCh);\n    }\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key)\n          ? oldKeyToIdx[newStartVnode.key]\n          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n        } else {\n          vnodeToMove = oldCh[idxInOld];\n          if (sameVnode(vnodeToMove, newStartVnode)) {\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n          }\n        }\n        newStartVnode = newCh[++newStartIdx];\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function checkDuplicateKeys (children) {\n    var seenKeys = {};\n    for (var i = 0; i < children.length; i++) {\n      var vnode = children[i];\n      var key = vnode.key;\n      if (isDef(key)) {\n        if (seenKeys[key]) {\n          warn(\n            (\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\"),\n            vnode.context\n          );\n        } else {\n          seenKeys[key] = true;\n        }\n      }\n    }\n  }\n\n  function findIdxInOld (node, oldCh, start, end) {\n    for (var i = start; i < end; i++) {\n      var c = oldCh[i];\n      if (isDef(c) && sameVnode(node, c)) { return i }\n    }\n  }\n\n  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return\n    }\n\n    var elm = vnode.elm = oldVnode.elm;\n\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\n      if (isDef(vnode.asyncFactory.resolved)) {\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n      } else {\n        vnode.isAsyncPlaceholder = true;\n      }\n      return\n    }\n\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) &&\n      isTrue(oldVnode.isStatic) &&\n      vnode.key === oldVnode.key &&\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n    ) {\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var hydrationBailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  // Note: style is excluded because it relies on initial clone for future\n  // deep updates (#7063).\n  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {\n    var i;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    inVPre = inVPre || (data && data.pre);\n    vnode.elm = elm;\n\n    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n      vnode.isAsyncPlaceholder = true;\n      return true\n    }\n    // assert node match\n    if (true) {\n      if (!assertNodeMatch(elm, vnode, inVPre)) {\n        return false\n      }\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          // v-html and domProps: innerHTML\n          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n            if (i !== elm.innerHTML) {\n              /* istanbul ignore if */\n              if (\"development\" !== 'production' &&\n                typeof console !== 'undefined' &&\n                !hydrationBailed\n              ) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('server innerHTML: ', i);\n                console.warn('client innerHTML: ', elm.innerHTML);\n              }\n              return false\n            }\n          } else {\n            // iterate and compare children lists\n            var childrenMatch = true;\n            var childNode = elm.firstChild;\n            for (var i$1 = 0; i$1 < children.length; i$1++) {\n              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                childrenMatch = false;\n                break\n              }\n              childNode = childNode.nextSibling;\n            }\n            // if childNode is not null, it means the actual childNodes list is\n            // longer than the virtual children list.\n            if (!childrenMatch || childNode) {\n              /* istanbul ignore if */\n              if (\"development\" !== 'production' &&\n                typeof console !== 'undefined' &&\n                !hydrationBailed\n              ) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n              }\n              return false\n            }\n          }\n        }\n      }\n      if (isDef(data)) {\n        var fullInvoke = false;\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            fullInvoke = true;\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n        if (!fullInvoke && data['class']) {\n          // ensure collecting deps for deep class bindings for future updates\n          traverse(data['class']);\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode, inVPre) {\n    if (isDef(vnode.tag)) {\n      return vnode.tag.indexOf('vue-component') === 0 || (\n        !isUnknownElement$$1(vnode, inVPre) &&\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (true) {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm$1 = nodeOps.parentNode(oldElm);\n\n        // create new node\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm$1,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        // update parent placeholder node element, recursively\n        if (isDef(vnode.parent)) {\n          var ancestor = vnode.parent;\n          var patchable = isPatchable(vnode);\n          while (ancestor) {\n            for (var i = 0; i < cbs.destroy.length; ++i) {\n              cbs.destroy[i](ancestor);\n            }\n            ancestor.elm = vnode.elm;\n            if (patchable) {\n              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                cbs.create[i$1](emptyNode, ancestor);\n              }\n              // #6513\n              // invoke insert hooks that may have been merged by create hooks.\n              // e.g. for directives that uses the \"inserted\" hook.\n              var insert = ancestor.data.hook.insert;\n              if (insert.merged) {\n                // start at index 1 to avoid re-invoking component mounted hook\n                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                  insert.fns[i$2]();\n                }\n              }\n            } else {\n              registerRef(ancestor);\n            }\n            ancestor = ancestor.parent;\n          }\n        }\n\n        // destroy old node\n        if (isDef(parentElm$1)) {\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n}\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode, 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode, 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    // $flow-disable-line\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      // $flow-disable-line\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  // $flow-disable-line\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\n    }\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n]\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  var opts = vnode.componentOptions;\n  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n    return\n  }\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  // #6666: IE/Edge forces progress value down to 1 before setting a max\n  /* istanbul ignore if */\n  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (el.tagName.indexOf('-') > -1) {\n    baseSetAttr(el, key, value);\n  } else if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // technically allowfullscreen is a boolean attribute for <iframe>,\n      // but Flash expects a value of \"true\" when used on <embed> tag\n      value = key === 'allowfullscreen' && el.tagName === 'EMBED'\n        ? 'true'\n        : key;\n      el.setAttribute(key, value);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    baseSetAttr(el, key, value);\n  }\n}\n\nfunction baseSetAttr (el, key, value) {\n  if (isFalsyAttrValue(value)) {\n    el.removeAttribute(key);\n  } else {\n    // #7138: IE10 & 11 fires input event when setting placeholder on\n    // <textarea>... block the first input event and remove the blocker\n    // immediately.\n    /* istanbul ignore if */\n    if (\n      isIE && !isIE9 &&\n      el.tagName === 'TEXTAREA' &&\n      key === 'placeholder' && !el.__ieph\n    ) {\n      var blocker = function (e) {\n        e.stopImmediatePropagation();\n        el.removeEventListener('input', blocker);\n      };\n      el.addEventListener('input', blocker);\n      // $flow-disable-line\n      el.__ieph = true; /* IE placeholder patched */\n    }\n    el.setAttribute(key, value);\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n}\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (\n    isUndef(data.staticClass) &&\n    isUndef(data.class) && (\n      isUndef(oldData) || (\n        isUndef(oldData.staticClass) &&\n        isUndef(oldData.class)\n      )\n    )\n  ) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n}\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters (exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n    } else if (\n      c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C &&\n      exp.charCodeAt(i - 1) !== 0x7C &&\n      !curly && !square && !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break         // \"\n        case 0x27: inSingle = true; break         // '\n        case 0x60: inTemplateString = true; break // `\n        case 0x28: paren++; break                 // (\n        case 0x29: paren--; break                 // )\n        case 0x5B: square++; break                // [\n        case 0x5D: square--; break                // ]\n        case 0x7B: curly++; break                 // {\n        case 0x7D: curly--; break                 // }\n      }\n      if (c === 0x2f) { // /\n        var j = i - 1;\n        var p = (void 0);\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') { break }\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter () {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression\n}\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + (args !== ')' ? ',' + args : args))\n  }\n}\n\n/*  */\n\nfunction baseWarn (msg) {\n  console.error((\"[Vue compiler]: \" + msg));\n}\n\nfunction pluckModuleFunction (\n  modules,\n  key\n) {\n  return modules\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n    : []\n}\n\nfunction addProp (el, name, value) {\n  (el.props || (el.props = [])).push({ name: name, value: value });\n  el.plain = false;\n}\n\nfunction addAttr (el, name, value) {\n  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n  el.plain = false;\n}\n\n// add a raw attr (use this in preTransforms)\nfunction addRawAttr (el, name, value) {\n  el.attrsMap[name] = value;\n  el.attrsList.push({ name: name, value: value });\n}\n\nfunction addDirective (\n  el,\n  name,\n  rawName,\n  value,\n  arg,\n  modifiers\n) {\n  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n  el.plain = false;\n}\n\nfunction addHandler (\n  el,\n  name,\n  value,\n  modifiers,\n  important,\n  warn\n) {\n  modifiers = modifiers || emptyObject;\n  // warn prevent and passive modifier\n  /* istanbul ignore if */\n  if (\n    \"development\" !== 'production' && warn &&\n    modifiers.prevent && modifiers.passive\n  ) {\n    warn(\n      'passive and prevent can\\'t be used together. ' +\n      'Passive handler can\\'t prevent default event.'\n    );\n  }\n\n  // check capture modifier\n  if (modifiers.capture) {\n    delete modifiers.capture;\n    name = '!' + name; // mark the event as captured\n  }\n  if (modifiers.once) {\n    delete modifiers.once;\n    name = '~' + name; // mark the event as once\n  }\n  /* istanbul ignore if */\n  if (modifiers.passive) {\n    delete modifiers.passive;\n    name = '&' + name; // mark the event as passive\n  }\n\n  // normalize click.right and click.middle since they don't actually fire\n  // this is technically browser-specific, but at least for now browsers are\n  // the only target envs that have right/middle clicks.\n  if (name === 'click') {\n    if (modifiers.right) {\n      name = 'contextmenu';\n      delete modifiers.right;\n    } else if (modifiers.middle) {\n      name = 'mouseup';\n    }\n  }\n\n  var events;\n  if (modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n\n  var newHandler = {\n    value: value.trim()\n  };\n  if (modifiers !== emptyObject) {\n    newHandler.modifiers = modifiers;\n  }\n\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n\n  el.plain = false;\n}\n\nfunction getBindingAttr (\n  el,\n  name,\n  getStatic\n) {\n  var dynamicValue =\n    getAndRemoveAttr(el, ':' + name) ||\n    getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue)\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue)\n    }\n  }\n}\n\n// note: this only removes the attr from the Array (attrsList) so that it\n// doesn't get processed by processAttrs.\n// By default it does NOT remove it from the map (attrsMap) because the map is\n// needed during codegen.\nfunction getAndRemoveAttr (\n  el,\n  name,\n  removeFromMap\n) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break\n      }\n    }\n  }\n  if (removeFromMap) {\n    delete el.attrsMap[name];\n  }\n  return val\n}\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel (\n  el,\n  value,\n  modifiers\n) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n  if (trim) {\n    valueExpression =\n      \"(typeof \" + baseValueExpression + \" === 'string'\" +\n      \"? \" + baseValueExpression + \".trim()\" +\n      \": \" + baseValueExpression + \")\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n  var assignment = genAssignmentCode(value, valueExpression);\n\n  el.model = {\n    value: (\"(\" + value + \")\"),\n    expression: (\"\\\"\" + value + \"\\\"\"),\n    callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n  };\n}\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode (\n  value,\n  assignment\n) {\n  var res = parseModel(value);\n  if (res.key === null) {\n    return (value + \"=\" + assignment)\n  } else {\n    return (\"$set(\" + (res.exp) + \", \" + (res.key) + \", \" + assignment + \")\")\n  }\n}\n\n/**\n * Parse a v-model expression into a base path and a final key segment.\n * Handles both dot-path and possible square brackets.\n *\n * Possible cases:\n *\n * - test\n * - test[key]\n * - test[test1[key]]\n * - test[\"a\"][key]\n * - xxx.test[a[a].test1[key]]\n * - test.xxx.a[\"asa\"][test1[key]]\n *\n */\n\nvar len;\nvar str;\nvar chr;\nvar index$1;\nvar expressionPos;\nvar expressionEndPos;\n\n\n\nfunction parseModel (val) {\n  // Fix https://github.com/vuejs/vue/pull/7730\n  // allow v-model=\"obj.val \" (trailing whitespace)\n  val = val.trim();\n  len = val.length;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    index$1 = val.lastIndexOf('.');\n    if (index$1 > -1) {\n      return {\n        exp: val.slice(0, index$1),\n        key: '\"' + val.slice(index$1 + 1) + '\"'\n      }\n    } else {\n      return {\n        exp: val,\n        key: null\n      }\n    }\n  }\n\n  str = val;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.slice(0, expressionPos),\n    key: val.slice(expressionPos + 1, expressionEndPos)\n  }\n}\n\nfunction next () {\n  return str.charCodeAt(++index$1)\n}\n\nfunction eof () {\n  return index$1 >= len\n}\n\nfunction isStringStart (chr) {\n  return chr === 0x22 || chr === 0x27\n}\n\nfunction parseBracket (chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue\n    }\n    if (chr === 0x5B) { inBracket++; }\n    if (chr === 0x5D) { inBracket--; }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break\n    }\n  }\n}\n\nfunction parseString (chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break\n    }\n  }\n}\n\n/*  */\n\nvar warn$1;\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model (\n  el,\n  dir,\n  _warn\n) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (true) {\n    // inputs with type=\"file\" are read only and setting the input's\n    // value will throw an error.\n    if (tag === 'input' && type === 'file') {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n        \"File inputs are read only. Use a v-on:change listener instead.\"\n      );\n    }\n  }\n\n  if (el.component) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (true) {\n    warn$1(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n      \"v-model is not supported on this element type. \" +\n      'If you are working with contenteditable, it\\'s recommended to ' +\n      'wrap a library dedicated for that purpose inside a custom component.'\n    );\n  }\n\n  // ensure runtime directive metadata\n  return true\n}\n\nfunction genCheckboxModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked',\n    \"Array.isArray(\" + value + \")\" +\n    \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n      trueValueBinding === 'true'\n        ? (\":(\" + value + \")\")\n        : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n    )\n  );\n  addHandler(el, 'change',\n    \"var $$a=\" + value + \",\" +\n        '$$el=$event.target,' +\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n    'if(Array.isArray($$a)){' +\n      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n          '$$i=_i($$a,$$v);' +\n      \"if($$el.checked){$$i<0&&(\" + (genAssignmentCode(value, '$$a.concat([$$v])')) + \")}\" +\n      \"else{$$i>-1&&(\" + (genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')) + \")}\" +\n    \"}else{\" + (genAssignmentCode(value, '$$c')) + \"}\",\n    null, true\n  );\n}\n\nfunction genRadioModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" +\n    \".call($event.target.options,function(o){return o.selected})\" +\n    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n    \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + (genAssignmentCode(value, assignment));\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel (\n  el,\n  value,\n  modifiers\n) {\n  var type = el.attrsMap.type;\n\n  // warn if v-bind:value conflicts with v-model\n  // except for inputs with v-bind:type\n  if (true) {\n    var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];\n    var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n    if (value$1 && !typeBinding) {\n      var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';\n      warn$1(\n        binding + \"=\\\"\" + value$1 + \"\\\" conflicts with v-model on the same element \" +\n        'because the latter already expands to a value binding internally'\n      );\n    }\n  }\n\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy\n    ? 'change'\n    : type === 'range'\n      ? RANGE_TOKEN\n      : 'input';\n\n  var valueExpression = '$event.target.value';\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', (\"(\" + value + \")\"));\n  addHandler(el, event, code, null, true);\n  if (trim || number) {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents (on) {\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    var event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  // This was originally intended to fix #4521 but no longer necessary\n  // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n  /* istanbul ignore if */\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction createOnceHandler (handler, event, capture) {\n  var _target = target$1; // save current target element in closure\n  return function onceHandler () {\n    var res = handler.apply(null, arguments);\n    if (res !== null) {\n      remove$2(event, onceHandler, capture, _target);\n    }\n  }\n}\n\nfunction add$1 (\n  event,\n  handler,\n  once$$1,\n  capture,\n  passive\n) {\n  handler = withMacroTask(handler);\n  if (once$$1) { handler = createOnceHandler(handler, event, capture); }\n  target$1.addEventListener(\n    event,\n    handler,\n    supportsPassive\n      ? { capture: capture, passive: passive }\n      : capture\n  );\n}\n\nfunction remove$2 (\n  event,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(\n    event,\n    handler._withTask || handler,\n    capture\n  );\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, vnode.context);\n  target$1 = undefined;\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n}\n\n/*  */\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (isUndef(props[key])) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n      // #6601 work around Chrome version <= 55 bug where single textNode\n      // replaced by innerHTML/textContent retains its parentNode property\n      if (elm.childNodes.length === 1) {\n        elm.removeChild(elm.childNodes[0]);\n      }\n    }\n\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = isUndef(cur) ? '' : String(cur);\n      if (shouldUpdateValue(elm, strCur)) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (elm, checkVal) {\n  return (!elm.composing && (\n    elm.tagName === 'OPTION' ||\n    isNotInFocusAndDirty(elm, checkVal) ||\n    isDirtyWithModifiers(elm, checkVal)\n  ))\n}\n\nfunction isNotInFocusAndDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is\n  // not equal to the updated value\n  var notInFocus = true;\n  // #6157\n  // work around IE bug when accessing document.activeElement in an iframe\n  try { notInFocus = document.activeElement !== elm; } catch (e) {}\n  return notInFocus && elm.value !== checkVal\n}\n\nfunction isDirtyWithModifiers (elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if (isDef(modifiers)) {\n    if (modifiers.lazy) {\n      // inputs with lazy should only be updated when not in focus\n      return false\n    }\n    if (modifiers.number) {\n      return toNumber(value) !== toNumber(newVal)\n    }\n    if (modifiers.trim) {\n      return value.trim() !== newVal.trim()\n    }\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n}\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (\n        childNode && childNode.data &&\n        (styleData = normalizeStyleData(childNode.data))\n      ) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\n\nvar emptyStyle;\nvar normalize = cached(function (prop) {\n  emptyStyle = emptyStyle || document.createElement('div').style;\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in emptyStyle)) {\n    return prop\n  }\n  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < vendorNames.length; i++) {\n    var name = vendorNames[i] + capName;\n    if (name in emptyStyle) {\n      return name\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) &&\n    isUndef(oldData.staticStyle) && isUndef(oldData.style)\n  ) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likely wants\n  // to mutate it.\n  vnode.data.normalizedStyle = isDef(style.__ob__)\n    ? extend({}, style)\n    : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n}\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n    if (!el.classList.length) {\n      el.removeAttribute('class');\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    cur = cur.trim();\n    if (cur) {\n      el.setAttribute('class', cur);\n    } else {\n      el.removeAttribute('class');\n    }\n  }\n}\n\n/*  */\n\nfunction resolveTransition (def) {\n  if (!def) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def === 'object') {\n    var res = {};\n    if (def.css !== false) {\n      extend(res, autoCssTransition(def.name || 'v'));\n    }\n    extend(res, def);\n    return res\n  } else if (typeof def === 'string') {\n    return autoCssTransition(def)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveClass: (name + \"-leave\"),\n    leaveToClass: (name + \"-leave-to\"),\n    leaveActiveClass: (name + \"-leave-active\")\n  }\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined\n  ) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined\n  ) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser\n  ? window.requestAnimationFrame\n    ? window.requestAnimationFrame.bind(window)\n    : setTimeout\n  : /* istanbul ignore next */ function (fn) { return fn(); };\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n  if (transitionClasses.indexOf(cls) < 0) {\n    transitionClasses.push(cls);\n    addClass(el, cls);\n  }\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\nfunction toMs (s) {\n  return Number(s.slice(0, -1)) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear && appearClass\n    ? appearClass\n    : enterClass;\n  var activeClass = isAppear && appearActiveClass\n    ? appearActiveClass\n    : enterActiveClass;\n  var toClass = isAppear && appearToClass\n    ? appearToClass\n    : enterToClass;\n\n  var beforeEnterHook = isAppear\n    ? (beforeAppear || beforeEnter)\n    : beforeEnter;\n  var enterHook = isAppear\n    ? (typeof appear === 'function' ? appear : enter)\n    : enter;\n  var afterEnterHook = isAppear\n    ? (afterAppear || afterEnter)\n    : afterEnter;\n  var enterCancelledHook = isAppear\n    ? (appearCancelled || enterCancelled)\n    : enterCancelled;\n\n  var explicitEnterDuration = toNumber(\n    isObject(duration)\n      ? duration.enter\n      : duration\n  );\n\n  if (\"development\" !== 'production' && explicitEnterDuration != null) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode, 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n        pendingNode.tag === vnode.tag &&\n        pendingNode.elm._leaveCb\n      ) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled) {\n        addTransitionClass(el, toClass);\n        if (!userWantsControl) {\n          if (isValidDuration(explicitEnterDuration)) {\n            setTimeout(cb, explicitEnterDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data) || el.nodeType !== 1) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._leaveCb)) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(\n    isObject(duration)\n      ? duration.leave\n      : duration\n  );\n\n  if (\"development\" !== 'production' && isDef(explicitLeaveDuration)) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled) {\n          addTransitionClass(el, leaveToClass);\n          if (!userWantsControl) {\n            if (isValidDuration(explicitLeaveDuration)) {\n              setTimeout(cb, explicitLeaveDuration);\n            } else {\n              whenTransitionEnds(el, type, cb);\n            }\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration (val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n      \"got \" + (JSON.stringify(val)) + \".\",\n      vnode.context\n    );\n  } else if (isNaN(val)) {\n    warn(\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\n      'the duration expression might be incorrect.',\n      vnode.context\n    );\n  }\n}\n\nfunction isValidDuration (val) {\n  return typeof val === 'number' && !isNaN(val)\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength (fn) {\n  if (isUndef(fn)) {\n    return false\n  }\n  var invokerFns = fn.fns;\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(\n      Array.isArray(invokerFns)\n        ? invokerFns[0]\n        : invokerFns\n    )\n  } else {\n    return (fn._length || fn.length) > 1\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1 (vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {}\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n]\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar directive = {\n  inserted: function inserted (el, binding, vnode, oldVnode) {\n    if (vnode.tag === 'select') {\n      // #6903\n      if (oldVnode.elm && !oldVnode.elm._vOptions) {\n        mergeVNodeHook(vnode, 'postpatch', function () {\n          directive.componentUpdated(el, binding, vnode);\n        });\n      } else {\n        setSelected(el, binding, vnode.context);\n      }\n      el._vOptions = [].map.call(el.options, getValue);\n    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        el.addEventListener('compositionstart', onCompositionStart);\n        el.addEventListener('compositionend', onCompositionEnd);\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n        el.addEventListener('change', onCompositionEnd);\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var prevOptions = el._vOptions;\n      var curOptions = el._vOptions = [].map.call(el.options, getValue);\n      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {\n        // trigger change event if\n        // no matching option found for at least one value\n        var needReset = el.multiple\n          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })\n          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n        if (needReset) {\n          trigger(el, 'change');\n        }\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  actuallySetSelected(el, binding, vm);\n  /* istanbul ignore if */\n  if (isIE || isEdge) {\n    setTimeout(function () {\n      actuallySetSelected(el, binding, vm);\n    }, 0);\n  }\n}\n\nfunction actuallySetSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    \"development\" !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  return options.every(function (o) { return !looseEqual(o, value); })\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) { return }\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition$$1) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (!value === !oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    if (transition$$1) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n}\n\nvar platformDirectives = {\n  model: directive,\n  show: show\n}\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    })\n  }\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) { return c.tag || isAsyncPlaceholder(c); });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (\"development\" !== 'production' && children.length > 1) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (\"development\" !== 'production' &&\n      mode && mode !== 'in-out' && mode !== 'out-in'\n    ) {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    child.key = child.key == null\n      ? child.isComment\n        ? id + 'comment'\n        : id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n      child.data.show = true;\n    }\n\n    if (\n      oldChild &&\n      oldChild.data &&\n      !isSameChild(child, oldChild) &&\n      !isAsyncPlaceholder(oldChild) &&\n      // #6687 component root is a comment node\n      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)\n    ) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild.data.transition = extend({}, data);\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        if (isAsyncPlaceholder(child)) {\n          return oldRawChild\n        }\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n      }\n    }\n\n    return rawChild\n  }\n}\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final desired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (true) {\n          var opts = c.componentOptions;\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  beforeUpdate: function beforeUpdate () {\n    // force removing pass\n    this.__patch__(\n      this._vnode,\n      this.kept,\n      false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    // assign to this to avoid being removed in tree-shaking\n    // $flow-disable-line\n    this._reflow = document.body.offsetHeight;\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      /* istanbul ignore if */\n      if (this._hasMove) {\n        return this._hasMove\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n}\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n}\n\n/*  */\n\n// install platform specific utils\nVue.config.mustUseProp = mustUseProp;\nVue.config.isReservedTag = isReservedTag;\nVue.config.isReservedAttr = isReservedAttr;\nVue.config.getTagNamespace = getTagNamespace;\nVue.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue.options.directives, platformDirectives);\nextend(Vue.options.components, platformComponents);\n\n// install platform patch function\nVue.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nif (inBrowser) {\n  setTimeout(function () {\n    if (config.devtools) {\n      if (devtools) {\n        devtools.emit('init', Vue);\n      } else if (\n        \"development\" !== 'production' &&\n        \"development\" !== 'test' &&\n        isChrome\n      ) {\n        console[console.info ? 'info' : 'log'](\n          'Download the Vue Devtools extension for a better development experience:\\n' +\n          'https://github.com/vuejs/vue-devtools'\n        );\n      }\n    }\n    if (\"development\" !== 'production' &&\n      \"development\" !== 'test' &&\n      config.productionTip !== false &&\n      typeof console !== 'undefined'\n    ) {\n      console[console.info ? 'info' : 'log'](\n        \"You are running Vue in development mode.\\n\" +\n        \"Make sure to turn on production mode when deploying for production.\\n\" +\n        \"See more tips at https://vuejs.org/guide/deployment.html\"\n      );\n    }\n  }, 0);\n}\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n});\n\n\n\nfunction parseText (\n  text,\n  delimiters\n) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return\n  }\n  var tokens = [];\n  var rawTokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index, tokenValue;\n  while ((match = tagRE.exec(text))) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      rawTokens.push(tokenValue = text.slice(lastIndex, index));\n      tokens.push(JSON.stringify(tokenValue));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push((\"_s(\" + exp + \")\"));\n    rawTokens.push({ '@binding': exp });\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    rawTokens.push(tokenValue = text.slice(lastIndex));\n    tokens.push(JSON.stringify(tokenValue));\n  }\n  return {\n    expression: tokens.join('+'),\n    tokens: rawTokens\n  }\n}\n\n/*  */\n\nfunction transformNode (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (\"development\" !== 'production' && staticClass) {\n    var res = parseText(staticClass, options.delimiters);\n    if (res) {\n      warn(\n        \"class=\\\"\" + staticClass + \"\\\": \" +\n        'Interpolation inside attributes has been removed. ' +\n        'Use v-bind or the colon shorthand instead. For example, ' +\n        'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.'\n      );\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData (el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + (el.staticClass) + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + (el.classBinding) + \",\";\n  }\n  return data\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData\n}\n\n/*  */\n\nfunction transformNode$1 (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (true) {\n      var res = parseText(staticStyle, options.delimiters);\n      if (res) {\n        warn(\n          \"style=\\\"\" + staticStyle + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.'\n        );\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$1 (el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + (el.styleBinding) + \"),\";\n  }\n  return data\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$1\n}\n\n/*  */\n\nvar decoder;\n\nvar he = {\n  decode: function decode (html) {\n    decoder = decoder || document.createElement('div');\n    decoder.innerHTML = html;\n    return decoder.textContent\n  }\n}\n\n/*  */\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr'\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track'\n);\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\n\n// Regular Expressions for parsing tags and attributes\nvar attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\n// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n// but for Vue templates we can enforce a simple charset\nvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\nvar qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\nvar startTagOpen = new RegExp((\"^<\" + qnameCapture));\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp((\"^<\\\\/\" + qnameCapture + \"[^>]*>\"));\nvar doctype = /^<!DOCTYPE [^>]+>/i;\n// #7298: escape - to avoid being pased as HTML comment when inlined in page\nvar comment = /^<!\\--/;\nvar conditionalComment = /^<!\\[/;\n\nvar IS_REGEX_CAPTURING_BROKEN = false;\n'x'.replace(/x(.)?/g, function (m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === '';\n});\n\n// Special Elements (can contain anything)\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\n\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n',\n  '&#9;': '\\t'\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10|#9);/g;\n\n// #5992\nvar isIgnoreNewlineTag = makeMap('pre,textarea', true);\nvar shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n'; };\n\nfunction decodeAttr (value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) { return decodingMap[match]; })\n}\n\nfunction parseHTML (html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a plaintext content element like script/style\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            if (options.shouldKeepComment) {\n              options.comment(html.substring(4, commentEnd));\n            }\n            advance(commentEnd + 3);\n            continue\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          if (shouldIgnoreFirstNewline(lastTag, html)) {\n            advance(1);\n          }\n          continue\n        }\n      }\n\n      var text = (void 0), rest = (void 0), next = (void 0);\n      if (textEnd >= 0) {\n        rest = html.slice(textEnd);\n        while (\n          !endTag.test(rest) &&\n          !startTagOpen.test(rest) &&\n          !comment.test(rest) &&\n          !conditionalComment.test(rest)\n        ) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest.indexOf('<', 1);\n          if (next < 0) { break }\n          textEnd += next;\n          rest = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n        advance(textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n        html = '';\n      }\n\n      if (options.chars && text) {\n        options.chars(text);\n      }\n    } else {\n      var endTagLength = 0;\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text\n            .replace(/<!\\--([\\s\\S]*?)-->/g, '$1') // #7298\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (shouldIgnoreFirstNewline(stackedTag, text)) {\n          text = text.slice(1);\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return ''\n      });\n      index += html.length - rest$1.length;\n      html = rest$1;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (\"development\" !== 'production' && !stack.length && options.warn) {\n        options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"));\n      }\n      break\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance (n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag () {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match\n      }\n    }\n  }\n\n  function handleStartTag (match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === '') { delete args[3]; }\n        if (args[4] === '') { delete args[4]; }\n        if (args[5] === '') { delete args[5]; }\n      }\n      var value = args[3] || args[4] || args[5] || '';\n      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'\n        ? options.shouldDecodeNewlinesForHref\n        : options.shouldDecodeNewlines;\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(value, shouldDecodeNewlines)\n      };\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag (tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) { start = index; }\n    if (end == null) { end = index; }\n\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n    }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (\"development\" !== 'production' &&\n          (i > pos || !tagName) &&\n          options.warn\n        ) {\n          options.warn(\n            (\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\")\n          );\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /([^]*?)\\s+(?:in|of)\\s+([^]*)/;\nvar forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\nvar stripParensRE = /^\\(|\\)$/g;\n\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^v-bind:/;\nvar modifierRE = /\\.[^.]+/g;\n\nvar decodeHTMLCached = cached(he.decode);\n\n// configurable state\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\n\n\n\nfunction createASTElement (\n  tag,\n  attrs,\n  parent\n) {\n  return {\n    type: 1,\n    tag: tag,\n    attrsList: attrs,\n    attrsMap: makeAttrsMap(attrs),\n    parent: parent,\n    children: []\n  }\n}\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse (\n  template,\n  options\n) {\n  warn$2 = options.warn || baseWarn;\n\n  platformIsPreTag = options.isPreTag || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformGetTagNamespace = options.getTagNamespace || no;\n\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n\n  delimiters = options.delimiters;\n\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce (msg) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg);\n    }\n  }\n\n  function closeElement (element) {\n    // check pre state\n    if (element.pre) {\n      inVPre = false;\n    }\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    }\n    // apply post-transforms\n    for (var i = 0; i < postTransforms.length; i++) {\n      postTransforms[i](element, options);\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n    shouldKeepComment: options.comments,\n    start: function start (tag, attrs, unary) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = createASTElement(tag, attrs, currentParent);\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n        \"development\" !== 'production' && warn$2(\n          'Templates should only be responsible for mapping the state to the ' +\n          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n          \"<\" + tag + \">\" + ', as they will not be parsed.'\n        );\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        element = preTransforms[i](element, options) || element;\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else if (!element.processed) {\n        // structural directives\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n        // element-scope stuff\n        processElement(element, options);\n      }\n\n      function checkRootConstraints (el) {\n        if (true) {\n          if (el.tag === 'slot' || el.tag === 'template') {\n            warnOnce(\n              \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n              'contain multiple nodes.'\n            );\n          }\n          if (el.attrsMap.hasOwnProperty('v-for')) {\n            warnOnce(\n              'Cannot use v-for on stateful component root element because ' +\n              'it renders multiple elements.'\n            );\n          }\n        }\n      }\n\n      // tree management\n      if (!root) {\n        root = element;\n        checkRootConstraints(root);\n      } else if (!stack.length) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          checkRootConstraints(element);\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else if (true) {\n          warnOnce(\n            \"Component template should contain exactly one root element. \" +\n            \"If you are using v-if on multiple elements, \" +\n            \"use v-else-if to chain them instead.\"\n          );\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else if (element.slotScope) { // scoped slot\n          currentParent.plain = false;\n          var name = element.slotTarget || '\"default\"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        } else {\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        closeElement(element);\n      }\n    },\n\n    end: function end () {\n      // remove trailing whitespace\n      var element = stack[stack.length - 1];\n      var lastNode = element.children[element.children.length - 1];\n      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\n        element.children.pop();\n      }\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      closeElement(element);\n    },\n\n    chars: function chars (text) {\n      if (!currentParent) {\n        if (true) {\n          if (text === template) {\n            warnOnce(\n              'Component template requires a root element, rather than just text.'\n            );\n          } else if ((text = text.trim())) {\n            warnOnce(\n              (\"text \\\"\" + text + \"\\\" outside root element will be ignored.\")\n            );\n          }\n        }\n        return\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE &&\n        currentParent.tag === 'textarea' &&\n        currentParent.attrsMap.placeholder === text\n      ) {\n        return\n      }\n      var children = currentParent.children;\n      text = inPre || text.trim()\n        ? isTextTag(currentParent) ? text : decodeHTMLCached(text)\n        // only preserve whitespace if its not right after a starting tag\n        : preserveWhitespace && children.length ? ' ' : '';\n      if (text) {\n        var res;\n        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\n          children.push({\n            type: 2,\n            expression: res.expression,\n            tokens: res.tokens,\n            text: text\n          });\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          children.push({\n            type: 3,\n            text: text\n          });\n        }\n      }\n    },\n    comment: function comment (text) {\n      currentParent.children.push({\n        type: 3,\n        text: text,\n        isComment: true\n      });\n    }\n  });\n  return root\n}\n\nfunction processPre (el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs (el) {\n  var l = el.attrsList.length;\n  if (l) {\n    var attrs = el.attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      attrs[i] = {\n        name: el.attrsList[i].name,\n        value: JSON.stringify(el.attrsList[i].value)\n      };\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processElement (element, options) {\n  processKey(element);\n\n  // determine whether this is a plain element after\n  // removing structural attributes\n  element.plain = !element.key && !element.attrsList.length;\n\n  processRef(element);\n  processSlot(element);\n  processComponent(element);\n  for (var i = 0; i < transforms.length; i++) {\n    element = transforms[i](element, options) || element;\n  }\n  processAttrs(element);\n}\n\nfunction processKey (el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (\"development\" !== 'production' && el.tag === 'template') {\n      warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\");\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef (el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor (el) {\n  var exp;\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    var res = parseFor(exp);\n    if (res) {\n      extend(el, res);\n    } else if (true) {\n      warn$2(\n        (\"Invalid v-for expression: \" + exp)\n      );\n    }\n  }\n}\n\n\n\nfunction parseFor (exp) {\n  var inMatch = exp.match(forAliasRE);\n  if (!inMatch) { return }\n  var res = {};\n  res.for = inMatch[2].trim();\n  var alias = inMatch[1].trim().replace(stripParensRE, '');\n  var iteratorMatch = alias.match(forIteratorRE);\n  if (iteratorMatch) {\n    res.alias = alias.replace(forIteratorRE, '');\n    res.iterator1 = iteratorMatch[1].trim();\n    if (iteratorMatch[2]) {\n      res.iterator2 = iteratorMatch[2].trim();\n    }\n  } else {\n    res.alias = alias;\n  }\n  return res\n}\n\nfunction processIf (el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions (el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (true) {\n    warn$2(\n      \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n      \"used on element <\" + (el.tag) + \"> without corresponding v-if.\"\n    );\n  }\n}\n\nfunction findPrevElement (children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i]\n    } else {\n      if (\"development\" !== 'production' && children[i].text !== ' ') {\n        warn$2(\n          \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n          \"will be ignored.\"\n        );\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition (el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce (el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n  if (once$$1 != null) {\n    el.once = true;\n  }\n}\n\nfunction processSlot (el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (\"development\" !== 'production' && el.key) {\n      warn$2(\n        \"`key` does not work on <slot> because slots are abstract outlets \" +\n        \"and can possibly expand into multiple elements. \" +\n        \"Use the key on a wrapping element instead.\"\n      );\n    }\n  } else {\n    var slotScope;\n    if (el.tag === 'template') {\n      slotScope = getAndRemoveAttr(el, 'scope');\n      /* istanbul ignore if */\n      if (\"development\" !== 'production' && slotScope) {\n        warn$2(\n          \"the \\\"scope\\\" attribute for scoped slots have been deprecated and \" +\n          \"replaced by \\\"slot-scope\\\" since 2.5. The new \\\"slot-scope\\\" attribute \" +\n          \"can also be used on plain elements in addition to <template> to \" +\n          \"denote scoped slots.\",\n          true\n        );\n      }\n      el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n    } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {\n      /* istanbul ignore if */\n      if (\"development\" !== 'production' && el.attrsMap['v-for']) {\n        warn$2(\n          \"Ambiguous combined usage of slot-scope and v-for on <\" + (el.tag) + \"> \" +\n          \"(v-for takes higher priority). Use a wrapper <template> for the \" +\n          \"scoped slot to make it clearer.\",\n          true\n        );\n      }\n      el.slotScope = slotScope;\n    }\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n      // preserve slot as an attribute for native shadow DOM compat\n      // only for non-scoped slots.\n      if (el.tag !== 'template' && !el.slotScope) {\n        addAttr(el, 'slot', slotTarget);\n      }\n    }\n  }\n}\n\nfunction processComponent (el) {\n  var binding;\n  if ((binding = getBindingAttr(el, 'is'))) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs (el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, isProp;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name);\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) { // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isProp = false;\n        if (modifiers) {\n          if (modifiers.prop) {\n            isProp = true;\n            name = camelize(name);\n            if (name === 'innerHtml') { name = 'innerHTML'; }\n          }\n          if (modifiers.camel) {\n            name = camelize(name);\n          }\n          if (modifiers.sync) {\n            addHandler(\n              el,\n              (\"update:\" + (camelize(name))),\n              genAssignmentCode(value, \"$event\")\n            );\n          }\n        }\n        if (isProp || (\n          !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)\n        )) {\n          addProp(el, name, value);\n        } else {\n          addAttr(el, name, value);\n        }\n      } else if (onRE.test(name)) { // v-on\n        name = name.replace(onRE, '');\n        addHandler(el, name, value, modifiers, false, warn$2);\n      } else { // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n        }\n        addDirective(el, name, rawName, value, arg, modifiers);\n        if (\"development\" !== 'production' && name === 'model') {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (true) {\n        var res = parseText(value, delimiters);\n        if (res) {\n          warn$2(\n            name + \"=\\\"\" + value + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.'\n          );\n        }\n      }\n      addAttr(el, name, JSON.stringify(value));\n      // #6887 firefox doesn't update muted state if set via attribute\n      // even immediately after element creation\n      if (!el.component &&\n          name === 'muted' &&\n          platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n        addProp(el, name, 'true');\n      }\n    }\n  }\n}\n\nfunction checkInFor (el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true\n    }\n    parent = parent.parent;\n  }\n  return false\n}\n\nfunction parseModifiers (name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\n    return ret\n  }\n}\n\nfunction makeAttrsMap (attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (\n      \"development\" !== 'production' &&\n      map[attrs[i].name] && !isIE && !isEdge\n    ) {\n      warn$2('duplicate attribute: ' + attrs[i].name);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map\n}\n\n// for script (e.g. type=\"x/template\") or style, do not decode content\nfunction isTextTag (el) {\n  return el.tag === 'script' || el.tag === 'style'\n}\n\nfunction isForbiddenTag (el) {\n  return (\n    el.tag === 'style' ||\n    (el.tag === 'script' && (\n      !el.attrsMap.type ||\n      el.attrsMap.type === 'text/javascript'\n    ))\n  )\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug (attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res\n}\n\nfunction checkForAliasModel (el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"You are binding v-model directly to a v-for iteration alias. \" +\n        \"This will not be able to modify the v-for source array because \" +\n        \"writing to the alias is like modifying a function local variable. \" +\n        \"Consider using an array of objects and use v-model on an object property instead.\"\n      );\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\n/**\n * Expand input[v-model] with dyanmic type bindings into v-if-else chains\n * Turn this:\n *   <input v-model=\"data[type]\" :type=\"type\">\n * into this:\n *   <input v-if=\"type === 'checkbox'\" type=\"checkbox\" v-model=\"data[type]\">\n *   <input v-else-if=\"type === 'radio'\" type=\"radio\" v-model=\"data[type]\">\n *   <input v-else :type=\"type\" v-model=\"data[type]\">\n */\n\nfunction preTransformNode (el, options) {\n  if (el.tag === 'input') {\n    var map = el.attrsMap;\n    if (!map['v-model']) {\n      return\n    }\n\n    var typeBinding;\n    if (map[':type'] || map['v-bind:type']) {\n      typeBinding = getBindingAttr(el, 'type');\n    }\n    if (!map.type && !typeBinding && map['v-bind']) {\n      typeBinding = \"(\" + (map['v-bind']) + \").type\";\n    }\n\n    if (typeBinding) {\n      var ifCondition = getAndRemoveAttr(el, 'v-if', true);\n      var ifConditionExtra = ifCondition ? (\"&&(\" + ifCondition + \")\") : \"\";\n      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);\n      // 1. checkbox\n      var branch0 = cloneASTElement(el);\n      // process for on the main node\n      processFor(branch0);\n      addRawAttr(branch0, 'type', 'checkbox');\n      processElement(branch0, options);\n      branch0.processed = true; // prevent it from double-processed\n      branch0.if = \"(\" + typeBinding + \")==='checkbox'\" + ifConditionExtra;\n      addIfCondition(branch0, {\n        exp: branch0.if,\n        block: branch0\n      });\n      // 2. add radio else-if condition\n      var branch1 = cloneASTElement(el);\n      getAndRemoveAttr(branch1, 'v-for', true);\n      addRawAttr(branch1, 'type', 'radio');\n      processElement(branch1, options);\n      addIfCondition(branch0, {\n        exp: \"(\" + typeBinding + \")==='radio'\" + ifConditionExtra,\n        block: branch1\n      });\n      // 3. other\n      var branch2 = cloneASTElement(el);\n      getAndRemoveAttr(branch2, 'v-for', true);\n      addRawAttr(branch2, ':type', typeBinding);\n      processElement(branch2, options);\n      addIfCondition(branch0, {\n        exp: ifCondition,\n        block: branch2\n      });\n\n      if (hasElse) {\n        branch0.else = true;\n      } else if (elseIfCondition) {\n        branch0.elseif = elseIfCondition;\n      }\n\n      return branch0\n    }\n  }\n}\n\nfunction cloneASTElement (el) {\n  return createASTElement(el.tag, el.attrsList.slice(), el.parent)\n}\n\nvar model$2 = {\n  preTransformNode: preTransformNode\n}\n\nvar modules$1 = [\n  klass$1,\n  style$1,\n  model$2\n]\n\n/*  */\n\nfunction text (el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\n/*  */\n\nfunction html (el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n}\n\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  canBeLeftOpenTag: canBeLeftOpenTag,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize (root, options) {\n  if (!root) { return }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic$1(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1 (keys) {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +\n    (keys ? ',' + keys : '')\n  )\n}\n\nfunction markStatic$1 (node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        var block = node.ifConditions[i$1].block;\n        markStatic$1(block);\n        if (!block.static) {\n          node.static = false;\n        }\n      }\n    }\n  }\n}\n\nfunction markStaticRoots (node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true;\n      return\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        markStaticRoots(node.ifConditions[i$1].block, isInFor);\n      }\n    }\n  }\n}\n\nfunction isStatic (node) {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n\nfunction isDirectChildOfTemplateFor (node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false\n    }\n    if (node.for) {\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\nvar fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\nvar simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/;\n\n// KeyboardEvent.keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\n// KeyboardEvent.key aliases\nvar keyNames = {\n  esc: 'Escape',\n  tab: 'Tab',\n  enter: 'Enter',\n  space: ' ',\n  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.\n  up: ['Up', 'ArrowUp'],\n  left: ['Left', 'ArrowLeft'],\n  right: ['Right', 'ArrowRight'],\n  down: ['Down', 'ArrowDown'],\n  'delete': ['Backspace', 'Delete']\n};\n\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nvar genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers (\n  events,\n  isNative,\n  warn\n) {\n  var res = isNative ? 'nativeOn:{' : 'on:{';\n  for (var name in events) {\n    res += \"\\\"\" + name + \"\\\":\" + (genHandler(name, events[name])) + \",\";\n  }\n  return res.slice(0, -1) + '}'\n}\n\nfunction genHandler (\n  name,\n  handler\n) {\n  if (!handler) {\n    return 'function(){}'\n  }\n\n  if (Array.isArray(handler)) {\n    return (\"[\" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + \"]\")\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n\n  if (!handler.modifiers) {\n    if (isMethodPath || isFunctionExpression) {\n      return handler.value\n    }\n    /* istanbul ignore if */\n    return (\"function($event){\" + (handler.value) + \"}\") // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key];\n        // left/right\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else if (key === 'exact') {\n        var modifiers = (handler.modifiers);\n        genModifierCode += genGuard(\n          ['ctrl', 'shift', 'alt', 'meta']\n            .filter(function (keyModifier) { return !modifiers[keyModifier]; })\n            .map(function (keyModifier) { return (\"$event.\" + keyModifier + \"Key\"); })\n            .join('||')\n        );\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    }\n    // Make sure modifiers like prevent and stop get executed after key filtering\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n    var handlerCode = isMethodPath\n      ? (\"return \" + (handler.value) + \"($event)\")\n      : isFunctionExpression\n        ? (\"return (\" + (handler.value) + \")($event)\")\n        : handler.value;\n    /* istanbul ignore if */\n    return (\"function($event){\" + code + handlerCode + \"}\")\n  }\n}\n\nfunction genKeyFilter (keys) {\n  return (\"if(!('button' in $event)&&\" + (keys.map(genFilterCode).join('&&')) + \")return null;\")\n}\n\nfunction genFilterCode (key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return (\"$event.keyCode!==\" + keyVal)\n  }\n  var keyCode = keyCodes[key];\n  var keyName = keyNames[key];\n  return (\n    \"_k($event.keyCode,\" +\n    (JSON.stringify(key)) + \",\" +\n    (JSON.stringify(keyCode)) + \",\" +\n    \"$event.key,\" +\n    \"\" + (JSON.stringify(keyName)) +\n    \")\"\n  )\n}\n\n/*  */\n\nfunction on (el, dir) {\n  if (\"development\" !== 'production' && dir.modifiers) {\n    warn(\"v-on without argument does not support modifiers.\");\n  }\n  el.wrapListeners = function (code) { return (\"_g(\" + code + \",\" + (dir.value) + \")\"); };\n}\n\n/*  */\n\nfunction bind$1 (el, dir) {\n  el.wrapData = function (code) {\n    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\")\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  on: on,\n  bind: bind$1,\n  cloak: noop\n}\n\n/*  */\n\nvar CodegenState = function CodegenState (options) {\n  this.options = options;\n  this.warn = options.warn || baseWarn;\n  this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  this.directives = extend(extend({}, baseDirectives), options.directives);\n  var isReservedTag = options.isReservedTag || no;\n  this.maybeComponent = function (el) { return !isReservedTag(el.tag); };\n  this.onceId = 0;\n  this.staticRenderFns = [];\n};\n\n\n\nfunction generate (\n  ast,\n  options\n) {\n  var state = new CodegenState(options);\n  var code = ast ? genElement(ast, state) : '_c(\"div\")';\n  return {\n    render: (\"with(this){return \" + code + \"}\"),\n    staticRenderFns: state.staticRenderFns\n  }\n}\n\nfunction genElement (el, state) {\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el, state)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el, state)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el, state)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.tag === 'template' && !el.slotTarget) {\n    return genChildren(el, state) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el, state)\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el, state);\n    } else {\n      var data = el.plain ? undefined : genData$2(el, state);\n\n      var children = el.inlineTemplate ? null : genChildren(el, state, true);\n      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < state.transforms.length; i++) {\n      code = state.transforms[i](el, code);\n    }\n    return code\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic (el, state) {\n  el.staticProcessed = true;\n  state.staticRenderFns.push((\"with(this){return \" + (genElement(el, state)) + \"}\"));\n  return (\"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n}\n\n// v-once\nfunction genOnce (el, state) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n      \"development\" !== 'production' && state.warn(\n        \"v-once can only be used inside v-for that is keyed. \"\n      );\n      return genElement(el, state)\n    }\n    return (\"_o(\" + (genElement(el, state)) + \",\" + (state.onceId++) + \",\" + key + \")\")\n  } else {\n    return genStatic(el, state)\n  }\n}\n\nfunction genIf (\n  el,\n  state,\n  altGen,\n  altEmpty\n) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)\n}\n\nfunction genIfConditions (\n  conditions,\n  state,\n  altGen,\n  altEmpty\n) {\n  if (!conditions.length) {\n    return altEmpty || '_e()'\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions, state, altGen, altEmpty)))\n  } else {\n    return (\"\" + (genTernaryExp(condition.block)))\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp (el) {\n    return altGen\n      ? altGen(el, state)\n      : el.once\n        ? genOnce(el, state)\n        : genElement(el, state)\n  }\n}\n\nfunction genFor (\n  el,\n  state,\n  altGen,\n  altHelper\n) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\n  if (\"development\" !== 'production' &&\n    state.maybeComponent(el) &&\n    el.tag !== 'slot' &&\n    el.tag !== 'template' &&\n    !el.key\n  ) {\n    state.warn(\n      \"<\" + (el.tag) + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" +\n      \"v-for should have explicit keys. \" +\n      \"See https://vuejs.org/guide/list.html#key for more info.\",\n      true /* tip */\n    );\n  }\n\n  el.forProcessed = true; // avoid recursion\n  return (altHelper || '_l') + \"((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + ((altGen || genElement)(el, state)) +\n    '})'\n}\n\nfunction genData$2 (el, state) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el, state);\n  if (dirs) { data += dirs + ','; }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + (el.key) + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + (el.ref) + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < state.dataGenFns.length; i++) {\n    data += state.dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:{\" + (genProps(el.attrs)) + \"},\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:{\" + (genProps(el.props)) + \"},\";\n  }\n  // event handlers\n  if (el.events) {\n    data += (genHandlers(el.events, false, state.warn)) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += (genHandlers(el.nativeEvents, true, state.warn)) + \",\";\n  }\n  // slot target\n  // only for non-scoped slots\n  if (el.slotTarget && !el.slotScope) {\n    data += \"slot:\" + (el.slotTarget) + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += (genScopedSlots(el.scopedSlots, state)) + \",\";\n  }\n  // component v-model\n  if (el.model) {\n    data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el, state);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  // v-on data wrap\n  if (el.wrapListeners) {\n    data = el.wrapListeners(data);\n  }\n  return data\n}\n\nfunction genDirectives (el, state) {\n  var dirs = el.directives;\n  if (!dirs) { return }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = state.directives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, state.warn);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\\\"\" + (dir.arg) + \"\\\"\") : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']'\n  }\n}\n\nfunction genInlineTemplate (el, state) {\n  var ast = el.children[0];\n  if (\"development\" !== 'production' && (\n    el.children.length !== 1 || ast.type !== 1\n  )) {\n    state.warn('Inline-template components must have exactly one child element.');\n  }\n  if (ast.type === 1) {\n    var inlineRenderFns = generate(ast, state.options);\n    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n  }\n}\n\nfunction genScopedSlots (\n  slots,\n  state\n) {\n  return (\"scopedSlots:_u([\" + (Object.keys(slots).map(function (key) {\n      return genScopedSlot(key, slots[key], state)\n    }).join(',')) + \"])\")\n}\n\nfunction genScopedSlot (\n  key,\n  el,\n  state\n) {\n  if (el.for && !el.forProcessed) {\n    return genForScopedSlot(key, el, state)\n  }\n  var fn = \"function(\" + (String(el.slotScope)) + \"){\" +\n    \"return \" + (el.tag === 'template'\n      ? el.if\n        ? ((el.if) + \"?\" + (genChildren(el, state) || 'undefined') + \":undefined\")\n        : genChildren(el, state) || 'undefined'\n      : genElement(el, state)) + \"}\";\n  return (\"{key:\" + key + \",fn:\" + fn + \"}\")\n}\n\nfunction genForScopedSlot (\n  key,\n  el,\n  state\n) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + (genScopedSlot(key, el, state)) +\n    '})'\n}\n\nfunction genChildren (\n  el,\n  state,\n  checkSkip,\n  altGenElement,\n  altGenNode\n) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 &&\n      el$1.for &&\n      el$1.tag !== 'template' &&\n      el$1.tag !== 'slot'\n    ) {\n      return (altGenElement || genElement)(el$1, state)\n    }\n    var normalizationType = checkSkip\n      ? getNormalizationType(children, state.maybeComponent)\n      : 0;\n    var gen = altGenNode || genNode;\n    return (\"[\" + (children.map(function (c) { return gen(c, state); }).join(',')) + \"]\" + (normalizationType ? (\",\" + normalizationType) : ''))\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType (\n  children,\n  maybeComponent\n) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue\n    }\n    if (needsNormalization(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n      res = 2;\n      break\n    }\n    if (maybeComponent(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n      res = 1;\n    }\n  }\n  return res\n}\n\nfunction needsNormalization (el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n}\n\nfunction genNode (node, state) {\n  if (node.type === 1) {\n    return genElement(node, state)\n  } if (node.type === 3 && node.isComment) {\n    return genComment(node)\n  } else {\n    return genText(node)\n  }\n}\n\nfunction genText (text) {\n  return (\"_v(\" + (text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n}\n\nfunction genComment (comment) {\n  return (\"_e(\" + (JSON.stringify(comment.text)) + \")\")\n}\n\nfunction genSlot (el, state) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el, state);\n  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n  var attrs = el.attrs && (\"{\" + (el.attrs.map(function (a) { return ((camelize(a.name)) + \":\" + (a.value)); }).join(',')) + \"}\");\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')'\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent (\n  componentName,\n  el,\n  state\n) {\n  var children = el.inlineTemplate ? null : genChildren(el, state, true);\n  return (\"_c(\" + componentName + \",\" + (genData$2(el, state)) + (children ? (\",\" + children) : '') + \")\")\n}\n\nfunction genProps (props) {\n  var res = '';\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    /* istanbul ignore if */\n    {\n      res += \"\\\"\" + (prop.name) + \"\\\":\" + (transformSpecialNewlines(prop.value)) + \",\";\n    }\n  }\n  return res.slice(0, -1)\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines (text) {\n  return text\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029')\n}\n\n/*  */\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n  'extends,finally,continue,debugger,function,arguments'\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n// these unary operators should not be used as property/method names\nvar unaryOperatorsRE = new RegExp('\\\\b' + (\n  'delete,typeof,void'\n).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors (ast) {\n  var errors = [];\n  if (ast) {\n    checkNode(ast, errors);\n  }\n  return errors\n}\n\nfunction checkNode (node, errors) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          if (name === 'v-for') {\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), errors);\n          } else if (onRE.test(name)) {\n            checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          } else {\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], errors);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, errors);\n  }\n}\n\nfunction checkEvent (exp, text, errors) {\n  var stipped = exp.replace(stripStringRE, '');\n  var keywordMatch = stipped.match(unaryOperatorsRE);\n  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n    errors.push(\n      \"avoid using JavaScript unary operator as property name: \" +\n      \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n    );\n  }\n  checkExpression(exp, text, errors);\n}\n\nfunction checkFor (node, text, errors) {\n  checkExpression(node.for || '', text, errors);\n  checkIdentifier(node.alias, 'v-for alias', text, errors);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n}\n\nfunction checkIdentifier (\n  ident,\n  type,\n  text,\n  errors\n) {\n  if (typeof ident === 'string') {\n    try {\n      new Function((\"var \" + ident + \"=_\"));\n    } catch (e) {\n      errors.push((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())));\n    }\n  }\n}\n\nfunction checkExpression (exp, text, errors) {\n  try {\n    new Function((\"return \" + exp));\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      errors.push(\n        \"avoid using JavaScript keyword as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\"\\n  Raw expression: \" + (text.trim())\n      );\n    } else {\n      errors.push(\n        \"invalid expression: \" + (e.message) + \" in\\n\\n\" +\n        \"    \" + exp + \"\\n\\n\" +\n        \"  Raw expression: \" + (text.trim()) + \"\\n\"\n      );\n    }\n  }\n}\n\n/*  */\n\nfunction createFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err: err, code: code });\n    return noop\n  }\n}\n\nfunction createCompileToFunctionFn (compile) {\n  var cache = Object.create(null);\n\n  return function compileToFunctions (\n    template,\n    options,\n    vm\n  ) {\n    options = extend({}, options);\n    var warn$$1 = options.warn || warn;\n    delete options.warn;\n\n    /* istanbul ignore if */\n    if (true) {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1');\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn$$1(\n            'It seems you are using the standalone build of Vue.js in an ' +\n            'environment with Content Security Policy that prohibits unsafe-eval. ' +\n            'The template compiler cannot work in this environment. Consider ' +\n            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n            'templates into render functions.'\n          );\n        }\n      }\n    }\n\n    // check cache\n    var key = options.delimiters\n      ? String(options.delimiters) + template\n      : template;\n    if (cache[key]) {\n      return cache[key]\n    }\n\n    // compile\n    var compiled = compile(template, options);\n\n    // check compilation errors/tips\n    if (true) {\n      if (compiled.errors && compiled.errors.length) {\n        warn$$1(\n          \"Error compiling template:\\n\\n\" + template + \"\\n\\n\" +\n          compiled.errors.map(function (e) { return (\"- \" + e); }).join('\\n') + '\\n',\n          vm\n        );\n      }\n      if (compiled.tips && compiled.tips.length) {\n        compiled.tips.forEach(function (msg) { return tip(msg, vm); });\n      }\n    }\n\n    // turn code into functions\n    var res = {};\n    var fnGenErrors = [];\n    res.render = createFunction(compiled.render, fnGenErrors);\n    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n      return createFunction(code, fnGenErrors)\n    });\n\n    // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n    /* istanbul ignore if */\n    if (true) {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn$$1(\n          \"Failed to generate render function:\\n\\n\" +\n          fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n\n            return ((err.toString()) + \" in\\n\\n\" + code + \"\\n\");\n        }).join('\\n'),\n          vm\n        );\n      }\n    }\n\n    return (cache[key] = res)\n  }\n}\n\n/*  */\n\nfunction createCompilerCreator (baseCompile) {\n  return function createCompiler (baseOptions) {\n    function compile (\n      template,\n      options\n    ) {\n      var finalOptions = Object.create(baseOptions);\n      var errors = [];\n      var tips = [];\n      finalOptions.warn = function (msg, tip) {\n        (tip ? tips : errors).push(msg);\n      };\n\n      if (options) {\n        // merge custom modules\n        if (options.modules) {\n          finalOptions.modules =\n            (baseOptions.modules || []).concat(options.modules);\n        }\n        // merge custom directives\n        if (options.directives) {\n          finalOptions.directives = extend(\n            Object.create(baseOptions.directives || null),\n            options.directives\n          );\n        }\n        // copy other options\n        for (var key in options) {\n          if (key !== 'modules' && key !== 'directives') {\n            finalOptions[key] = options[key];\n          }\n        }\n      }\n\n      var compiled = baseCompile(template, finalOptions);\n      if (true) {\n        errors.push.apply(errors, detectErrors(compiled.ast));\n      }\n      compiled.errors = errors;\n      compiled.tips = tips;\n      return compiled\n    }\n\n    return {\n      compile: compile,\n      compileToFunctions: createCompileToFunctionFn(compile)\n    }\n  }\n}\n\n/*  */\n\n// `createCompilerCreator` allows creating compilers that use alternative\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\n// Here we just export a default compiler using the default parts.\nvar createCompiler = createCompilerCreator(function baseCompile (\n  template,\n  options\n) {\n  var ast = parse(template.trim(), options);\n  if (options.optimize !== false) {\n    optimize(ast, options);\n  }\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n});\n\n/*  */\n\nvar ref$1 = createCompiler(baseOptions);\nvar compileToFunctions = ref$1.compileToFunctions;\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nvar div;\nfunction getShouldDecode (href) {\n  div = div || document.createElement('div');\n  div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\n  return div.innerHTML.indexOf('&#10;') > 0\n}\n\n// #3663: IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;\n// #6828: chrome encodes content in a[href]\nvar shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML\n});\n\nvar mount = Vue.prototype.$mount;\nVue.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    \"development\" !== 'production' && warn(\n      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n    );\n    return this\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (\"development\" !== 'production' && !template) {\n            warn(\n              (\"Template element not found or is empty: \" + (options.template)),\n              this\n            );\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (true) {\n          warn('invalid template option:' + template, this);\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (\"development\" !== 'production' && config.performance && mark) {\n        mark('compile');\n      }\n\n      var ref = compileToFunctions(template, {\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\n        delimiters: options.delimiters,\n        comments: options.comments\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n\n      /* istanbul ignore if */\n      if (\"development\" !== 'production' && config.performance && mark) {\n        mark('compile end');\n        measure((\"vue \" + (this._name) + \" compile\"), 'compile', 'compile end');\n      }\n    }\n  }\n  return mount.call(this, el, hydrating)\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\nVue.compile = compileToFunctions;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Vue);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! (webpack)/buildin/global.js */ \"C:\\\\Users\\\\VULCNAVSeries\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\webpack\\\\buildin\\\\global.js\"), __webpack_require__(/*! (webpack)/node_modules/timers-browserify/main.js */ \"C:\\\\Users\\\\VULCNAVSeries\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\webpack\\\\node_modules\\\\timers-browserify\\\\main.js\").setImmediate))\n\n//# sourceURL=webpack:///./node_modules/vue/dist/vue.esm.js?");

/***/ }),

/***/ "./src/app.vue":
/*!*********************!*\
  !*** ./src/app.vue ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _app_vue_vue_type_template_id_5ef48958_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./app.vue?vue&type=template&id=5ef48958&scoped=true& */ \"./src/app.vue?vue&type=template&id=5ef48958&scoped=true&\");\n/* harmony import */ var _app_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./app.vue?vue&type=script&lang=js& */ \"./src/app.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport *//* harmony import */ var _app_vue_vue_type_style_index_0_id_5ef48958_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./app.vue?vue&type=style&index=0&id=5ef48958&scoped=true&lang=css& */ \"./src/app.vue?vue&type=style&index=0&id=5ef48958&scoped=true&lang=css&\");\n/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ \"./node_modules/vue-loader/lib/runtime/componentNormalizer.js\");\n\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(\n  _app_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _app_vue_vue_type_template_id_5ef48958_scoped_true___WEBPACK_IMPORTED_MODULE_0__[\"render\"],\n  _app_vue_vue_type_template_id_5ef48958_scoped_true___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"],\n  false,\n  null,\n  \"5ef48958\",\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = \"src/app.vue\"\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);\n\n//# sourceURL=webpack:///./src/app.vue?");

/***/ }),

/***/ "./src/app.vue?vue&type=script&lang=js&":
/*!**********************************************!*\
  !*** ./src/app.vue?vue&type=script&lang=js& ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_vue_loader_lib_index_js_vue_loader_options_app_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../node_modules/vue-loader/lib??vue-loader-options!./app.vue?vue&type=script&lang=js& */ \"./node_modules/vue-loader/lib/index.js?!./src/app.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_vue_loader_lib_index_js_vue_loader_options_app_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"]); \n\n//# sourceURL=webpack:///./src/app.vue?");

/***/ }),

/***/ "./src/app.vue?vue&type=style&index=0&id=5ef48958&scoped=true&lang=css&":
/*!******************************************************************************!*\
  !*** ./src/app.vue?vue&type=style&index=0&id=5ef48958&scoped=true&lang=css& ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_style_loader_index_js_node_modules_css_loader_index_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_vue_loader_lib_index_js_vue_loader_options_app_vue_vue_type_style_index_0_id_5ef48958_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../node_modules/style-loader!../node_modules/css-loader!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/vue-loader/lib??vue-loader-options!./app.vue?vue&type=style&index=0&id=5ef48958&scoped=true&lang=css& */ \"./node_modules/style-loader/index.js!./node_modules/css-loader/index.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js?!./src/app.vue?vue&type=style&index=0&id=5ef48958&scoped=true&lang=css&\");\n/* harmony import */ var _node_modules_style_loader_index_js_node_modules_css_loader_index_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_vue_loader_lib_index_js_vue_loader_options_app_vue_vue_type_style_index_0_id_5ef48958_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_index_js_node_modules_css_loader_index_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_vue_loader_lib_index_js_vue_loader_options_app_vue_vue_type_style_index_0_id_5ef48958_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_style_loader_index_js_node_modules_css_loader_index_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_vue_loader_lib_index_js_vue_loader_options_app_vue_vue_type_style_index_0_id_5ef48958_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _node_modules_style_loader_index_js_node_modules_css_loader_index_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_vue_loader_lib_index_js_vue_loader_options_app_vue_vue_type_style_index_0_id_5ef48958_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_style_loader_index_js_node_modules_css_loader_index_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_vue_loader_lib_index_js_vue_loader_options_app_vue_vue_type_style_index_0_id_5ef48958_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default.a); \n\n//# sourceURL=webpack:///./src/app.vue?");

/***/ }),

/***/ "./src/app.vue?vue&type=template&id=5ef48958&scoped=true&":
/*!****************************************************************!*\
  !*** ./src/app.vue?vue&type=template&id=5ef48958&scoped=true& ***!
  \****************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_app_vue_vue_type_template_id_5ef48958_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../node_modules/vue-loader/lib??vue-loader-options!./app.vue?vue&type=template&id=5ef48958&scoped=true& */ \"./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/app.vue?vue&type=template&id=5ef48958&scoped=true&\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_app_vue_vue_type_template_id_5ef48958_scoped_true___WEBPACK_IMPORTED_MODULE_0__[\"render\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_app_vue_vue_type_template_id_5ef48958_scoped_true___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"]; });\n\n\n\n//# sourceURL=webpack:///./src/app.vue?");

/***/ }),

/***/ "./src/ass/4efbc0992ccdbfb4.jpg":
/*!**************************************!*\
  !*** ./src/ass/4efbc0992ccdbfb4.jpg ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAOpBdwDASIAAhEBAxEB/8QAHAAAAQUBAQEAAAAAAAAAAAAABQECAwQGAAcI/8QAWhAAAgEDAgMFBAcFBQQHBQERAQIDAAQRBSESMUEGEyJRYTJxgZEHFCNCUqGxFTNiwdEkQ1NykjRzguEWJTVUY5OiRIOz8PEIFyY2RcInVaOy0mR0dYQ3lOL/xAAaAQADAQEBAQAAAAAAAAAAAAAAAQIDBAUG/8QAMREAAgICAgEEAgIABQUBAQEAAAECEQMhEjFBBBMiUTJhBXEUI0KBkTNSobHR4fBi/9oADAMBAAIRAxEAPwD3f6Ksf/cs7H5//Q1n/wDAStLGoYknlWK+i6ed/ox7IJAh20izBLdfsUrZxzozcDDgfG4rSmkb00iYKBsBSOMjkD61wx+LNPANKyehkQKt6VMwXIOKbwHGajkmXGSw2o7F+T0dMzcJIGfSoIZmJI5nyxypWuFZSAcE7ZNdGrQoTjjz5U0qNEqVMWW7KqylTxVTjfhbi61JOztzUqD0NQY6VaVGkIpIp63YyXMa31m3Df254ozy4h1U+hq5pd/Dqdgk8XXZ0PNW6g052IQJQC4B0TUvr8YJsZyBcoPuHo4/nWiXJUKUa2ZTtvobaTfC9swVt5WyOH+7aj/ZjU49StW+sOAWwrgfcfo/x/WtXfWdvqti9vIA8My7EfkRXk89tcdmdcaC6VjCThsHAkTzrphJZocH2jnl8HaPV9NuTcQkP+9jPC3r6/Gsh2206ewmOq6azRh/DOq8j6kUdgvFkgiubRlklCAOByZOjHHL/wCtGJYUuLYxzBXSRcNjkQa54y9uVmn5Kgb2bvzf6bE0hXvgo4uE5B9azXamzn0bWE1m2KrCWAZR59c++qVm83ZvtObRpWFsSe7U+ywPKvQJ4bfVLBo5VEkMoxgjl/zFaP8Aypcl0xJ8lXkZp91FfWcVxAcpIM+70qzWL0KWTs9rL6XeHFtKfsnPIHofjW1wfKsskeL10axlaGmnjlSFcb5pVqBs4CnUm9dnBoEcaWkzS0hCGkpTvXYpjEPpTdsU/FNPPagEQsN6dEgY71zdaWFTx56U/A2SqiqdhTq6uqCRQKWmFgKheYE4FFNhVlgEUvOqqOc1N3oHvpuIOI/h3zS0gYHbNLUiOrq6uoA7FdS0lAHV1dXUAdSUtdQAldS11ACV1LXUDEpKWupgdzpD60tIRQBXVWhZiN08qRbgtINsLVgjI3qlInDIQBtVrfZS2Xa6qiMVPWrSNkZpNUJqh1dXV1SI6lrq6gDqbLIkUbPKwVFGSScAVDeXcVpGHmbmcKo3Zj5Adapx2s19Is2orwxg5jts5A9W8z6cqEvLFY0GbVjsXh0/5PN/Rf1opDGkMaxxKqIowFUbCmySpEACd+ijmarfbXZwCY4epHM/Gn3/AEImluSXMduO8k6n7q+80kNoFbvJm72XzPIe4VNDEkKBI1CqKkqb+gOrq6upAJXV1LQgErqWkpjErqWkxTA6kNcaac00AjHeoiN6ed67FUibIWFRkVOy0wiqTGQmmmpGFMIq0xojNJw1Jw0hFOwG4pKkAzXcOKLAaBTgK5RUgAFJsBhG1RnnUzGozzoTGIBS4pRS0WBR1HDG3hIz3koz7hvVuqr5k1WJcbRxlz7zsKu4qm9CG12KcBTgKmxjcbU2RhHBcP8AhiY/lUhFVNVbu9Ivn/8ACIpPYqPMWySSetRkelSMafaRpLcKsmQmCW9wFd/RswYv2t85HKJeH4mpm2JolpFlCbMSyQMzSsXz3mNjy/KrbWtsBn6r85TRKaslRdADNNOx5Ue+rWxAP1Rf/MNd9Xthys4/ixo5j4gD31x91HjFBkAWcG/mTXcEI/8AZLf5UcxcS59G5/67m9YTV7tUeG5i/wB+n60Kt7qSzfvLSOOFiMcSDBxTJdQuZzmUo5DZBYA/yrFwcp8iXDdlzUygv7jicjxnrVGC1MmnPqcueF5TDD6IOZ+JqpqupXK27eJTJL4BsMkmprSaZbJbVn4oolHCueVa01ETVscxTPtn51E/Dn2mPxqZi/kPnTW4/JfnTRRXPDxnDH5mmEr5t8zUpLiQ7Ly86Y3GPL51RLImKYwGb5mmApgbt8zUr8ZB2WmDiKj2aoljCVPVvmaYxTjXdsfGpDxjy/Oo2Lca+z+dMlkN7IsVrI/izjA586jgC21ivECCq8R586j1IvJJBb7eNsnGeQpdVZu5SEEZlYLgeVWukjNmm7DxjuFZgeJjxGt6uwFYTs3N3BCEjA2rTT6rHGQvEM4zXl+pg5T0ehgkowC1RyTIg3NZ6515VQ8JFBb7WJZD4WGDWcPTSfZUs8Uau81WOJTg1ltS1gyuyjix7qES3Uzk8TioMuZDlhy8q7cXp4wOSedyJHcSEkhvlTG4cEcJ5eVJlgfaHypTxEHxD5V0mBXlYO8EXCcZ4j7hVwcP4D8qo2+Xu3biBEahRt161eGT94D4U2CFOOMYQ/KlAX8B+VMOeJfEPlT8/wAX5VJQhC7YjNKgXf7M86QH+MfIUisfEeMc/SgYxSpu3bg8MaY+dLaANG0jJvI3FyHLpVIM0kfAreOdzk+SjrRPAVAFcADYDaqehLZ6T2dw3YwYGMMwxWKuRi6kzWz7JHi7IyjizwyNWOvyPrbg+dceD85L9lIoABS3CMZNcVLIxOa5vaNSwOkcitKhdBzUda7Gyira2FzdOxt4mkxz4elW4rSe0Z1ngZGJBHEMVsey8lnNIz6dbtbL95nbZq0WpQ20ts5uVQqBzNcmT1LUuLQ0jIaHfakEWKKFpYc458q0N3okUyCSOMLck54i3Kg/Za8S2vZIWmHduTw++tkTgZAz7q5c0nGWiiO3hMcCxu5dgMFj1qKSK5WLht5BxebVOZBjkc1aSSGJAXcAnzrncmiZOgZcyFbQLf2vfr1KVNpwhMK/V0EcOM7nJq68qumFXINRIoHIBfdReiUJIiPsRkVGw7hfshwg+VTSBkQkYJ6CqKtcsSJkAA5EULZcdkyy20SGSZcsN8kZqeDU4Zk4kVuEelUHUOpVhkGuRQihVGAKbimU8SbsuJqMTSkd04P4iKmmuo2QgZz0ofU8NokpV3fGOmalxS2S8cY7YgWWXfcgVCwcPjAx1owpQDCkYFQTRJJkjGfMUKQo5d1QN4eH2BU9tEZgSDgqeXnV2G2QJ4hkmnLbopyuR8aHMJZV0hihI8yOMMBTPrsbZDKcY+dQ327BS3EBTba27w5OyiilVsShGuUgW+vNBdOEt/B5Y3oxYTjU7cSunCoPs1101naIXeNWblsMk1DZxziXvYlWG3bfuzzpumtKiGl4CU0scCZcgDpSiQFA3n0qtKsMlxG0xHGvsjNJqV5HbQMQw7wjwgb1HHwRxLDSE+lMcRlMO/Dn1qPTizWaPMMO25zU5hjfBIzR0Oym062pCMxYjlVX9uxrccEqlV88UTmigk8LhSfzoRqWhpcElRyG1XHi/wAiri1sNQyxXEfFGyupqRVC+yAPdWb7PWdxbTNhsIDgqetaJmwRUTjTpENbGXCyBC0LAP0B5UsDlogZAA/XFSYDU3gHSlYf2I5BO1Mrm2OKaSBzplpHGmk0ySQrjhGc07ORToujqQ0pqOVmVcovFjpTQ1sdnAzUSyoWwZE4ieWaiS6Z2CtHwjrk0J1TSYzdC8gJMo5AHYVcYpvZXF3QfLADfakWZG9lgfcax+r6tqdrCEZI5Qw9pByqpoOtRJO0uoycAXZU/nWiwNxsONdm8L+lKG23IofDqdtcQ95bt3g8hzqlM5eRm43Hpms1BvsqONy6Kn0Tyov0Y9jomGHOj2hG3P7FK1IhQSliDxVjPoyvo4vox7HqcFho9mMf+4StYLovjG1RxdGag6L6KrDpTuFgMZ2qh3p4shsZ5irqgxxFixbbO9S0Zyi0RsZmLDZVofIRnB5edFIn7yIOQBmhl2xZ9lwo5VUTTE90SW8KsOLOfSpUjk4854V8hVKN2jYEVZa6UOCAMHn503ZUkxZ43z4cvnz6Upte7i43f4U+K6TB2yabcTxzoq5IOeVK2TcuhtqiJG0suCOlQSvFP3iTLxROCpXHMVNNChjxB4sc96r902FPQ+dNfZcUnbYH0Wd9J1D9k3BY20mWtJG8uqH3Vc7W6Gmu6eVwFuY94n9fI+hp+p6bHqdo0JZ0kXxxuPuMORFN7P6lLdLLaXo4NQtvDKv4h0YehrS3fOPaMpRV0YrsXqT6XfyabfDu24iMNt7wf5Vu7WeOO4Fsj8asOOMruAPImgHbvs8t/bNe2q/2uIeIAe2v9aqfR5LC+jTxGbhnjk4gGb2fLFbZOOSPuImNxfEI9udJW+tY7hfDJFsW8h5/OouyWqsYSlyeF0bup1P3X6N7jWlidLy2YOp4WyrKwrF6nbPpd49yqmTuRwXCf4sJ5N7x/Spg+UeDHJU7Rpe0+kLqtiQvhuI/FG3r5VD2Q1U6hYGK4I+t254JAeZxyNWNEvlmjSAyceUDwyf4if1HI0F12yk0PUotX0uD7EZ+tIp5g9cVMdrg/wDYd+UbGmkb7Uy0uI7q2jnhYNHIvEpFSZrLploQVxGaWuAoA7FdyFOxTTQB1ca6loAQUh50tIaAGkb0nEVO1K249ajamUTowYetRyMVqPJXlSFiedNRChpY9KYRvTq41YzlbApjHJ50hpDQBNA57wA1eoapw2RVlZs9aiUbE1ZZrqarZFOrMg6lpnEM08UBR1JS11AhK6uNdQM6urq6gDq6uNdQB1dXV1ACHPSkGcb06uoASopYQ2SvOpaQg5yKaY7KojI2Ip6krUxUsd6Rk8qq7KsbxHyqQHaowMUtKgaJAapX18IHEMCGa6f2Y1PL1J6Cq8t5LdStBp2Dw7STndU9B5mpbKGO2VktVMsrHMkrn2j5k9fcKfGuyGda2fcubq+kWS5I9s+yg8lHSp3mZlJX7OP8bDc+4VzqqMDKTLMfZXoPcP51JHCWYSTEM3QdFpN+WIhig4/EwIQ9D7Te/wDpVwDAwBgV1LUt2B1dXV1AHV1dXUgOrsV1L0oASurq6mgOpKWkoGIaSnUlADCKUClaoiT51S2FDpThdudVjmpDvSYq1odDcHGKYy4qYUhWmmFEYUGkZM08bU7h2osVEISuKVNikYYGadiIVGDTsUo3Oa40yiNxtTVG9Panqu3KiwY3hpQuafikYhFJPIDNKxFCyBe9vJTy4hGvwH/OruKq6RlrFZDzlZn+Zq6BTb2IbikNPxSYpDsbihnaVuDQLvfnwr+dFTWf7auV0ZVB9uUD5CmttDW2YJ9qYiyTTxW1v+8nbu9vI8/yqxaxd9dRRtuHYCtBoNlE/bOdY4lWOyhbGPxHb9K7HPjZpN0imwWNjGr4VfCBnpTG4SD9ofnVifi75xwjn51E3EAcKPnUJmiIAV4R9ofnSEp1kb51IC3AMBfnTSX/AAr86YERKcS4kPzpG4M+23zpzl+Jdl5+dcePyX50xER4MY42+dMHAQ3ibn5mpT3nkvzqB5vq6tJKAUU7gcz6U0Q9bHaXot3ruoubUAwWowWdsDjPT5UUvdAu9Lt3lujH3beEFHJOa0OkqdC0KNZABPLmaX/Md8fAYFCNW1xdRtGgUNkHi3GKy92cpa6MYtsCtwZ2LfnTPBjm351K3GOXDTGD4+7W6ZqQEp3hOSdvWkYJ14vzp2H7w+zypD3nmMe6qJIn4N/a/OogUwNm/Op3DHO4+VRIG4RuPlTTJY08Hk351C/AWXwnn5GrBD4zkfKq9w5jQuxGFyeVNEspQ8M2pzOQSkY4RsedI3DNqqgKeGFcnbrUmlqy2hkYgGQlztTNLDOs05IzI+23QVpZnRft5gjNwq3PypqXjTTTMQxUHhG3lTCxUOSwGN+VRWSsLZWJA4iWO3nU0ux2+iWRsqfCflVySw4LAXDxkcR2GKm0XTZdRu1QHwZ32o921jjtLW3toyAQPKsZZKkoIpR02zGYXP7s/KuHDx7xnl5U7xfjHypgz3ntDl5VuZj8L/hn5UhKqCTGdh5U8ZxksPdioL88Nq2H8TeEfGhAN01QLfjZCS5LcqugDn3f5CooBwQqgbkMdKlzsPH+lDexoa2OJfB+lP2A/d/pTGO6+Mc/SlJ5faD8qQx2xwRH+lQ3DcEEzcHLPlU4/wB5+lVbvDNHEHyHcZ5chQuwYzSAXVpSufuKPICiJPg9jf4UItpvq9+bSJg8ZYsWH3aLnHCftP0py7HDo9B7Ft/9695nAxIf0rIakwN23iCrn2jWp7Ep3mh3o4uIBwd+m1ZnWIQLp+pzzNcmH/qSKRRY2wO0kkreSjAqtcTMsgMUJUct2qwsZ4vZI+FPeLAGQfXauu0h0HtK7K3F1axz2+o8BcZKqeVajSNJl09X+v3f1iNvuvyFCtA0JJII7mzv54s812p+o6PqxuyVuHuItuHJx8xXn5Jc205FJBO/vrWyZFtLeORyd8DlUt1Hf3EUMls/dnmy52xS6Qkxi7u8hVJB1C8xRBkeNfs/EPKudtLRSEt5WVVWbBbqRU+xbdar3Vs0sHDGQjn73lU9vGYoVRnLkDmahideCXkNq6mhdsZqHglE44ZBwdRUkkpUM3EWNcSAMPypzcQ9kZpcBhuBQFleRoyCFX41CcAZJwBTruYxEBYiV6tiqRMr3CswKweRq0jWL0WwcjbrS5I67UNvtSS2YJH4j1wOVW7Ng8IkBJ4t96bi0rKJXXvFwSR8aQSm3mhXOFJwc1V1RjHD3mWGPKhi6iFUC5BlHNcDlTUG0JqzYzSi3TjZgB0qs147rtgA9RWbvri3uIUMk7hfwCorHUXjmEMYZ0JwoIoWHVmccaXYeeRVPjbBPnUS3zm57mNXOOfDV1NO+sRKbrGeYA6VyaMkV19YilkWTlz2qOUfISyx6KdxOls6zTqWQHyqO47QQyMsVqcM23EeQo60SyxGO4VGzz9aAT6HbySNFbIFI6+VOLi/yJUlN2x0eid/L38928hJz4TREWMajAJPqaistO+prhZmY9c1X1uS9tITPbSBkHtKRRbk6TEnvTCuTGgU5IHKgU0moPcO7RukI2XhNENGkkns1lmfiLb8uVXXyVIHOknxdDWmQ6TbMid7K5d28zyoj1qjbd5EhViMeQqVHKtnmDWctuzOcW2WFULnA50pAPMUgdSOdcHB2BqdmdMXAFcCCNq4gNzqJxwHY4oGlZIQB5VFKiHeqE93JJP3UGCfOoJ5bm1P2mCD1FaKDNo4n9hJhtsN6o3dw8SnKFD0Oajg1INtMMeoqvPqEMpxLBxAcquMHezWONp7RHHqsqv9p4kq+b+JoiYnXjxsDQi5e1wGgVuL8J5VE14CR9ggI5GtfbT6Rv7Slui5PM85BkCgjyqpPqn1aFlU5P4R1qu9w7Zy3CD5VUbHFnmfOtI4/s2WNVReacyxK5iznfHlVeyt4/rOZ9HZgdxIeVTWjtKRGi7gcxTu9mtZG7wuM8jTqtIiePk6CsqwLEBDwQ7eyBQ9o8sT3hqjPdNIdiQKYkhAxk0RxtGkcfFFf6OZIpPoz7IxouZf2RaDOMf3KVp41mtkZm4WHUZrG/R1IW+jvsnyGNItBt/uUrXQJb8IaaXiby8qwqkjkS0ixBM8nNcZqd7iX2Wc8I6VXe4gjUGJgfQU24ZJbcsDuKmgqy0sjgBQx4c8s1aa4HehguQBjBrPW7M0qAsQM0aBYKVB2POlKNClBCSnvGLGqwByQpIbrnep3jbuuNsAdBmoTzz5UIca8EvGqKOM8PrSsm2Rg5qBo1kPjyR76m9lOEDYcsUMdDkV13XIzzxSEN13rlZuWcVNGQxwwJ9RSJetixZIHCcH1oT2gsLhWi1PT/8Abrfp0lTqpo34F5Yp48Q50lKnZjLZR0y/h1SxjuYPZbZlPNT1Brz7tVY3PZzWP2hpsjQ29zkEqM8BPMfzFanUVbs/qZ1GBSdPnIF1GPuHo4/nRbU7S31jS5IWw0My5Vhv7iK2hL23fhkNWqItLuY5rO3nhlMyOg42PMnzPrTtWte9jWeNA8sWfCfvqea/GsF2W1OTQNVn0y/z3XEV5fmK9CsZzKuCMId4yebL50ZIOErQ4vkqMZbg6XfR2scmLSdu9sZm/u36ofQ8q2lnOl/aHjTBOUljP3T1FCde0uKeCWGTw20xyGH9zJ0Yeh60N0LUZ7eaSO8yLq2xHcp+NOkg88dfSnL5q12JadFnRpG0PWZNInY/VZiZLVj081rVAZoL2m04appfFCR38X2sLjz5/nT+y+rDVtOVn8NzF4JV6hh1qJLkuX/JS1oMYrhS0h51kULTSKWuoEIOVcaWuxTsY2kpxpDvTAYRTelPI3pDyplIjam4p5503fNUMTFMYGpTTGoTAjxSEU+mkZqgGCnDY0mKcFJ5UATQvg71MXzyqBFxUtQ0FCing0wUo51LEyUUtMzTlNSQ0LXV1dQI6krsV3WgZ3Wupa6gQldXYrjQM6urq6gDqSlpDQAtdSVU1C/hskHHl5H2SJBlnPoKaVgTTukMbSSsERRkknYUIkkl1JuEccVoeSrtJL/+6tPisrm+lWfUSEA3SAbhff5miyRpEp4QFHU1VqIWytDa8MaoVWOJRgRJsB7/ADqTvN+7gALDn5LXEtcbJlYurdT7qmjRUUKgAApNgJDEI8nJZzzY8zUtJSipYjq6upQKQCV1OxXYoAbXYp1dSAbilpa7FADa6n4pCKLFY2up2K7FOx2MxXGn4pOGiwsiao2FTMNqjIqkUmMxXYp4FLiqsdkYG1Lin4rsUWIjIpyrTsUmKLA4gComAOwqUjNcAAKLArFSBTatONqrld6tOwGgZqUDamoKlUUmxMaRVPV3MenTFfaK8I952q/ih2qDvLiygz7UvGR6LvRHsRYgi7qGOMckUL8hUuKdiuxQ2A3FIRUmKQjalYEJ2rL9upP7JZx55szVqWWsd26b7WzTyQn860h+SLj2ANG4RqlsXwFVwxPoN603YIC4vNTvd83BZ9/Inb8qyEStJcRQRZ7ydhEuPWvRtFgWyg1JUACReBfcBWuZ0v7HPsxl3eW4uZQHfZiNs+dV2vrffxyfnQyRuJiepOaiY71qkjUJ/XYOEZaT86ab2385TQtmqEk551SigsLPewEjHebGo3v7f/xc0MyaYfWnSJsKftCDqJaZYXMN32g0+3CsY++V3B677ChLuoBOdgKn7LknWbOQ+08yn4Z2ptJRbM5u9Hq/bEhLSRjyCk7V5zY3Uc8siojDwE5Nej9tBmwm/wAhrzLQEyJ3x93Arn9P+DFAJkL+FvzpjBccmx7jU7K+BuvyqJg3mvyrZM0ZAQvHybl613g/C3yNPbi7zmOXlSeLnkfKqskiYIRsrfI1EoUIPC3yqzg42YfKowrFRuB8Kdkldgp+4flVDWCDAsaqQ0jBRtRRlOfaHyoXNmXVo1B8MK5O3U1ceyJdC35WCwYKhDY4RkU+3jEVukYQ5C+VQ3wM17bQcWQDxnbyq9g59sfKm3omtg6+4FtZOBDxsQM486LaXYPeSxwRQnOACcVUW1e8v7aCPxMz5OB5V612d0ePTrZSwBmYbnFY58yxx/Y4wtnaJpcOlWg8KhgMscV5/wBq7769qkh4MqpwK2XbLVlsrJoY2AlcV5szFjxGTJPurD00W28ki8j8IZwj/D/IUgC8e8fTyFO8x3n6U3HiHj/Su2zKiTY/3ePgKrXA47u3i4AAuXPLpVlcDfvP0qtb+O9uHD+zhAdvjTTEyyo29j9KcNv7v9Kam67yH8qdkHnJj5VNjEfcjwcj6U7f8A/KmuVOAJOvmKXI6OfmKLGNuJRDC0jp4VGdsVnpL2aW6DoxXoAByBo5dBZ1ELSnhbdtxyoTpawftRxuFUnuzmtINJNkStug3YWqWseFQlm3ZmO5q0zHgOF/Oo+Jf8Q/OlypXAcj41m3ZqlR6F9Hp4tI1AEAEMv6Gs5rY/tb4Gd6P/Rqwa01FQc+yfyNBde/2xwMc65cessgQ/QtRmg+zNmtyudsryrY2dut3lrvT4ouorHadr8un2hgihjz+MjeqL6zfLP3wuH4s5xnanPFKbdaLPSP7NYSKkSKGfkqnc/CroY7YwM+deYaTqt/NqzXndm4fGMfhrX2+mz38sV7LdyBsbxjYCubJh4dsYfmlWKNnc4AFBtM1g3F26z5QZwmBsaMd1lgXbiUDHCRtToESSUpGigD2vDWKaS2Juh7EgbDNRpMGfgwQ/kRVqWFUUlQc++oVGBjn76lMlOzvQ9aUALyriQBk8q5MPjhOaBi9K7O23Olxg0mBnPWgRXi+scZ75EK52wamkiSQeMZPT0p9OCEnGKGwbBMmmWyOzcBZ233pUHCBGVKsOQPWjaRhee5oZelJLvmOJdqak3oqGS3RnNVknWchivCduGhJD+a/KtlNplneow4+Kb38qCWeimXUGglBVE3LY5iumGSKRosiA/CxZQzKBkdKtTKkLo8EnEw3O1aZOzVizggMVHrS3/Zy2eL+zqEYedL34t0Q8sbooaXrJ+sqLhiE5YHWtF9fQjKqSKC6d2ejV+KUAkcqJXNsYQOHcVjPg3oVQkxlxOZnyNvcaljkmjixHGPeajtoi0mWGAKun0qHXQ50viiq17wnEq4aql9dLOnA2yeXnV64hE2OQNVJrRlOwDCqjRcOBXjv+CJYbZMNyFX7SCRPHNIWc/IUJl44ZAY0wwpRczSyAXLMI+vDVuNrRcsd/iHA6k4U5PWlJ4QcDNUhf2kSAK23oKadTiaaOO3BlZuePuj1rPgzBxa8HT6tb28ojuCUY8s9auRzB1DDYHlTJ7aC4ZTNErkcsjlQ1VkmvpIYn4Y0500kwjGw2kpI2O1I44wQx50Kmt7q3UtDKWQdKdpN133GJXzJ5Gjhq0P29ckO4RZXXG37puvlUs13azIUMg386r63MFhVBuTQpZ3jjw0alTyLLWkYclZrHHzSkwqohS1Kq6d6NwedBZ3ZnPFzqPiydyFFcyhn4YzxmtYxo6IQ4lmzmgiYmXiJIxyziq986PJlHLL0yMUyeCWEjvVIzyrrSKKZ8TSrGo86pJL5FpJfIrk1NDazSKJFQsmd8VJeJHBMPq5Dx/iznNFNNvEij4XHh8xRKbStBKb43EnsLaKLMsY3xuKF67NJK6B4uBRy9aJN3lxfrJAeGLG/rVm6sUuSpc7gbVipcZWzmUlGXKRnRpc0kQki8W2cVQdWRipG451p+8ksZO5GGBG1D5dImkkL5zxb5zWscv2dEMn/d0Bvo3S0H0adkg2eM6RaEkefcrRVgOIhdx0qr9E5jT6NeyymJSx0izYMfIwJRLUIhHN4QQrb1jB+DlxStDO4k4CxUhfWmw4Zgp4sHoKdDO6nDksh2INSwyRC7BVeBOmaptmhZSziiPeMzYG+CKQagBIQVBTOxFS3MoSI8WGB9edDXETDKFgfI1K32SlfYajIlTiQ5Wo5AAaFw3Lw+FDleoPKiEEqTqOEYfyqXGhU0O3WpUAfO+KTuzkBjV6yhQA8QBPSpboic6VlBkIOxz7qlt8gE/lVt4sOSExSrBE8RZjypciHkVEPdy442xg9KkANKkbkA95xIOlTKADyqbIcirLGk0bRyKHRhgqeRFZzTnfs/frp10xOnzt/ZZW+4fwH+VayRQDlap6pYQ6nYyW1yMo42I5qehHrVRn4fRLd7RjfpH0NpYF1W2GJotpAOZXofhSdkNeW4shFO4WSL2Seh8vcf1o5od07PNo2r4N1EuFY8p4+je/zrzzXLB+zPaIjhLWrniT1Xy94rqx/Ne3L/YhunaPWIZEvLYMyHhcYZGG49DWW7RabPBLFe2eTdW/sE/3sfVD64+dX9F1RZ4hNxhyFBlI+8vRx+ho66x3EJBKujciDn5Vgm8cjT8kAuzWpxXEKLEfsJP3YPONusZ/lQvVlfs5r66jAD9TuNpkH61Q1+0n7O6k15EpewuCO9C8g3Q+hrTRSW/aHRWVWV2xzHn51tSj8l0xLevIbgmSaFJI2DI44lI6ipCPKsZ2Pvnsrl9HuydiWgLeXVa2YrCceLLTtCjlXYrqWoEJXGlpOdAxppCKdikpoY2mtTzTW5UxojNcBmuNSRDrTspuiMKW5U10YdKtV1LkTyKOKQirTxcyOVRd3vsNqtSKuyEDJqzEmBScPDvUsRpSkJvQhjOcikAxU9cRUcieREBXU/FIRinYWJSikpRSAdS0gNLmkSdXV1dRYHV1dXUAdSGlrqAErq411AzqaxCgliAB1NQy3KqrFMEL7TE4VfeaGhZtUbwsyWvWXGC/+QdB6mmkKySbUZJ5mt9MjEko9qRvYj9/mfSrFjp62zNLIxmum9qZ+fuHkPSrNtbxWsSxwIEQdBSyy8LcCDikPIeXvpt+EAsjrGuWPuHU1EI2mPFNsvRP60+OLDcch4pPPoPdUtIZw5bV1dS0hCYpaXFdQFiUorqUUgFrq6upCOrsV1LQITFLSiupCsSupa6gBKTFLS4oCxMUlL1riKYEbYqMrUxGaaVpp0WmRgUtOC0oSnY7GYpafw000WKxMUmK4HelJoGNIpuKU11UM7G1JwDpTqcNqVisjCUoWpa7FHIRERQ1R32uOcZFvFj4sf6Ci+1DNHBkF1cEbyzHB/hGw/nTi9AXOHNLwU/FOpWMixTTUrVEd6aGMcbGsJ22bi1ZF/DEtbxweE1552wbOt3GeSgD8q1xfkVDsi7FWwuu1cRYApbRmT/iOwra3n9m0nWJDkZZv0rM/RbFx3F9ckbuNvdnatR2yYRdnbvG3FgfM0ZXeSiHuR5Q2QKiPUVM+9QNtXWjooY21Rsae1Rtv1qkwE4tvKoyelcWwKjZsA+VNEsgufEywj7x391FNCwusWPpKv60JtsyM8x+9svuojo7Y1iy/wB8v61U+mjP9nrfbL/YJv8AIa840VQttg/eUmvSe144rGUfwmvPNNXu1VRz4f5VyYH8Axk54cDwMdvKmMFx7DfKpFLMMcQ5eVNYN0YfKtiyuwXjHgPLypMD/DPyqVgeMeIfKkIYEeIH4VViIiFz+7PypIUDuqmPYnepCrZ9ofKo1lMIL8QOMnBFOyWTtbQrlig2oXpFukwuLl0GJJDw+4VFf6o/1WTE6FyMYEZG/vqFL8WuniNLhMomw7s8/fVJOjNtWTafClxf3c/COBT3aj3c6JfV484CLQTTrxbe0RPrKKx8RBjJOTVhtUVcf2uPPP8AdGnJOxJqj0TsfoUUMhvZIwGK4UY5Uc1jWILCI+INJ0UV5ha9t7v6qYfrCR4OAe7J2oZca00zlpL3iJ/8I1yv08pyuZXNJaDmpTfXrl5ZhxE9DVUQRAbxrQj9qj/vY/8AKpo1QAk/XP8A9TXSotKiOSDJgj3+zWuEKZ/drn3UEOrj/vn/AOppy6sp/wDbD/5VVxYrQYlWGONnZVwoydqr6TCn1JHdBxSEvy8zQa+1LvIGQXRbi2I7vG1TR6kiIqLesABgYip8XQrVh7u4x9xflUd2Eit2cIMjeobEySlZDcGSMjIyuKl1HezlA22qPJfgqCQSIGUDGfOpQT+EY99CLZ8SAcZwTyzRUcI++fnVPQk7KskojgnmPCGbIXxUyw7tbiNQg7xY9ywwaS9hhMsSKMNI4JPoKnbg+vRniPskZqr0LyXgW/CPnS4YqfCPnTAU/G3zNOBXB8TfM1Bobn6NWOdQQ4/dqdjQzX0IvXPTNXvozIN1fBSd4R+tQ9oVxdN765o6ysEZ91HFT47VpHVWRwrHniulByMb0b7O3eoIRHbwiWMn765AronJxVo0SO0uyNtqCtYTMMfvFYc62UVmrsJEmkQH2lU7GksVuHdjexW6npwc6ucapIFUDPkOlefkyOTKbtUP3QDhBNTW8jKDxDAPlURdVIDMATyBNP8AdWDM2r0TSy8S4HWqzMA2FYFzyUmhGq3l5HMsUETvk7kDAA99TC1DgSRKBcgZ4mbODVKFIFClovy9+BkBSPw063zgkqFbyBp+mSzlSl2F7wbBh96n6jAXQNGSrg81qL3RDnumcT51wFNbjiC8YJB6jpTgy9TtQP8AoWpO8BUAg1HkY2pzDG+DikJ0xVJ3IBIqoNOh70yyAsTvgmrsRAUnrTeM8XEaLa6Jt3ogS0iWTjSLDeYqcx4PEcAmn96McqYckFqLYb8jwVUeE70wEtud65FzyO9SjhXOKQnoZxY6VzMH2PKnM+QdqbGoJyeVAfsQqDshpO7OOVSs6gHBGagEjE7nahDTbE+FMkDFfAcGpzHsT8qiqkUmVDArnxnxU2SxXgJU71bCDi4jzpTyquTNebXTMubaWS4KKu5OKaBP2fnaaVVljl24geVFtWuTacDQqOPPXrQjVb86hZGCSMKSc5Fbxcpf0avnkrWh1zr94/gt4FQH75OcUyyvpLVyw8TN7WetJpGlTXCBVJCD7xq3d6JPDIqxnvA3Xyqv8tfEuKxxfFlm01cSTFZ8KhG1DbmUR3jtA22cg0Qj0IsBmXxeQFCr+1ezmKSZ9D50Q4N6Kx+25VEsRd3NxPczEMeSqMmo7mbA7tHdk8mFVY5mUYTAPnjeo2Zi25yfM1oo7NlDZOCSnTA6mmR7uAG4fWn/AFZmUHipZkdIgeBPD1HOnaKG98yvhmLj1q0iRyDiIGPzoarkSAqcHOc1JPO7XCiSZWkbkM86HETVBq3QSxvDEQoPmKksbOOym4LrD8fsVUj723CuQyk+Y50F7Y39/BDBqEfcPFCcFSTxA+eKxUXJ8UznyWuno2bQdwwe3B57oeVNmu5EIJhITq1CdD1gzW0Usx4lkUEkdKu32oI8TRxbhh7VZuDTpmftyumrJbrguocwYaSmrqCxKEmRg450Ntbg28nGoBPkadPMs8hkfhDHmKrh4NPa8PoHfRmVj+jbsXJnnpFmjfGFK1FwEYBZMYPnWO+jW7t3+i/srDIeBxpFoAfUQpWxiKywowIYMKyppHNFUCb+2WAhkbKH8qlsY47m28aYYHGetdqi8LAAED31Vt7h4c8B51r2jdbQogke5eFSW4PvHlV2Cx7tuIybnbapbeRDFlRknmfWuVO8mWRycLyWpcmJtlc6c5YnjGPOlgtpbeUOfEo58Jq68jgEfd9BTGbiQg9edLkxW2So4kwUy2fKrkIljbxLgH1oZbAxyKIyBv1owrv/AHvC3lgVnIxya0LIXKnhxn1psFsye0+Qd8dKVOIyHjwF6VMjAczUMxbaVIayhdhypnCQc9Kl4g243phJY0CTEqJ4y7blgBvtShXV2ywb0pwY9RvTK66AXaGyF8kbwEw31ueKCbqD5H0NCL+Be1mhTRSL3WrWp8UZ5q3p6Gth3QMvG2/pQTtDp80c66tpig3kIxJGOUydQfXyrWE6pBKvB5t2d1Ca0uhZSkIwYhOPYBuqH+E9a9K0O5j7pYlyFcnhzzVvvIfUfpWH7aadDdwx67pme4l2nUDeN/Mjp607s9qbXkXBcSspTHfhRg8I5Se8cj6V1ZEskeSIi+Lo9Ju7aK8tpILhA8TjhZTXnum2zdle0csdzdNHaupaIt7Eg8iehre6fOJYu7bhEiAAheRHRh6GqnaXR4tZ0ySBwBIPFG/VWrnxz4/F9M0avaAPae0W5hg1TTpFySHWRTybofjyNaDs7qi6rpyTY4ZV8EqdVYc6z/Zi+ie1k0m/jWGWId3JHjAI/EP5/OqaSydnNdMsmTA5CXA8wfZkH860cbXHyhJ1s9BFLTY2R0V42DKwyCOop1cpQldS12KdgId6aRT8UhoTHYykIzS9a6qGRHY05Wx7qVhvTcb0yuybmMilrl9kV1QQcwyK5QAKWlxQ2IayhhvTQm9SV1Kx2JXc6WkNAjq7FLiloAZgVxFPxSYosLG12KWuFAHYrqWuxQAldXUtFgJS0ySRY/aO/QDmajxLL7X2aeQ9o/HpQAskwU8KgvJ+EfzqrdzrAga7YkscJDHuWPl60k11wObbT4xJP978KerH+XOpbOxWBzNM5mumHikbp6AdBVdCK8VlJdFZL8BYxulsPZX/ADeZ/KiWMDYbCukZUXic4FQ4af2wVi/D1b30XYzi7Snhh2HV/wClPjjWMELzPMnmaeAAAAAAOldSsDq6upQKQzqUCkpRRYjq6urqAFFdXV1IQtdXV1AHDnThSV1Ili0tJXUAdS4pKWgR1dikpcUAdiurqQ0AJSYpa6gdiAUtLikxTCxKa3I080w0FIjpKeRXYqh2R1wp5FJjenY7FArqXFKBSFZw3paSlpMCtqUwt7CeX8KH503TIfq+n28R5qgz7zuar679otra8+/mVT/lG5/SidPwIbXGlrsUhjDSYp5FIaqyhjjw15T2xmLaleBfaeTgFerSch768f1R/rOuzdVjZmPvJ2rfB+VlR7Nt9HMAjs7gryBCj4VZ+kKTg0RU/HIBUnYSPg0dm/FIao/SRJi0tI+pcn8qz7yk/wCs89Y5qI9fKpGzmoZCc12HSRuahc4zUrEA1BIc1SERsaqXbkgRr7TnHw61YY88mqcR7yV5Ty9la0j9mcvonyFUKvIDarWjf9rWh/8AFX9aonJzVrSXxqdp/vV/WlLpks9s7Trm0f3GvOrUASj3Yr0btL/sh/y15zan7YZ251yYOmLH0SgKAMR9PKmsBn92fkKdxDhH2g5elNJyP3gPyrY0ZC4HGuI/yFKQMex+lK3tr4x+VNY5P7wY+FUSNblkR/pVWeNmgcIg4s+lWiR/ifpUWR4h3nX0ppkszLJ3t1HE4IycnpUF7AEMSxhiWO4Lc6vW32mps+c4bhHrXQILjVNx4U2+Nbp0YtWUxCP+7n/zDTJYgEYm2wAPxmth9Tj4fZFUNWtkWFEXZpHC1KyWxuBnYrbwLxW+TjnxmuMG/wDsw/1mtS1ugAHCPKlNrHyAFP3Be2ZeG2VmIaAKMc+Immi1wSBCrDO2WNaS5t0jhZgNwKggiUqpI50KYuABNpv/ALOP9ZrhAV52y/6jR8xqDjHWp4YUcHIFPmLgZZkzOqiBRgZI4udTxRKXAaBR65NEIIllu7mQDYMI1+HOrd1AiL4QM4pufgSh5J9KULboBsADtVm7GbaUfwmq2nH7FPjVqcZgcfwmsm9mi6M7bcXejYfOjA4/IfOgsBXvBuefnRclQCSzbD1qmJA26lnTUjKq8ccIAKrvgGrKzd/ewtEVYYJOCfzqDR27xJ5nZmZ36Z2q6giDsyghiNzg5NNsEiypk8l+dSZfGMCoU4dt2/Olkmgi/ePg9BvmpLNt9GhP1+5Bxgw9PfU2tW5m1Exg4ydyelUvowlD6rOBFIn2Jwzdd/KtBr9tjie2DyTsfZUcq5JSrKxxqyjHoRtSJGCzKfyozpccixMkRWNPQVS0a7uIwLW7crIR4eNaOwgxKFcgt5gYrLJN9M25aqgbfWFw6kwy+POx4sGpdKgeDLTJIZn9pic5pl3Bp9tP9YurhlYnIBfb5V0+v6fHCCkyyEnhUA53qdtUiXJsJywRzAd4mSOR8qkAx1zUVtJxwq7MrMRnCmnI5KsxRgfI1mSSMQBuM02OMDdUHEegoDca3LZXx+tRjuTsFG5HqaJ6drlrcS8MIYgjPFTcZJWJ34L4aSLxPB4fPOSKnS5idc8Xzpj3sAU8Tj3VDBbxykvx7HoKzr7M6tXJUWjLE6EFhinIkZjAUArUZtYcYx+dSQxLEuE5UtEOq0PwqjlsKruxY+nlVk786ryYDbUIIdnAZGV50lOLYQBRjNNG/KmWhwQ4ydhT4iCCKVFPCQ1NVCr+lIhuxwjANcIxnNPrqVk2ztqieLibOcCpaQsBzNCBN+CPulUZOTSxEMDgAUx5hyX51GvGu6g4p0aU2tjpmZW51GNxU7KJI+I7GoUVjtimhxaockbN7qR1C8jmpGiZVyGqEAk4oGnewXrhQ24U7yHkBzoQunXTKCIWwa2AtoeMOyqZB1NOupe6gYjHFjYVrHK4qkaw9Q4rjFGZg1WfTEEMkI2+dJP2gmkxwRqnnTLjS7+5ZpnXJO+CaFTwyQvwyoVbyIreMYS/s6YQxzd+Q5D2jKAB4QfUGqmsatHfIqrHgjqaEGm1axRTtGscEIvkkPVsMCdxVtJYGG64PuqiKlhYK+cZ99W1ZswihGPDsKU7jB5VW+tKDhlIFTxN3w+yDNjyFZNNGbKVzEEYFeRqi9hnVrbUuHvhDzjPX3UWlVmJWRSBUtpAzOI48nNVzpBKnHYH7V9sXjvYFhtJPqoHjJXGDWf7WSPd2kN/Y5dMYdcHb3ivSLzSbZrciWeMEjDAgGsNqvZ69tlkGl6q5gYEmM8vdVYZw1WjmhXHjHoTsLqQurBraQ/aRHl5itOzcNeX9mXurPV+94GZA3DIQNhXqEeJACpGCOdVnilK0bwdo7ORyrlGRtTnThOCQfcaZtWJZD9FWnwN9GnZOTg4nOkWhI/9ylG/q5EskaJ3aoeLKnGxoR9GWoQ2n0XdkOFfF+x7PJ9e5Sj97qURjjmiKEnwOG2xn/nXNHkeZFz1oYIInfLFivUE5pTaQyKUCiNBvxU2weKfL3EwRgdgNgaimuWM7LHMnAPvYqt2bbukLDGI1KhywztUnupkTIqsq8LsdyaliQyHAKg+poZXXZZtYO8TxM4I8+tS3MWV8KDI+9SQxNFjDsW/CKsxliuXGD5Vm2c8pbsqWoO2Ywd+Zq23Hw5UAt0BNQXKpzDKG8yaYJxboDLMpX86HsH8tomd5EXi4ckjkOlV0eR85HEDzAq/wCaAFGwGGxpYIhEAucnHPzqbIU0kUjdNCvCkZA8iasQSd5EGbwyHpUF/ky4GNumKiy7YJYjHL0qqsvipKyd4pWlyGCj86mSPhbPEzH1pneMQpUAnrUobPSkS7FNNkJVCRg04sANzULXCgAjOOvpSSJSbMrq9v+zp5r2KBn065HDe24G3+8UefnWA1O2k0DV45rSTjhP2sEg3EiHof0NeyvMsiMrHCkY3GQawPaHSEgj+qs2NPlfigmI/2eQ9D/Ca6sOSnTCUPJY7N6ibp4pbc8EQyIUPU82iJ8uq1t45BPbLNBurDr099eJ6ddy6LqMtvdo4iLcMyA7gjkw9RzFeg6XqshJkVj9W273H388pR5A9aebFu0KD2RdsdNl71NUtAEuYfax94etVPrMOtacHCkzRAqYmO5H3k/mK3FvHFwcVxhlYbA7isHr+nNpWpfXLBSYXOODlxD8Pv8jSxz5fF+Cpaei/2H1gd4+ktMsvd+KByeaeXvFbUV5OLWNpEv8AScJO78aHixwuOakev616Do+uJq+mxSxLwSDwyr+FhzFTmhu0KLvQXpc1GhYjLAfOn1hRR1JSmupoBj0gGTTyM1wGKdjs7FMcU+kk3FJAjk9mnUxTgU4EUMGKBS1wI6UtIk6urqWkAmK7FLXUAJXUtdikB1dXV2KBCEU0in0hpjErq7ONzyqMSF9ohkfiPL/nTAe7Ki5YgD1qPMkns/Zr5nmfcKckQDcTEu/menupl7dRWqAyElicKijLMfIChAKFjgRnYgYGWdj/ADqiZZ9SPDalobTrNjxP/l8h605bWa9dZL8BYhutuDke9j1PpyoiBgbbCn0BFa28VtEI4ECqPmT5nzNOkkCYUAs55KKa0jOxWHBxsWPIU+OMRg4yWPNjzNL+wI0iJYPKQzdB0WpTSmuoASuxS11AxBS1wrs0gOrqr3d5BaKDcSqnFso5lvcBuaiSW8uRm3txBH/iXGx+Cjf5kUPQfsu1BJe28bFWmTjH3Qcn5Cg9/f6VaZGo3sl7KOcaHwj/AIRt86DXXbuG0UrY6fGiDlxNj8hWkcU59IX9I163nGcRW9y48+74R+eKZLdXSbrYtjzeZF/rXmN59JmqlyIEtUX/ACk1UP0jauw+0it2H+Qitl6TJ5oVy/7T06TV509q2t/d9bX+lRjXyGw9rj/LcIf5ivKJ+2Iu8/WbREc/fhbH5VQfWVdge8bh/OtV6T7KTT8Hti69BnxW12B5qgf/APZJqePW9OYgNcrEx+7MDGf/AFAV5Hpuu6bDg3P1qQ/w4Fa7S+1+gMgjeW7iU9JV41/nWM/TyXSB8TfK6uoZGDKeRU5FLnagNhBoWo/aadcRrKfvW0hjb5Aj9Ksmy1ezJNtdx30f+HcrwN8HX+YrmarTJ+L6YVpc0Ij1uGOVYdRhlsJmOB348DH0ceH54NFQQQCDkHkRQDVD66krhSJFpKdXUANpcV1LQAlJTqQ8qBjTSYpwGaUrTCyMikxUhFJiix2MxXYp+KXFOwsZilxTsV2NqVisbiupaQ0DBbHvu0KJ923hLH3scD8s0ToXof20l9d9Jpiq/wCVdv1zRI5Bqn9DQ7FdXA5FcTtUgIedNOKY7k7CosnzqlEpIW6YRxMzHAVSfyrxy2PemWc85XLfDO1ej9tb02uhukX76f7FPjzPyrz5VCIqLyAwK6MSpNmmJbs9O7Ix91oNv65NZr6SJCbu0jHRCfzrYaEnd6PaL/4YNYT6QJeLWwo+5GBWePcyYbmZR+VQNzqZzkmoD1rqTOghc86gc1PJyNVnNWhFO7chOBfbc4FcqhECjkBimR/bTPMfZHhT+Zp7Zq7rRmt7Gsan0441G1/3q/rVcmpLE/2+3x/iL+tD6Ez3btJvZf8AD/KvNbYHvgPWvS+0IzYA/wAP8q81tjif41yYemLESgAKPst/hXAjH7r9KaGGP3n6UmVP95+lblsbJuy/Z439Kac/4Y/KnOyrjEmd/SonlGR4/wAxTEOwT9wflVW6k7iCaQqAoBPSpzJgZLn5ihOryGREgV/3sgB91UuyX0VbI9yiOwxvxE1Z0hNllPORi1ULzAzEjElmCjejtrGkSxoPujFXJ6MkthPPg9aG3JM2q28fMRqXP6CiJ2FDrEmXUbyU8lxGv61nH7KZZkGMUibsKkmGMUnLpQBBdkGJx6VDaj7NQasy4IO3Oo4ABH6070LyQSDxHFI8ggt5XPJVJqVv3hqnrJ/syxJzmcJ8KpbExNKj4bWLI8TeM+81PceJmAqSJArADkoxVdnzKc07tirRNp2OBfeauyjMbAeRqnZDCj3mrp3Uipb2NGYjLB+Q50RvZmjtXYcOSMDFCpJYopSHJBydt81NcyPcSQQxRsgY8XFJncD0rQiwhaobeBIwEUAb9N/Wozd5lIgHfPjGE5fE0wWqE/2hpJj5HIX5VZjCKQFQgAcgDSstWW7TS9T1BA0akJ1WIZPzrbaN2IsZbXiEsiXJG/Fuc+tZHT76azI7iaaNTzC5rc6P2s0+3Co6TgkbuVzmubNKf+kqhvZTSrrSO0rQ3KjhMTBGHJq00dsFuHmLEsTy6UiTve3tvPbIpiCkiQ+o8qJLbgJgnxnc4rjnNt2xKXHsoC1hExm4AZD1NOmaJF4pWCqOpqWe1l4SY5OFumeVD7WyvmuHF80MkR9lAOVJO+2VyQEkuNDu7xoZhIcn2mzw5qeDsjpyXQuEdynMR9KLDRZhemUyRdxjaHu/51dWPuxw4xireSvxYKSfTILaygtlxEmPec1O+yEA4J2FOUcRA5UyQhJ1Rx7jjas7sL8AZOy7XFy0t3cEqTnAG5otBodnaoBCpUgc80+YElWGSR0BqRXbY759ablJ+RNS7sEy2sqXXB7QPI0WitljQZZg+OlKGfi4sgn3U/ic+0QT6UnJscpyaSIZI5ApMcpJHnVmykMkAZudVWuo1lMMrBXI5VDDeLbAoillzzoabQnFyVBg1WOzbb0176JUBJBJ6CoFv0LYValRZnGEvouFS65xg1JGMKNsGmCZeEHO56VwmJPs1OyWmx8mQpK8xVSGdppgreEDpV0VBMiAhgMMOopoItdMnpMknYjFD7i7ZvBGdz1q3aoY4RxHJO5oqhuDirZKwypHKo1hGfESa55cbLg10cuWw2KWxJSSHiNVOwFOJAG+1Mn4u6bg9rFCFun5SEnBppWOMHNWFnkVedcsiEbHFVOLO9cKdFe2idpHJOAOGoy2FONs9aZk1WltuJiSx4T0zTSRUYIIJEmAS+T76SS1SR1Yk5XlvQiYNZW7yh+JUGcGgB7YBCSgOfKrjjlL8RODvTNzJcRxbSHhobqF1pt0DFNImeh8qxOr9qpr+NIkiAIO5U7mmWsrzJxMnB761h6ets3w4E3bey1eqsE7BH4k6HzqAb70pXJ8W9PXZgSAQOldK0j0VpF3TdKuL7JjAVR940Qk0OWBMlA+OopljrskCiPuk4fTatHp1293GXaPgX31zZJzi78HFly5YO60ZJrVA/jUjzFHLHULS2jCJDwgczin693Hd5UAy+lDLGzmu28IAA5k0m+cbkNtZYcp6Dk0NtqFuXUBT0bGKEvC9i7ETw5xyJ5ii89nxWyrIT4B904zUFtbWhBD2+SdiX3NZxlRhCfFadoDx3ERJPcqxPXNQypuTw4BrRHTrO24pmGFHToKFGGGWVmQySAn2UFaRmn0bwzRe0Y/UtF1K747eCSOLTieM4ABzRmyi+r2cULe0gwWzzq9cRMknCEcA8g3OkktHRA0p4M/dPOtHktUzSPFbRPpFkl7IxkbCL5HnV6fTQkhCW8br0JYihUKKoLGRo/8o51IbufpM5A86zabemRKM5StMyP0b3oi+jvsqiPkfsm0ztnB7laOXc0c0TgsTIRtgVjfo1k7zsF2bHs/9W2w39IlFa5kSJlaB+9J5jHKtVFJIcUuKJYHDRqwBBIzUySFc7A58xVO2Yh5IyCu/EB6Gnu/CpCcRNS1sdF2OdowQoHyp/1qQ45CqEDMUy2c+tWIhxuq5xk86lqgaLtreiHiZ4+8foc71Zt9TuLgEd2EHU0PuYhCwUNk9afaRynxp7PX1qWl2Q4Rewg8hdhxU1xGcGTGM0hdQgYkeVMM0ZG5BPkakVGhjlTu14B4cbVWXvmkYluFTyzQqC77iZeJ8Iea0R+uQjI4gB55qHGjneNxeiGbi705ZmPninxoSNyR7643PeQHAJ9QcZqld3AMQEBkJ6luYprZat6Ll3K1ugMIVj1JNUlvp+9zJhQeQO1LFHFFCJJGzJzyTVm1nW8TglhBI8xtR0FUh/1vMJYRnI6VQeeaV8bqvkBRaJO6cosShMZBFQ3DNn2OEedCYotWVcY6b1YNus9m9vdRLJBIMMp8qbGivEZGfb31PasRGWcnhHInlQxzdo837T9npA4tT4rlFJtZj/foP7sn8Q6edCOy+sPbypZz4yCREXOACeaN6H8jXq2oW1rrFm8EjYYbqw2ZG6MK8y7QaK1w8zR4/acJ+1ReU69JF9fMV1YsikuMjn4NdG5s7oRwxx4zE/7p2PI9UPqOlEWiintHivIQVcYrzPstq4llFrfO+eQJJyCOTD1H6Vv7a/ErC2uWzdJsSoyGHRvdWWSDizaD5KmYnWbebR718AvBJucbcY/EP4h1+dTaRq502/W/TDWk5CXIHIE8n+P61s72zhvbdoJ1DA+y3VT5g151qdpLoN+0d2oa0lyrY9lweo9fStYSU1TIlDi7R6/CxeNWODkZBHLFIHPGVcY8vWsd2L1d486TcNxuq8dtKT+8jPL5VsV4nXEi4HnXNOPF0NfZJTXdV5nelXhxgEbVDL3RkBZt/KoBKyYbjNdUEkpRwBgrTjNlgEGaY+LJaWkpcUiRrDbNMzT3B+Fd3ZxmmmNMbT0JzinBB1pGwvs86LsTdj67FR8RBrmbNKhUO4xmnAjGagrs4p0VxJeIU4MDyqGuHpSoOJPXU1WHWueRUxncnkBuTSM2OxUbyANwoON/IdPeaTgkk3c8CfhB3+JqVFVRhQAPSgCHuSxzMeL+Ech/WpcUrsqKWdgqgZJOwFDDLNqR4bRmhtOs2MM/ovp60dhZJdXpEpt7NBNc9R91PVj/AC5060shC5mmYzXLDxSN09FHQVYtreK2i4IUCrzPmT5k9TSySBCFALOeSinfhDFdlRSzHAFRYefnlI/Lq1OSIkh5SGboOgqWkFiKoUAKAAOgpaWuxQFjaUClxSgZoCxpFJin4obqGpCCZbW1iNzeuMrEpxwjzY/dFALZZubiK2haWd1jjUZLMcAVRjlvtS3tENpan+/lXxsPNV6e8/KrFnpRLrc6m4uLkbqMYjj/AMo/md6Edpe1sVjxW9iVeYbM/RP6mnGMpuoj5bqO2EZRp2go1xMxkuGG8kh4pH+PT4Viu0Paye84o0cwwfhXmffWa1XW5rp2Z5GdjzJNAZrkkkk5Nd+L08YbfZcYVuQSudQY5EYA9TQueYucyuW9OQqrLOfOoTIT1rpSopysvJcxptwKvqKqXFw1wxWEZA5t0qrIOM4O48qmDYwAMCnpdCtvsYtoPvuc+lSi1jx7bims5pO8OKLYaJharjwyt8aUQyp7LA1CJSKeJiOtK2GiVLuW3kBPEpHJhtWv0Pt7qtiFV5frMI+7LufnWOEwYYbcetN7sZ4oW4T5dKUoqSqSE4pnuWkdt9I1dO4vFELuMFJBlTReHS/qyd5ok4jiO4gY8UR93Vfht6V89xScR4X+zk6Hoa0WgdrtS0CYKH72DO8TnII9D0rkyelXcCHBx/E9mi1FBOttdqba5b2Uc7N/lbkf1q/QbRNY0rtbpjBVR9sSQSc0P/z1pJFvNDHFmS900c8+KaEf/lr+fvriaadPslNS6DdLnNQ288VzCk0EiyROMqynIIqWgQuKQinUmKQCYrsUopaAEArhS11ACHnXYpa6gBK6urqAErjS0hoGJiqmqT/VtOuJvwISPfVrioTr579rOzH9/MOL/Ku5qorYFrSIPqumW0R9oIC3vO5/WrTDrXNvTTR+ykJSNkil601jTRQw4zSYBpSM1DdSrb28kznCIpYk+lUMy3aRhd6hcbgxWEGf/ePsPkKyKDidQOZIFad1deylzdy5769mErZ8idh8qz1ineXsCY5uB+dbp0ma4+mz1qzXgtIV8kA/KvL+2b8faG635YX8q9VUYUDyFeOa/IZtYvXPWUiscPdmeFfJsGPtyNQvkVK1QvsDvXUdJC5qjfuQgRfbkPCP61caqEZ7+d5t+FfAn8zVx+yZfQqosaBF2AGKjbn51M3PeoWBBNOxUMPpT7Q4vIP84/Woyc8qmsUzdwj+MfrTb0Sz3fXv+z1/yD9K8zgP9o/4q9N1r/s5f8g/SvMozi5PlxfzrlwvTIxeSUk4xwDn5imEt+EfMUrFN8yHmetRsU/xD862NBkhOV8PXzprMxIyg29a6QqMHvDz/FTGKdZD86oTHs7Y3UY99CsmfWGIUYhXlnqavSPGqMxkYBRnnQzScNDNO7kNIxbOelVEh9lRyX1eNW5I3EaPxENKMbbms1atx3Tylj4n236UatX/ALRgHqaqRmuw1I3DGW6AZofow/svennIxc59TUmpzd3p0pX2iOEfGpIEEUSR8gqgVC6KfZJLkkb01zgCuYgj3VHKdhQhCy+xmqttIzPKDkqp2yKsyn7E5O2KrW5DQBsdaa6Ex7DByapT/b6vbp0iQyH39KtvzzQ2yuoRd3cztl2YRqoGSQPSqQmFY+bGh8jYckkAA1MHupVJjiWBPxSbn5CqX1RSxaZmmbn4jt8qEDLNreqfDbo8z5+7y+dXO5up/wB9MsKH7kXP4k1FpxUphRgBuQokcAUmxIyghWG4cKF9o7nJPzq5blpb6WTw4jUIKqXrKk8xIOxJqXTcfVFYq/E5LHar8CXZfy5OfD8qeofjG68vKm28aSzJGcpxHGWGwrTwdjb2RBIjQFMbENzqJTUezRIH6LcLa3qyzwieMc1xW/tZdJktvrBsmjHPxR1V7H9nVsJJJdQXEo2VcZFavIAwMFfLG1cmXIm9DVgTRtct7u+FtaJ3cYzjOx+AozHaO979YEzAdQetQx6bYreJeR2qxzJnDLsDVnJ33OKwbXgW2ERjFV7u6W2aIFC3G3Dt0rklQRgA+KoLmxt3BmnZ2xv7VZpb2ZKNPYQqpc7SVVTUB3OLdS3Dt4jvTFuix+1GDTUWjSGKSdkxdccxTWDOBgjhrhbLKPCOe9NjCRkpup8jVGmvBKuw5ml4h1IpMeVRyxlmBXAxQLTK97qMVqu+SemBUun3b3UYcIVX+IVMEGPEqk+6ukmjgTLsqKKOwdeCwqRM/HIiluWSKSe0ilU8IAPpWTGqag99K1piaIHAHQ1pbAXE0Aa6CxOegOaJRcdkOLjuwXeYs5VSVDluRromBc7e6i2oBBCqy4Y9CaEySIm+Mn0qk7R0YpOStl+OXA+zQkjnS/XCTgAZ99Ns7qIxgEcB9aH6rA63cctqwwTlhnaklbIpXTQdjkfgBO1IzbjiPPzoempqCEkXDVKVkuhxZ4VHKlx+yeFO3ot91GviK4PnT8rwnc5NCJzNEOFy2KltrhUQ94xJ9aOI3idXdl4DFTCJXUHODUFrcJP4AMY61Zc90nhFSzGVp0NVZBkFsioWtlTJIBzUxm8G2zVGzcS7k8VALkhhXA9KQCnYOM03O9BYuBT04SpVtvWufg4QV59agmDOuFPCfOgKsFdsOKLRpe6OQ2xxzrJaP2Sub9RJKxijblnma30FvjwzN3ino29W0KxuNvCK1jlcFSBtoz8HZKK1hxAwMn4mqjd6Xc2p+0TKea1t+NeHOaESQyXE7CWU93nYUQyy8mmHNJd9Ga+qq4yGIPka42e2zb1sE021AxwA/Gqd/pOxe2bGPumrWa2bR9VFujMG2f0ola3c8NuIlYqKaVKnBG4pvWrb5dmzqS2cSWOWJJ9aI22oiCMKqcvzodiuxUtJ9kyipKmE5tWldcKvDS6aHubnilckDpVCAosimQZXqKMQ3NuTwxng9MVnJUqRjOKiqigqVUrwkAjyNIkaIMIoX3Ch0lzHEd5N/SnwanAw8bYx51lxZxvHKtF5o1YgsoJHI4qvNYwzTCSRSxHTO1RpqUUsndwZcjnipmnPQYpU0JRmht1Zxzwd0AEHTApkGmwRRhSoY9SanhLMeJjtU1HJrQOclqzwv6PsDsB2YJ2xplt/8Ja1CTsigADFBfo3tSnYTso1yh7l9LtTnGxBhWtfNb2tzbh4ZEXh2IXzru5KkelGSpA24uE+xePPeseBs9M1bhjm8PeJwgnnThp8cUTcRDzcJbC748qKWxW7tIZW34lzjHI1EpJdCcq6KM0HdnCnjPUjlUAIBGQfhRjupTE6hAFGwfzoZDAy3SiY+HOMcqlME7L4it1CccEp4uuc0+ON4g6rgIdwfKrCjC4XkNqRgcnhchsee1RZANSEyFsMM56mr/cI6KJBuOeKqtHwZaaMuQc8SbVfjYvGr8JUHoRQ2DY6O1iKkMoxj40Ov4EiYNEdj0JokWO2elKYY3XidN6SdEW07YPtLiVysYC7dT5VYuJ3h/utj1zTrW2jjlLjJ/lU97GZLfhhAPU5obVg5KypBbqSJXGWO/D0FXxMVQBFXPrQxJriKPxJkDkSOVKW72IyNNwuOSjak1YON9hBr4IwWSMqTy9ahv5JGj6hD0IoewuZoxKeJ1Xr5UQsbyLusXEhLfxDNFUS48doHm4OOFVC0RWa34I1kkLjGSByFQ6k9rIoaI/aegxVIDuSDlWLL8qrsr8kXbu0eR+9twO7I5g0OudDmuoluInWK4i8UZPX0PoaI6bHO44CzCA86vmxQneSTg/DxbUuXEiUq02ecdptEh1G2OpaTCYL+E4mhU8yOfx/WqXZ3tHCiBbnEU8fsNwkg/wHHQ1vL+1ispjcW7ZkG0sf41/qKw3bLRlspotc04RvCzBnTmM/ix5V0QmpLizN62j0Kwmjv4FdV7v8Qbmp8jXazoum6tAIrtVbh5EHBU+YrL6JqpvxHdWuViA/tAbrjy9R5+VbKEgRpIqpLGwyGXfI86wknB6LbUvJ5Nf2uo6LOUnt50jtpC1rcldgM8ifI16PoOrx6npkV1A/i9mSM81bqKL3DW9xbvHOoeJxwsjDIIrz1oX7Ha4JocyaNcnhcH+78s+6r5e6qfZEbT30bdnLEknBqaNYnQk8WRzFVVdWUMhBUjII5EU+NyrZUke6smjocbWh8gUHYNj1FLHLwKce151O00bIAVZvU1F3JbdFOPWlZKdqmSQ8MjAk+LyqZpFU4Lb1DDiEHjDAn0pqRM54gwx6mkQ0r/Rb5janKNqbHGFG361IBSMmxKj5Gpq4KPLelYk6ICM0hqwVBqKROGqTKUiMiuxTsbV2KZVjcUhIUZY4FNL5PDGOJhz8hTlj3y54m8/L3UBY3Lv7HhX8RG/wFTwxqgyBknmTzNIoyamxgVLZEmLVe8u4rRAZSSzHCIoyzHyAqC5vmMxtrFBNc/e38Efqx/lT7KwWCQzzOZ7phvKw5eijoKVfZJAlpNfOJNRAWIbpbA5HvY9T6cqJAADA2ArpHVFLOcCouFp/bykf4ep99FgI0jSHhh5dXPIf1p0cSxjbJJ5k8zUoUAAAAAdK7FFgNxSYp+K6gBlOArqWgYmK4ClofdXMk9wbKyb7X+9l6RD/APe9KAG3txPcTGz04hZf72cjIhH829Ktadp9vpsLCLJZvFJK5yznzJqa0torSARxDCjckncnqSfOsF277T547Cxk4UG0sgPP0FVjxvI6XQrcvjEXth2uLmS005+GIbPMDufQV5teXhkJwcL+tVr+/G4B8PQDrQ8uWHE+w6CvUhjUFSNopRVIsSTEk77VWeTORUbycR8h5U0DNaD7HyspP2YIGOtR533pwHSq88oSRF6saBdFjYHakJ3qMNSk+lAxxakLDFMJ2pM0WA/PrXZqMmuDUWIlDetSo5FVvWnBqVjLquHGGANTRMGTu5PEh5Z6UPD4qaKSgdluyvbzQr+O7sZWRlPhYdfQ17x2K7UW3aXTg6lUvIxiaLPL1HpXgqsroVcZU+dLpGpXfZ3VoryzcjhPLow6qaxzYlkX7MsmPyj6ButPm06d7zSUyjHimtAcLJ5svk360QsrqG8gEsDZXkQRgqeoI6GqnZvXrXXtMjvLRtjs6HmjdQafeWrpMb3TwO+/vYuQlH8m8jXmtNOmQnfYQrqgs7mO7hEkROORB5qeoI86npAdXV1dQI6urq6gDq6urqAOpKWuoGJSHlS11AxhFCUH1ntG7c0tYeEf5m/5Ci7EKpJ5DehXZ5S9tNdt7VzK0nw5D9KpdBYUxTSKfSUhpkZFNNSnFMKmmikyM0C7Us01vBYRE8d3IIzjonNj8qPEVn7X+3dpbqfnFZp3Cf5zux+VaQ+yrKvbErHo8MSbL3gUD0ArM9nk7zWrRcffBrQduWxBaJ5szUK7HR8evQH8IJqk/i2bR1BnpMjBUZugBNeKXzd5czv+J2P517HqT93p9y/lGx/KvF3PzpYSMC7IH5VA/Kp5Kgfl5Cug6CjqEhVBFHtJIeEenmaQIscYRQcKMCmwDv53n3K+xH7upq4tlNIpZUJFW3WiFvZRbHxFRE/Op5FKNg7ehqErk9KExsj3671c0xAbyI45MDVbl0q9pg+1UnoRTb0TR7Zq5/6sQ/wD9K8wyBdMP4/516hqm+lR/wCQfpXlzn+1vgffP61zYfJni8k54ssAoOCetRuX/CAPfXMV43BdgeI9aaxQ7d4x+JrY0ZHIWwMqOY61zceRsu3rTZSoX225+ZpCyH7zfM0yWUtZldLMoAOKQhBg+dQ3jNaac6KACFCDfqaS54J9Vgjy3BEONufPpUeo8M19bwZYqTxtz5CtF4M2U0jeERoceHGaIWZxdYHmaqXfCLg+1nPrVi0IW838zRZNbCOoAvJaQ52eTiI9BvVxlyTVGFu+1k7ZEMWM+pq8SMnJqWMjU5BAqOQk4xVf67EsjJFmaT8MYz+fKo2+tTMMslup8vE39BTFZbuWSKAtIyqMfeOKGWl2zw8NtC0m58R8KirhtYI1LNmSTHtyHiNQWciqCpI5mmheSK6Wb6tJJczkBVJ4Ith8+dT6NbLb6fEQqh2HExxvvVXWJFeBIVO8rhfhRNXRUVeIcIGKbeheSZsd0aqMoVGPnUr3KEcIIqpPLxKQDmkhkmnEd23+aim+KEacwMb46NRWhiRldZBFxKo++2KvQIyxoARgADlVPVcHWGXhyF8Rq5GVKriM8vKrvQl2XbSB57hIkdQXOASMCtrDpcGkRLJqWqMy48McbVgxhSCIyD6CnvI0jqZAze/espRci0er23aPTBYs0cxIjHstzNSaXqqPZteXMqxxk+FM9K8pThx+7PyFF9IntVlVNQjdoc5GPumsnhSWi0z1HT9SF7ESgZUHLPWns8jt9kRgUJ0q802Zkis3l329najKRLGcqSK5mqZa4robJJMi7qB61NaSpcju5eIt7+dT2wVsnGQKsRxxk8YjAPniobMp5FVUNjt4YR4IwPhTZ44ZEIZfdgVLNxlCIxknzqvbJNAp7whl5jHOp/Zim3uyvwSQAGNjnqpqNy8h7xwBjzqyzljk86aULggDI61aZ0J+WR26yHxZHCelStHk7mmoo4cKSPSk4XGwekJ7ZHNaRshDOyZ+9xYrPaxpAZOKC6mkb8JNEdQ0+7my6T8RG4Unaksra9KZucZ6AVpF1uy4peWdosa2MCq65bqaMCZGGcnFVYBHFnvhhqlFzCTgVL2wmrekQtH9cm4uIhVpWsVA8B39anYxoC6MBVf695rRvwC5P8StNCy+GQbU6O2kCeBDw1M16je2nLlSHUlzgD86ezS5/Q76gjoC3t1ajI4QnUdKiguDNnC4HnS3EJkwUPC/mKl/sxdt1IllXjjZSM+VCGR0PiRsZolFFLH7Uob0qvdTuCEdeEZ504l4206RYtlKoCV4fSpyxxzNQRTxuAEbJ8qZezSwx8UUJlPUDnSatkSTb2Ws0rScSgHAxVe3nWaMMNj1B5ivPu0GrXY1mRFnIgVsYBpwxuTonjZ6OG4hsciuNZW37UWFvaAAs8gG48zR3Trs6haJOqGMN0NDg49jouAg8qXbrTQAOVMdCzAE7VIUSD0pfU1wwBio5CxGANvOkIl6ZqKRtts1yJxDdqeygjBNNAtFeOCTnxsvpmla3uCD3cxz671LgrybNJHNJxEYx/OnbKt+AJMsqTmOUZc75HWogGMyrIrKpPlRe6hkuZwccPD1pz2ayAd6xZhyrTmbrJrZRezYMAniB60lxbdyoyQSelFIYiigHGRUN2Y8/aqSfMUlJ2SsjsFqpJwASac0bJ7SkVesp4ImIK7k7Gi0ZjlBUoOE0ObQp5XHwBNOgWeb7TPCKI3Nzplp4J2iQjoedS28C287FCvdtvg8xQbtPoxv5UmhCg/eOOdTalLZhOfOX6COm3thcvJ9SG45uFwKtsq7kuSfSgWmXMdlHHZ9y3F+JRzo1nbNKSpk8RnEQetLlz940hbPKlwR0pFnlv0c6ndf/c37MQABkGlWqjw527laKQzmNZIlXxNvxUH+iq6jtuwnZoyozZ0y1xg/+Etam9bvXSWCOOIg+1XWnWqOuOktFC3aTvCqPwFuZJxVqCa9jgmjB+zB4uPqQfKrFjFC1xxXHFNJ+HFXL4NKYiYykAPASOgPp76UpbCUti6fcRiII11xPjOG2xUBvIppOCd2VgcAoNqgvtLaBDJE3Eo5550Q02KD6shURs+PF55qHXaE6W0PiuBM/DDIQRyZl51ZRWA8bAt1IGKZcmURcUCglfu4p6W8t3ahyWifqFNZszbS2SxqG32x6ioLqQIwBDknkAcVdgjYIECliPvGlkgQSqzDDnYZNTZHNWUI3nZwHiKg8iatElRwnBz5U+RJkUh8cB8t6SExoueEkinYcr2KgTb2s+lWRCvBg/Oq4mPF4eFR7qlS4HJqlkS5DhbpwsGyQRjeqg0qEA5LEnl6VckmCqCu5PnToizLlutK2ibktlWytmteIZ4kNTRWsUZLKgLnfJqeuoslybKaxCFZJp0DPz8I6UKuJTdTAJGFHQAb0V1GVoothkHY4oXYq7T/AGZCsN8mqj9m0OuTDdqGESDh4QByqfYVFF3ip42DY6+dSghlyKzZgyOSKJiSyKSfSs5rend1FJKkBa0fPfRDfhHVlH6itQDkbik4gcjnTjJxYKTR4lqltL2V1RWt3abS7oBkYcmXyz5itjo+uQvGghJMLbhVOAvqPT06Gm9qdOSNJ7afxabK3EQBvbv+NfTzrz63kuezesCOfkDxK3NWB5MOhBrtVZI77KVwdns6ylUPAo4j1NNu7ePULBreaFXSQcLgjnQbStdh1NYxbKDIfaXOyj39aO24cuCqg++udpxZu6asxOn3s/ZvUv2RqZZrUnNvK34fKtlFICFZCCp3yDzFD+1Glft+ye3KqtzEeKJ+qt7/ACrJdmNel0+d9P1TKmNuEg80P9K0rmrXZMZVpnos113UQ7qIZNRrezAjiVD6Coe8EiKykMCNiORFQuZegX3isqLWNF6S57zAKjh8q6QxAgpxetVYyxHjxxelOoofBLoJW8sQTGQvvNPlnVAOHDE9BQl24RnIHvpGeVeFohy6ilxIeLdhmGQSDYjPUVMKHabMkjtleGT30SqHo55qnR1MlGV91P5DeoWcygiHGOrnl8POkiUQyOqYydzyA5mmcLyfvPCv4Rz+Jq1HAiHO5Y82PM04xg1XJF8iuqhQAAAB0p1S92BVPULqKyRTISzucJGoyznyAoTsfJEryLEheRgqKMlicAVSWa41Ta2LW9nyM2MPJ/lHQetRxWc146zakBwg5S2Byq+reZ/KiqEKPIU2JqxbW2itYRHAgVB8yfM+ZpZZeFuBBxSeXl76j7xpjiHwp1f+lTxRrGuFHvPU1BBGkPiDynifp5D3VNiupaAExXYrq6gBMV2KWuoCxuK7FOxVHVLw20aRwr3l1KeGJB1PmfICga2RajdyNMLGwIN24yzdIl/EfXyFXdPtIrK3EMWSebMdyx6knzqpYWwsIu7Dd5eTHjlkPU+fu8hVTtVrkOgaYXJDXD7Rrncnzpxi5tJA34QN7d9o1sIDZWz/ANoceIg+yK8W1jU/GUU8R6+pqXXtallkllkctM5yWNArSIuxllPqa9XHjWONGkY1pE0SneWY59P5VxYyOT/9BXAtcSBUGw5DyFNuDiQW0J8Z3ZvIVdl0dH9o5C8hzNWAoAro4xGgVdgKdg0rL4kTA0CM/fapz2BwKO3h7m0kkPlgVmNNy10rHq5FWnqzOfaQeWngZpwTanBaiy6IZdkB82ApnI1LfjgtuIdGBqNx4s+e9Fg0MNdTuHNIRinYqEDdKdmoZFOOJeYro5Qw9aBE4amszQniTdeq0lKDkYosCzbzhwCpq2eGWMo/I0AkLW0wZPZNFLS4EoBB94oY0/DD/YvtDP2Z1gFyWtZPDKv4l8/eK9zg1CNo4ry3cSW0oBJHl5187SxiePH3xuprcfRl2iMbHSL1sRsT3RbofKubNjUlyRnkhWz1HU4pLWT9p6eC4x9vCv8Aer5j+If8qI2lxFd20c9u4eKQcSsKH6PcmKU2cp9YyfLyqrJnQNUB2Gl3kmCP8CU9f8rfka4WvBn+jQUlLXVIhK6lpKAOrq6upgdSUtdQMSurq6gYP12VotLnMf7xxwLjzO1WbOAW1pDCo2jUL8hVDUyZ9T0+1HIMZnHovL88UVpvoQh5U0inmm0DQ2up1JQVZT1W6Wx064uX5RoSPU9Kp9nbJrPSIhL+/lzNKfNm3NQa9/bdSsNMXdWbv5gPwLyHxOKONyNV0gRhe3L5ubZPJCfmaZ2CTj1aR/wxmo+2jBtVCn7sYFXvo9j+1u5MdAK0eoHQ9YzR9pX7vQr1v/DIrx9xivVe20nd9nrj+PC/nXlUm/SjF0GDohkxnAodqDsyrBHtJKcZ8h1NEJCqqS22OvlSdnrBtQvDccJKseFPRa3TrZrL6L/Z3RTcPGgU92uwr0NNGt7ewIKDOKsaHpqWduvh3qfWJO7snPpWMptszbt6PHO0cax3zhMAZoMw3zRPWpTLfOfWhxwSc/lW66Lobg+dX9PGCp8yKo45bVftBgJ76bEe0ahvpEP+7X9K8tm2vJPLjP616leb6LD/ALtf0ryu7OL6Xy46ww+THF5LT8XEwGMZph4znPD866Tg7x8lufTNMYp5tj41sajJuPh+786axcZJ4fzpspQKcFiT76qanKkNlKw4+MjA3PM1SJZBpfHPLcXXhy7cIz5CmWRefUbqfK4T7NaeWisNLUO2GVM7kjJqpp0jLaqsUDu7DiZmyq5P61ZmXzp0t0xk71EUnAypOaiubWOKQg3iq+chUQlvkDV2SIpbQ/Xbzu0YZCR+AfPmaY11p9nbSG3kiD8J3G5J99SmJg7TLa7uDNJC/dozY43zk49KvNo3eDM95NJ/DjA+Wadp2oWcFlDGZxxBctseZ51OdWsh/ff+k/0ptuxUiNNMSMBBPIo6BVAFcdNXO883yFc2rWZdSJSeefCf6VzatZ/4jH/gNK2FIT9nR9ZpT8qry6NBJKWM0wz0GKlOrWg5M/8AoNNbV7b/AMT/AEU02KkDn0+L9rLEryMkUZdskZz0ommnwlFbil3GfaH9KF2OoQ/Wbyd1kJkPCuF6Crq6xAiKCk2w/CP61UrJVFk6dB1Mv+r/AJUo063A27z/AFf8qpnWoQciOY/Af1pTrcP+FL+X9aVMei/DbxQKwQHffdqnU7b7bUHbW4cbQy/lUV1rifVnCQuGK4BJFHFhaKMknfXtxNkAM3CPcKIwE90viA2oUpHdRhIz4Vwc43NE7U5iUmPp6VTEiyM/jpSMOvjH5VPp9nLe3KQW0JaRzgDatPN2C1SKNZEjjkbmUBGaiU4x7ZVpGXXn+8/SjXZ6bT4bhm1IF0x4QMVe7MdmJbvVmg1GBoUj3YMAM0e7T9jYYLf6zpiexu0fmKzlljfEfNXQ3TtVkluoV061SGyDgMSNyK0lzcozKqkqudz1IrH9n7q5m4YYbfwIwDH0rYCy7x/s2AHrWE6TN0oLbLU18RGFtl2HXFW452a1DgeP1qra29xbnkroeYoiFCrg1g6OefFaRFFOSv2gAb0pGuC2QiE0k/dlhwkZ64pzSLF4QN6RFLtIhVTIzHYU+JZOE8GAPWmpKRLxHYHnUj3AxhRvTKd9EUcTd6RIdzTXBDEHpUoikY8ROD51HKGVyGOTTRSdsZgnkcVXnuJUbAyCPlU+ADkbGoZ2k4DkgDoaaNIrZTmmeU+M5PuqLNIzEnJO9NJrRHWo10O4jjANJmmk0hNMdHPkjAOKjEC5BzT81Ks8fdcLRjPnmntDdrovWM44REq5x1FdeXhjJRBhvOhaysvsMVpGcucscnzqeOzP2VythixGY+8d+Jj51BqkqFQoOWocJGHJiB76aWJOSaFHdgsVS5F6zuYoFOVJY0SglMqcXCVqnp1und94wDE9KsXLyRKDGARyIqJU2Y5KcqQ6aHjVuA8LHqOtZK+0uANOWi+1Ybk1sUOUBPM0K1mPJDEbHY1WOVMeJ74sCdmuzmnz2TSzqZHLHrjFFlS7srlYAwNoR4SOa1W0yRdP4xECVc5IJopHdC624MAVUm730DxuLt9Fu32XG+fM1I4ytQgk+yK4S74PPyrKjOvonX2Rk12c7U0yAJkg1GrMTkKcUhUSFMDwmmEANuTTzMB7SkYoZPdC5lKWsiAg7hqaViCyEYpds1Vg4wFUjPrVoCkITB89qWu60tACVHKhdcA4qQkKMk4pcbUBZWjtI0ByM5qwNgAOVLXYobBu+x2RwjA3FNYk86k7l8CoyMHB50iVQwRqDnhGfOnUtPRGxxAfOmO6GKVXmua5nJNKfG4GADVlVVRgYpEtpHi30cQM30f9mTyB0y1/+Eta0Ke54WONsUB+jKIN9G3ZiVncD9l2wAxsfslrVwWLTpxEhR0zXTy0dykuKK1jI4lRgoPTPrR26lBs3EoxxDG3SgPD3VxImQeoIqxbyHvR37lkzyNTJXsUo8i33ovLBe7cFyMMORyOdUtPjaCV5vq5dV2GTyNXF7vvpo2TwN9opG3vq3CVEYEZytTyolOlRPYO0sAMkfiPP0ojCqqMKMUNQHI2NX43RE3ZQ3lms5bOfIiao5iNgwB8s0kM4lzgEYqrecbHxcIA5YO9SkRGO6ZZSZCeDkfI1E1viXY4Q1TVuHcHerEYRoy7yE4qqo0cePQ/6vgkEgg8jSiExqSrEkdMU+CZCuADtUhkXhyuDnypbIcpLshjQyHiIFTNIq7Z3p+yjNRuExxGlZN2xiq7NljhamqGGYyMRjYdamPKgJX5GNgHZOImqeoW8rrmGNBjmRzqyTvkv8BSq5c4AYetNaGrW0UrEyA8MxJHLGaJqqquF2FRiPfJprsF2JpPYSfJk2NtiAarSQyKrd2QXPrinQwtG5YyuwPRqbcvLGMx4LNsKBLvQIm44LrinQv5ht81iO1+lxNEwVCtnktEx3Nsx6f5D+Vekw/bTL9YIaRR7ONhUN9piXR4URVQ7Nnka1hPizVtPUjwrS9RutD1DxAjgOGQ+VeudkNbXVOIxMirgYDHcn3eVYrtx2Y/Z4Xu2V4M/ZydY/4G/h8j0rJaVqVzo96eFnjwcMPKuqUVljaIWteD6LkcRrk/lXn30iaP9bH7SsUInjH2gUbsB194o52e1qC5sVuIpjJxe1GTupolPf20sB4cKx5gjnXLG4SLUDzTsp2pNo62l8fsG5N+H1Hp5ivREYMFZSGUjII5GvN+1GjW9pcNcKrfUJm3Ke1A3mPT0p2g6/c9nrhNP1jMlk+8M67gA9Qeo9OlbziprlEuLcdM9HmmklKhQq8PXnmpYoJXXPh+HKh4uo5QpikIUjKsORqVLy7D8EcnEPdtXO0aOLS+JYuLYtGOM8PltkGo+PugEKkn05VKlzIB/aWDA+Q5Uy5vbK2iM91KIIhy4iBmjZNtdj4hK7B1hZcdRRN7yOJUXd5nHhjXdj/y9aF2l7LqcBXSvsEzvLMpLY8wv6ZojY2UNmCEJeVvbkc5dz6n+VTL9nNklyJEiklPFckY6RLyHvPWrNdiurMyOrqZcTRW8LSzOscajJZjgChmbrVvZ47WxPXlJKPT8I/OmkBJdX7yzNa6aqyzjZ5D7EXvPU+lSWGnpas0kjNNcv7cz8z6DyHpVq2t4rWFYoI1jjXkBTXmJYpCONxzPRffTvwgOmKRrljueQHM1B3TyHMwwvRB/OrEUPC3GzcUnVj/ACqbFF0UpURquw6U+lpMZpCuxa7FJyO9LQI7FJXV1AHV1dXMQoJJAA3JNICG8uY7S3eaY4RR7yfQetDYC0CtfXg/tUwwkZ/u16D+tM75byb65L/skJ+wX/Eb8Xu8qHz3pnmaeQ+Bdl8q0jHkaKJdu9Ti020lu7lxkDJ/pXh/artFPq2oSXEz+iL0UUU7ddojezNDC/2KHA9T51hUDXEuDnhG5r0cWNY1b7KjHdk0MZuG4myR90eZqWXJZYYxnfp1NSswghyNidl9BRPQ7DCG4nXxH2QegqnLybKJSugNL08tjinfZR1JqvYWjRIXl3mfdjV61iOq6nJeMM20J7uEeZ6mi4s8nflUuVaLUb2BxCamjtixyRtRT6sq1DPIkWVHMDJouyqSMn2qnCNFbIeuTQjTl4Xtyermk1a4+sam7524sCp4l7trcHowrWWlRzL5SbNGI/DtThHtuKQTL3xjB3xmn8e2KzN9FPUkzaSD0plqvf2kbdcVZuMPGy+lVNDkzCUPNGIp+BPseYip3pDCzg8AOaJcKtzxT4wq7AUrHxQCAOcGq9xCYz3icutHLu1DNxoPeKgSAMCrDIOxp8iXAGwvxj1FSVDNE1pc4YbDf3irvBxIGG6nlRZPHwVpFEiFW61Shke3mIJwRzHnRIoRVO+hLrxqPGv5imn4JaC9pMJFDA86sypJBKk6BldcE9PjWcsLgxsDnwnnWit5zJgsxbI60noqO1R652Z1kaxpEU3EBd2+A3mfWtnwQa1pLxTqGjlUo48jXgnZ7UX0XVUkUn6vJsw9K9X7O6ukN8Iy47mbkf0NcWXHW0Yzg0FuzN3NwT6bfk/XbIhCxO8sf3X+I2PqKOUA7TI1hd2utQg/YHu7kD70Lc8+470eRldFZSCpGQR1FYP7M39i11dXUhHEUlLXUDErq6uoAQ11cahu5hb20szckUtQMH6d/aNXvrn7seIEPu3P8qLUP0OEw6ZDx+3JmVve29EKb7ASkpTSUhiUhwASdgKdQrtHcNFprRQn7e4Ihj97bU0rYIq9nlN3d32pvnEz91Fn/DX+pzRqTZGxUdjbJZ2cNvEPDGoUVJL7FOTtlI847Utx61ceQwv5VoOwMfDZXD45uBWZ1tuPVbpv4yK2PYuMJowI+85NaT1E3m/hRV+kJ+HRo0z7UorzRs5r0D6R3PdWcQ6sWrATDgRnfwqBkmqx/iXh1Er/AFOXU7tLKFgpccUjnkqjnXpXZnRI7OFTxI2Btwg0B7C6ZILZ7u4ThkuyGUHpGOVb+3iEMQVRiicvCE5WSAYGByoN2lZTaMrTpFkc2oyThSawvbIS3RKRvEB/E2KiPYoq2ZK50m3klZzqluP+E1AdGts/9qW+P8hrjos++ZLff+L/AJU39jS7fbW+P8x/pW6ZrQ8aLbj/APGUP+g/1qxHp1shH9vQ48k/51H+zWG3fwf+r+lNNgQwJuYefk39KdknpU+ohtLij+qXYUIAHMex251hbi3t3upH+sEEtnhKbj861svabT/2XFAzOGRApYrtsKwNzdQNdSyQS9/xNnEanb3nGKzxpmUFRfbiEj8JUjPWopnZFLOyKo6naq0guZpGzwwKcezlm5fKmCzgG8iySv8Aikya2RoMlvDICLaMzHzUEKPiaHX63V3eW9rM6ICeMiPJwB60YdU4DhCBjyNC7HhuL+5n4WKD7NMfnVJkMi1G1RXt4EUF5X3Y5LYHqaJkOHABUbbbVRhjFxq8snCxSFeAY86uEIH9hiceVNvwJFDWZu9uUQnIjUL8etC7k+EL+IgUXu7ZSe8jjIYcxihb8LXSAI3hBJ2oRMkNOc00nfep0xjPdn5V2AP7s/KnZNEIrhinSMBw4jO58qXY8k/KnZNDPfimzMEjZvIU9iMewflVS7OV4Au7MBTQmiS1AW3UE786kJHXFNwVwBGfypH5HwUWKhcjpS0gG3sU9QdvBRYUNwKilAZ40HU5NTtkOPD0qO3y9y78OQPCKaYUTDYbtgGilmPsF8ePlVSOFn2EZNErWJkjAMRGPOpspIs2VzLaTpNBMUkXkRivYexcup3ViLnUrhZEceAADPxrIdl+yFvqNot3dXAEZ+4vOtBJoGr6XH/1HqBaEbiGXl8DXLmlGWhSp6Ng8atvjfzrN3OvSW2qy2E0SyLjZgenrWfuLztQxMcpEfqCKh07R9QjuWubtu8zuTxZJrOONLtmmPDu5dGms7VAxaPCgnPhogpKsBg+8VQ09JAgKEDPnRDDEe0Aalm0q6LEE7hgH9mrowR5ihi+pzUvetw8IOBUNHPOFvRNcBBgjHFTbkhlVuRpsBAlGasTLxRnAyaOifxaRFbID4jvVhkVuYFQ2oIQltgKS4kRlxx4PoaXbFK3IllcImxGfKqTsWOTzpmTnJOT511UkaxhxFqpet4cFc1azttvUQuokbEyEHpkVSNI2tpA0RuWA4SM8s0ssEsW7oQPOiE1/A6kcJPlgcqauoxtBwTKSeVO2aqeT6BRNITtSuRxHh5dKjNaI6UcTXZprkhSQMmmRux2dcGmUTK3CwNTIRcOqYVB1IqtvzrlIzvvSJasNSWsLWxWLhyBzBoOwIJHWn99wbRjhzsd6jGWOQCTSSoiEXHthbTbeRAJGbC/hq28sY8LMCT0rP3VzO9u6F2XwkbbUB7DahNm4S9Rz3MhALcyKXt2mzKWJt2z0EDAAoLqkjmfgZvCOQqW71MFOGEEE9TQ+J1adWmJIzvSjFrY8WNr5Mu29vHcw4wUkHI+dELC0aCPLDJ9Kgub+BIk7jDOOlVv2vMr5VeEdRRUmQ1kmtBWe4jhI4/CDUblJBxxMpccqEX15Jc4DpwjmKqqxHIkUKBUcGrNMhdo/GAG8qenEFwxGaEWF+UISY5XzolcySCAtbAM/QGpcaMZwcXRJMxSJmVeMgez50Bs7GO5kkuGiUTE+znGKORSTdzxyIOPHsio7WES3DSpEUZufFtQnRF0PtojFEFIAPpU4p5j4cZ3PkKkXu8YKEH3VDZDkV3J4TwjJqF47hk41PLmBV/ukLbAgVIqBeVFi9yuijGveIGOfiKnaICPOd6sOMoaqb4xSuxKTkNpVBLbc67FPjJVthk0ymx/DKBswNL3XEAWO/WpFJPMYpGXiPM/CpsysqsAr4bkKkNwANlNPkh4mzn30vcpjlTsrlF9lckyPsMGn/V26kVLGix5wafkHkaLBz+jzH6KXZPo57NQCKNuPSLSRcn/AMFAa2SupRUAXIGMCsB2Au2g+jvsdIgCiPSrQMSOYMKZreW7AqXwAW54rVrR1qNIpX9oSVljVQQcEDyNVCGRsEYYUXvInmh4EOAdjQ+S2bu0KMWY7EHnmmmXFlTUL2ZVjl4gCp4SQPunnV6wvk7oIFw461FJps0kZB4NxjBqLTynCBcZDIeFgPMU9UN0GDeFvbBYj8IqRWEqBvZB5AjeutZIpmKxlsjoFq2LXwls7jlxbVm3RjKSjoprIQdiQRVqF+8DcUfGfdSJZu7E8ShfnVpIWjgZY2HGeR8qTaInOPgqi1ZwSF4fQmmTx9yuW4cdaoM2pC/RGZg3LP3SKKNBMzHiAYHmTTeh212ysrGRD3PhBHPNU9Ma4inkwGaNT4qIiBjxEYwvSkVZI0PAhwfKiyrT0WFuo5FyGGaUuXGFGxoXb2RimaSQg5OQoOwq8BI/7o8J8x0pNLwQ4JdFpAIE8ZG9JJOq7D3b0L1fT5ryKBJb2SJFcMeEbt6VYSKcZj7wGHHtMMmil2Qle2WxEzsGJA91TAYXO5qksndIVEmV82plndYllV5gUG4JpUDi2rL5YDntTZYxIuDUAu4nGVPH6AVyXPfE9yPCvtE7UULiyaNSNnlLHyIxTiwzg/Oh9i4muW72RuIHwjO1Pv7V+9WWPLqDupNFD406ZPMzRsHiQHOzHFLNKvdtiTDAfd505ZW4ACgRsbAnnVR1D8TG0y+dznahAl9gW/b6yGjl4niIxwvvkV5z2n7PiBgQcW52jmP92fwv/D5HpXqEwljIaQcUZ5DO1DrmKOdHjkQNG4wVbfIraE3FnTxUlR5Po+pXfZ/Ue7mVlXk8bdR/89a9OsruK9tknt34kb8j5Vj+0mjLBD3U5ZrHlDPza2P4W80/SgehatddndRNvdAmEkcS5yCOjA1vJLIrXZMW8bp9Hp88STxPFKoZHGCDWUjgit520PV17yzlObaRuan8Oelau1niuoEmgcPG4yCKpa7piapZNGfDKu8bdQayi60zaSvaAdubzss/BMXu9HY7OBlofePKj2oa/BYaR9ehcTQnHD3Z9onpmhGj67ELWa01pgt1B4WDDPej0HU0El0GKTV4lvFlsrK7J7qNH5N0z0FXSb+Rm3S+IYtvpAuLmPu4NMaSctgBCTt8KmtTcaqkatp86asJcyXEy+FBnzPp0q92b0BNCE/dTPIZSPEygEAdNqOKSDnJzUSlFfihKDa+TCljAbeFY04ivMnPM+dErUR8Y2YP60Jt7ySGPwxLk/exRXTpHeHilx555bVzyMsiaRdqlf6hHaFY1Vprl/YhT2j6+g9arPfzX0jQ6VjgBw90wyi+i/iP5VbsbGKzDMnE8r+3K5yzn1P8qmq7OUrQafJPMtzqjLJKu6Qr+7j/AKn1NE2YIpZiAB1NQ3FysTCNQZJm5Rrz958hTYoGZhJdEO/MIPZX+vvoAXL3HLMcXnyLf0qZI1RQqAACn1wpDOArqWuoEN260tIwpASKdDHYpK7NdQAldS0lAHUL1NxdObbi4bdd52HUfhHvqfU7s28XBFgzvsueQ9TWU1vWrbS7Bnkc90nX70jn+ZqoQcnRcYvstard9/KltF4VxyH3EFY3ttrIs7f6pbkB2GDj7o8qJyXpsNJkv7wcM8o4ih5r5L8K8q1jUHu7iWaQksxzXdhgvy8G6VaBtzK08wVdyTRGC3EShBz5sabolk0nFcOPRat36tFHwoMySHhFauVs0jGlYzTbU6jqOcHuIudGe0ErQWSW1v8A7Rcnukx0HU/Kr2jWA0+wRD+8Pib30KWUXmuzXLYMdsO6j9/U1mpX8i6rQSsreOztIoIwAEXFdPdRQLl2AoTrGtR2aEAgyHkKx91qklzIWkc1cYatkymlpGzutZgjRmRst0oJqF8YtPkmY+OXlWeFyZJVQHmabr96GZIEbwoN6uK2RKerBGoXBSIsD4iQB76OXD8MaN/lNZK9k4pIxnZcvWivpf7FEw8hVS7MYPTCMl7warHk7EAUXE4xzrFXs5NzG4P3RRuG77yFGzuRUtFRnsK/WAZwmelUtMl7rU7iInmeIUNN2ReZ6CkuLjudbhcHZ1oobn5NHc3ZifY1Pa3izrsfEOYrOanc4cHPMVThvmhkVlPKlQ/cpm5SXPOpURScigkV4skKzI3vq/aXQkAYGpaNlJMl1e07617xB4o9/hQ/SpFLG3k5N7Jo7bTpIShI36VnNVhNnfELsvtIfSkvoH9hKW3KMVIqs8JBO21GLFk1KxVwR3g2PvqNrffBpWOkzKXNubefYeBtxVywuCjBW3Borf2HfW5AHiG4oIiEHB2NWpWZuFPRokAmj4SefI0b0TUXCLE5IeI4FZfT5yGCNRRiYpUnXOOTVDXgqrPd+z95FrOjGKcBzw8DqeoxS9miYLeXTpDl7Nu7XPWPmp+W3wrCdhdZFpfojt9lJ4TW71WVNP1W0vWOIbgi3kbG2T7JPx2+NcUo8XRyTjxdBiupaSszM6upaSgDjSUtJQMQ0L1897DBaKcNcShD/lG5/KihoWP7Tr7HmlrHgf5m/wCVNDCYAAAGwFLXV1IDqQ0tIaBiUDI+v9pAOcFgmfQyNy+Qorf3KWdnNcSHwxqWql2ftmg05ZJh/aLgmaT3np8BiqWlYBOop9lqQ1BePwQO3kpP5UikeZXoL3MzEc3J/Ot/2Xj7vRLYeYJ/OvPpZCzEgczXpWkLwaZbLj7grTJ0a5ekZLt+3FeW6fhQn86wl2pu7uO0X2Bhpfd0Fav6QboQ6pI7HaOMDHr5UE7N2hedGl3llbif09K0hqNmkPxSPS9OtxFa2qgAcMQFXa5V4VUeQApsriNCxrIgq6lcCCBt96wd/M80zMSPzotr993kvDkhcbnesxLcw8REfHM/4Y8mtIo3hGkSESczw/nUALhM5UAVE4upOUfcKerZZvlyqNbKN1zN3sx/jzj5VZTEkvF4isZEr/hjBaoZDdycO0cAJ6+Jv6Vb7lUACRkD0GKimAyMo3Pyp2SVzZeLMzmZv4+Xy5UvCw2BUDyAqVguPYb5VC4XpG3yp2Ki8S+fCV5Dp6U0hztxAfCkwpxlCfCOlNITfEbfKlZJW1KV7e0mkLAALtt1qrZo1npYZmAPCXbbrzqPV8TTW9qqkFm4mHoK7WSpgigjjIeZgo91aIhjtGWRLMOxHFMxc7edXWU8exGcc8UiRIqhREQqjHKlZVLACI4x5Umw6I8PxY4xn3VRtYFlubqRiNmCDbyq3KBGrP3Z2Gc4FV9MH9jQtGSXy5OB1p2SyVLZOHmPlXG1XlkfKnqBw7RdfSkceUeD8KAK0trHtuOflSi2QH2h8hUsnJfByI8qRv8Ad/pTEQPAnQjHwoa8SyawiA+GNeIn1oqdv7sflQ7S/tbi6n4ActwjlyFUmSy8bdPxD8qjkhj4DuOXpVoZx+7H5UxxkH7MflSsCJIYzjxDl6U9YI+rb/CnrkAeAfMVIA3+GPnRYUVpYoo1Zy3sqT0qfQrBJI4g5ILniYjfGagv4Zrh4LaFMvM3DwjqK3ejdldbiEc8MKREAYDEcqUpKK2LSezY6Fpmh2djGbeFZmYbuVySaMSaXYTwHis4wCOXDVTTrOe2tx38eJPvEY5/CpW1UtIYBBKMc3IwK4XbehcLfxBOm2Mml308kWFtX27kD86NGclANwKjLDmab3gY4RS59BTezfivoiuk75weJQAMU1YAuCrOfcacYtyXhZSanjUKNhigvlqkKAB7IwaXO+K7oTTGYIhc5oJokG22KUZB51VMjSxZjYA+VKrSRxFpGzSoOJbzShmBzk/Oh4vhncbUy6vNgIjjzNOh+03oI3EzHfiwvUVUl4JUyjBSOuapJdyDPEeLPnULyFmJ5U1GjSOGi6lyYm4WPF61aS4jcbMAfI0FLYBJqqJZe89klc1XGzR4UzSu5QZVQR76ZGEvMgKduZPSmW1vEIgZ58Ej2QanitYjlrWZgfMcqh6OdtIoXdo8EigeIMdsVYXS/suKWQBscqdcR3geMF1IB2apprQzQeKYl/PO1FjeR0tlGxsu/Zix+zBxt1qzNpSHJic56A0+B54EVFiV1HPhNSzTz92TFAcjzobdkynPlpgGeF4XKSDBqPFFRYy3MRlmc8eNhU2nWiRxGSYDi9elXyo3edJfsDpBK7KqoctyztmkmhkhbhlQq1RdsdVuIdMuDaFMpurcO491Psry8vtOtJ7uNgWUHdcZNNXVjjOT2yxZ2bXByfCo60VSOK1UKEJJ9OdVe41BCJE4QMZ4RUMmpXHsSqvEpzkjBFS7kZy5ZHp6H3l5CVZBD4vUYobawCabhQKpPM1Z1O7S6KMEKOOZ86DXOqW9ldRRSScMshwtXGLrRtjjUfpmmXS4sbsSaiudMVYmaJjkdDU2kXMDQkXEuHHUmsrqXame67RHTtKKm0iH20n8hUxjJujFPJz4mlsWg7jiaHdebYqneXEUl0JEUcI6UthqHcL3cihozVa6ZJJ2MIwp6U0tmsYVJ2XL28iuIVVU4WHWqIFNpQapKjWMVFUjnd1ZeBMjqaO6QsnAzOfAeVCIInlcKgJJovFYyRxcTTlQOgqZ10YZmqqxdTuru24XhhDxA+LzNXdOufrMQd42iz0bnQyC7CXGJXLxDzozA63ALKDjpWUlSOTJHitj41Cy8QbPxqwCDyqiLd4pTI7Fl8h0q0oBOUfHpUMwkrJa7NVXLq2CTTSzeZpUChZO8uDhRmow5Z8AAZpyMiIPOmhi8gwMUxpUc8ZAznNSQ44aWZcoT1rocBNqBN2iQ0xs4IUbmu71c4zT6RG0RNJ3ajj5+lIjmRSRtXTSKARzNQxS8GxG1M0UbRE2QSCc0mT50+UhnJFMqjZdGB+jC2eT6NOzAYpwvpFqPEMn9yta3T3aSyQuuJE8De8bVlvotugPo37KKFYldJtMjGf7lK0NjcKdUmiCngmHGP8AMOf5VfaNN0mEBUCgJcuMe0OIfzq2cA4GPjVW8HDwSjHgOT7utSNMSWUrjul4z1AqpHG31uSOUBEmHGFG5yOe9XnLcP2eM1V1FZRbrMr4eI8Wwzt1ppjLUEQg4hGSAalaRnZFcsR5+VRQ57tcnO3PzqSpE1YRiRI1BEhx76RbmMMRk++qFOU48qVGXtfZPPccRHByHWmyXEjdcCojjOwpSxOAeQoGoJE8AYKSTgGpkhUEcWTnpmqSjLAZ5mrvdHvFHG3KkyJ68iSwIWG/Dnyp6Qqi7c/OobnZ1CsxemNNJkDi3HSglJtdizhs5Zcr0zUtqvgyevSo0kLeF8kmpbcOrENyFA5dUddd2sR4woXrkUCu9UsdOtxNgTqxwBEOMk+VaCeREjZpB4R59arW4szGe4RI8nJAUDemn9ijJpEGjv3tt3sqJF3niEeclR61ZlsY3yUYpn8J51S1K0SEd5G2M9KqrfzRxGNWwvn1p1e0WoOW4s7uWgnwWKYOzGppbydvCGDBTzUVTkleYgyMWI5U6Kd41KqRwnmMU6NuN9hi2uI50y3DxKN81J30brlWUpyJ8qqRQQPblwCp4fa4sV1nHHLbcEU3BId29amjBxXY+doj9nD3Tn8LGg1yrd6ylQG8hVi/h7iULkk8+I9aigMYcmZS22w9apG8FStEN3Y4hAlAcSDdSMjHrXnfans79XjJRWaxG6OBlrY+Xqn6V6ab2QyewpAHCFxyqkxJLcQznmCK0hNxL4uSqR5V2a1ybQ7v6teb2r788jH4lNa+XtLHc3IstEj+u3TD2uUaepNUO1XZaN4ZJrBPs93aAfdPUp/TlWV7EX50/XYlJIjlPdv6g8vzrZ1NckZXKD4s0uuaDf2c0OtLdfWbhCDMeHAiPTA/D0ohrbnWezSXFupWdJVBXrG/lW1s7mKO2mhnhEqSDBHQjyrzfX0uOzt+skSv9UkcFFO6uBuFPqOh8qzjJydMUuUG/o23Yy7/AG1p8feMVZPDKP4hWg1Hu4AII4ASRsay/Zi3OmajZgycMGpx96rKcqJeZX4j9K1d/qSi4+q2EIu74cx92L1dunu51jP8tGTy7THiaCwsVe9YLxbBSMlj5AdTVWKxn1JzJdI1rZHcWwOHk/znoPSrdjpghl+t3sn1m9x+8YYVB5KOg/OpJtUtkkEULi4uDyihIZvj5D1NR/Rk5NlxESGIIiqkajAAGABVdpZLjw2vhTrKR/8AsjrXRwyzYa8Ix0iU+Ee89T+VW8Y5UhEVvbxwKQgPE27MxyzH1NTV1dSEdXCupRQB1dXV1ACGuxS11ADcYrqX312KLGJUF5cJbRFmO+NqllkWJC7nAFYvtLqLS3H1ZT/vcdPJf61cI8mVCPJkV5qBlMs8jcKkcz0Wsv8AUptZ1q1uL5WS0h+2hgbqOjt7+g8qOaZaDVZpJ7gY0i0y0rZx3zjfhHoOtCtY1NrTS7i+c4uLtsop+6v3R8BXUlXwXbOlNXSMz2+1g3N39Uhb7OLY46msta2b3UyRr1O/oKtQW73crSEFt9z5mtHo+ni3QsR4251tKSiuKNYw8skgtEhgVFGFUUP0qAX2rvMw+wt+XqaKa1MLXT34f3jDhUetBL7U4tD0tLaIg3TDif0JqUm1SLbS2wnrmrRWsMoVh3gUnFZRtRGnaWpY5kfxH1JrNSX73d6BIxYs2Sc1V1i+7+ZjnwJsBWqilowlk1Yy9v3nmZ5GJJOar/WfWhhlLMTnnSu5RBnmatnNdhWzufty55KM1VuJJpnBihlmlmbwpGvEcVWt2Zl4F5seGvWfo20hIrd7+RQXY93GcclHP5msM2b2o2uzs9JgWefGXR5TPpGsdzNcPpN7HCijid0wFHnRW4bi0ph1TB+Fe2durYx9j9QZvaaBj7q8Qix3AR/ZdeE/Gl6fNLKuUjT1WDHidY+gY8ueDJ6YqxbXhROHJoe6sshRsgg4NdwkGuizztoIrcFnzXancHitZM7g4qihI60+9bitV81YUBegjfXPeRIwNU45iw57ioFkLwAdRTUyrDPI7UBd7DOnXxTMTHwty9DV+01JoJeZI6is6CcgjmKleUnDg79aktSo051ZkkDo3qN6JXt0up6SJ1x30JyR6daxIl4kyD7xVnTtQa2lO/gcYYUFqddmo7L6qLXUFidvspdvTPSt68KyjI514sZuGRgpOUbY+nSvUuy2qi/0yJy32ijhf3is5rya4p7oJNbEDlWe1ay7m57wDCP+tayGeN5O6Zhx8wPOmX9otxAyEcxsfI1CdG3Zk5LZljEy5wPa/rROzcTwFH3OMGp9OQMhjkHiXwsDVNo2sb0xnPBzU+a/8qdhQQ0+VomCkkMpxmvX9NmHaDsjJESDOEKZ5kMORryB18SyLyPOtz9HOo/V9QNvI2I5hgZ/F0rLKrVmOaFq0b7Q7o3uk207nMhTEn+cbN+YNXqC6Lm11XUrFuELxi4jA/C3P8x+dGxXK+zjYldS4rjSEJXGurqYDWIVSx5AZNDdEUNby3JHiuJGkz6ch+QqPtLqMVjYFGfEsxEaKOe+2cUTt4lhgjjQYVFCj5U/BQ+urq6kB1IaWkYgKSTgDegYG1n+2Xtppy7ozd9N/kXp8TReheir9YlutQbfv24Yz5Iuw/PNFKb+gEofrT8FhOeWIzRCg3aZ+DTbj1TH50LsuPZgACzqPMgV6nbLwW8S+SgflXl9qVN7AHYBeMZJOK2mv68lnY8Nirz3cp7qAKpwXPLetJptpGmVdHn/AGuf9o9rLpBvBbsOLyLY2FGeydrm4DnzrOJa3MLyJK6iTjPeP7RZs7mtn2QiVSMks3mTVydKjVKomsdgoyazeu6hKQY4WVPU7n5UR166+rRqu+WHSsXcyCRyWVj8DUIIRvZWlte9mDTuZj/GTj5cqfwFBhAijyAwKVghZfCw+FNZV/AflVmojBse0vyqAcZXBK8/KpGVMewflUA4QDmM8/KmIcwf8S/Kq0wcjdl5+VTtwkewflVeUADaPr5UxEbpJ+JflTeBiN3HyqVuH/D/ACprKo5R7e6mIeyNkEOB4R0qM8X4x8qmdQyrhCfCOlUr2RYLeSRo/ZHkKaJKFvm41K5n4hwxju1OPnTEJuNYzx+G3TnjqansIxbaYHkj3ILsTjrUOjIRatK8fE0zFunLpV2SFFJ4fbHyprZ4h9qPkKVcAYMW/wAKa+7r9n+lITKOquRaMofJchNsdatIoRFQSDAAGNqq3njvbWIR4AJkI26Vazv+6/SmSNB2I70Df0phI6y/pTgdj9n19KYxPIxj5igBkhGxMvX0prMCd5P0rpmOPYA38xTSWztGPmKYiC8mEVtK/eclPlUGkIIrRBx4LDiO45mm6wWaKKEKA0rgfCryrwtwhBgADnT8E+SRSv8AifmKU4x+8/MVd0v6v9aT66p7jPi4TXpOiR9k5ZFEKp3n/i1nKfHwJujypQABlyNvOnjAP7w/Ovc7vs9pV9Dg2sW42dBvXnDdmmHagaYz8MROQ3UipjmUhRmmZOCC9XVkuIo5gkS+FwM7mt72Q1nWL277gXKMi+0JR09KONoH7Htj9SupBCp4nWQZFTxGyEazwBGc9Yhz+VTLIpLotJSQdLxooMl0qg88nFDNQu7buibeYPwncg5qYxRXUQE6AqeamobfTobOKX6pASnMqN6xSSKiuLuwVBqYmkxAxbHPyora6gsRyUx54oGktzcXLiK17iIHkRg1ajgLyhZWKg8qtpHW4xlHYe+tpc7ofhTSPKq1lm1kK93xg8jU7uxJ4QM+Waijn48XS6EaJpGAEhXNT22nsMiZuNPKoHBZfaKmnRag0YId+MDrih34FJTaqIslqLeYhT4DyFRTEqpyvGPKnz3PfJmHDN69KokzmXDlh/lppfZcIt/kRzFHOAoQjpT4reOSPIcsfwip0txxcUmWbnxVIGiQnYKetOy3PwgXJC65PCQKh4xnHWrGsXUbRYWVk8yBQ21ZAnhYufM1a6N4NtbLRakz5Uw5xscVy8QHiOaZpQ/mcnmKJWWoLbxcBjz6ihXEK7OTtSasicFNUy9dXwmlBmYpDnkKlv8AWbSOyK2+X25DmKy2uX6QRcKsC1N0TUre4PdRx4fHiJ60+GrMnji2l9BfS+1ulxDgcTrITgnhJognaA3sgS1UxgnALDc0GNjaRyNP3Q4udVLDUIrvVRBDEQ5OMik4p7RLxJPlI9ChVo4gJpOI9SapXFrdOx4ZFMWc4JxUTPFZYzcNJL1Vtx/yqLUdajR444jknc7Eis0nejnjGV2ize2z3ESB7SM8LA44tiKmWEkJLc3CuinICLhRSNDLeW6GWRogwyRH/Wor22uGRBbhO7j5AbZNK/BK26uggxbhBiCnPntVdbWJ5HnlQO56HcCnqsklooLlJCNzjlTZ7lLVY0f2m2B/nSX6JSfSI5ILa9YHhUqmw4diaw/0jdmGa3j1PT/bt24nQnHh9K3TC1lDT8QHD99dsUJv9IsdecJcXFxLAm5jBKgn31pCXF2aRk1u9GN1vVfqehJKh+2lUKg9TSdl9M+p6eHmybibxuTWgt9C0vvnfUpYZVgYx28XHngHu6mmsACQvs9PdW3NNUjtxzU3oTpRfT0sUjDyTDvT0PSg557GkxvmpasuceSqzRyWttcp4WQHzBoJNH3cjJnODzqJASwCnBPrWhtdNtYIRNdyhuvPYVN8TBy9nt2ULC7S3jPgJY9cVZHfX2/GET8OaRtX0n6wLe3w8nLCjNEo7aHiVnVkbngVDdeDGWRd1soSacYsNFmQDcg1eiugkYYAqvuqGe5aO8WGNgYzz2qxcyRJF9phUNJ77Ibcq5D1ue9XPF4fOmmcJ4lBY56UkPdmJe7wUpZHWNCW5eQqCKXSJpC5wXGKZmo4phKg3b3Nzp9FAlQpOKdHJwkkCq9zL3KcZICjntTba6juVzExPntTrVj42rLbyl+dNzTa6kJJIcDg5FK0jNzNMpM5oCkLSUhOOdITTHRxNJXGu3oKMf8ARaF/+5r2S4QAx0izycf+ClaHVkkgiS4hVeOBg4IG5HX8qyf0V36N9HvZOJdguk2isSPKFK1U15bKSjye1tjFUkyuDaRZ4uMB8ghhkHzpGAdSrbgjFUdHmDK9q7YeA8PL7vMflRJkwCQwIpPQyvbMTEFb2k8J+FSFQwKtuDtUA+zu2G+JBke8f8qsZoYFewc9wY29uJihH6flVgHNVDiHUAdgs64/4h/yq4KGBx23pa4ClpAdSiurl3OBSEPjB7xSMVdRiDlmXB6CqyRArkyAAc6kjtyHJJ26HzpMxm0+xlzInfDgYcYprMFcMnM8wag03R2tdQubua5aeSbkCMBR6VcniRcs7YJp66QlJdCxycRBKZboRUjB2cDcKedRiSTgBVdhT0uQdn2NIlp9o64g71ApJwOnnUTQyscKqRgcjjOathgRnO1cM5JzkUrJUmisIBJh7kZYch0FVJLeykZuLw77EcqIzR94OEnC1BcQRzRGNSoYflTTKjIAzRiKQojcQHIimYOc5qxNbPGTjLKObYpqbKVKgt0rSzsUtEa8Rwq5OelPeOWBgWDI3Q0+1kEFwHdScdKNIYryJWkQY6AmpbInNxfWgHGPrEoEj4Y8mNWLq2t4YwAz95+LGRRNbGHhw6qQDtiul4bSId2ilBzGd6Vmby29ABGkikDgeLpxCouFpZcbZY86J3fDeOJIyRjoaalqpOeAE+Z5Cqs3U6VszmvxSWmi6pcyyNH3KkKMAq23L868mv4fqV7ZFQQ/crI22CDnNeqfSXHN+z4LGNwRd3EfCPUHcV5/2/Il7SmGPBFtCkZ4fQVviZzSk5bPXorYrbxSGRMSIGPoCM1mO3lsl1d6PYJdd2vjmMhIHCQNifStF9bt7bSbWAh572SFO7hj3bOBufIepoT2W0+XUu1l7c6rHFIbFFijQDKox3+JHnWS1seSVxozWn6hONNltdSvVtbcMZoJiuG7xeajHs591Fp+29pHpUVloEEsdzJw8bomSD94jO5PrVr6R9Ps7Zp7iaFSt7GVD43SVdwfiNqsfRvoVvp0pkljSW5aFJklIwVDc1qm4tcmc47TCuq6kYtLW4msxEBJPfcTBH81Dcz6cq2Wnafb6fD3dugBO7Njdj5mrddWLdgKKWm0oqQFrq6upCOrq6uoAWupKWgDq6urqAONITgb0tCe0GpQ2FnK87cMSLxPjmR0UepppW6GlYO7SayLSNTHhpXyIV/Vz6DpWQ02yudavzaWrFUG9xcH7gPPH8RqtAb/ALR6swgQCeXnn2bePp/89TXp+iaXBpFgltbgkDdnPN26k1u2sapdm7ftxpdmf7WiGw0e00ezAjjmIQqDjEY3Y/8Az515J2s1A6hqXdQ/uo/AoHU1se3mqD9p31wp3hUWsXv5sf0rCaDCLjU0LbhPGa1xLjHk+zXFDWzQ2NktraRx4HEBlj61bUgDyAqrql4sARRvJI3CooX2i1IWNgwz4yMVUY3Rs2DO0OsJ3xfOVjbwjzIrBajfPKXkkYszZJJqbV7l2jjLHkv5negNzKeBsnbFbr9HPkmLY3BaSVwdwOEe81FesRHgdaZpW9vxfiJNPukLSAeQovZkk+JXgjLsPKknJa4IHJRiiMMPBFk+81RgjLZf8RJo5DUAjoNq9zeIqLkjYe819CdmdOEUFtbAeCFBxep/+teUfRtp3fX6OVyqEufhy/OveNJt+5tgSPE+5rzPVz5T4ns+lj7WJy8sCfSNHxdktRx/gt+lfPk6H6kCPwg19HduI+97Lakv/gt+lfPrxZ0xG84wfyrf0r+Jj6hckgLeIHkjlUbSDf39aYYumKvxxFouA89nWpZLbO4FdXI4HAEmPHSo7kH6s4+NFHgPWoLiA9y+3SmpEOANtjkstWODiUgc+YqlA3BfMp5FQwooq4YGm2RGJCp8IJqRFDgr50k0fdzMOh3FdGeF1PkaVjqiONihx1G1PfbxDl+lT30HAyyL7LCq6nHPkedOwaohklw6Nnb2T/KtD2N1b6lqPdu2IpdvjWavIiqkqdiMg1FFKfC6nfnT7RNuLs9Y1+6eOJLiFiHjOcjyo92f1yPU7YBmAnUeIefrWGtr8XunRliDxJhvfQm1vJtMvFeJiOE7f0rOrR1OdfI9TvB9WvUuBtG54X9/nVnUrb61a5QAyJ4k9fShel6lDrGnnfcjDL5GiOj3BeMwyH7WI8J9R51m9Gqdq0VtPkEsXAfhmi2lStDcI6nDIwIoTexfVL0SIMRynI9G6ir9vJ4lcfGh7RTVo9Ye6Q6jpGoKPDdKbZyPM7jPxFaIVhNJuO/7NzoPFJbMs8fwOa3ETiSJHX2WAYfGuOSPOnHi6JK6urqkgbXUtCO0eoSWFohgVTJIeHJ6DzppXoaVukDNb0hNZ7RWbg8KW68UjA7nfYD41qKynZHVJb28n71AC22eHhIC8q1hqpWtMqSadMbXUppKkR1DNdlcWq28JxPcsIlI6Z5n4CrNxewwhsuGYDPCu5/KsM3aS9m1gT/VIwkalY+MnrzPvqoxbLjBy6N7bwpbwRwxDCIoUe4Uk08UIzLIqe81AkMs8atNcMAwB4Yxwj586litYIjlI1DfiO5+dIWiE3jSf7NbySfxN4F/OgHa360dPbvZEjDFRwxjJ+ZrVGsv23bFrEuebCnHs0h2ZTRLaI6xa8a8Z4xkuc1q7AftfVZ9WfBs7QNDaL0J+8/8hWBvJrmMYtDwu3hLdVB5kVvtAu89kHPAkawRtGoQYGAP1rSf2Xli20zDyOWkdifaYn86P9ineTVVj+6qljWbB29a1XYCMtfXMmNlTGfeaJdGk9RZd7ZlhPbhcDKms1wNjJYfKtR20QNJbErnY1mCq8OO7PyqY9DxP4oikDZUZHypGDj7w+VK4UMv2Z+VRtw9Iz8qs0GvxD7y/Kq4yQ3iHPyqVwMfuz8hUKYy32Z5+QpiFbOPaHyqCXi4D4h8qmYDrH+QqvMowfs9vhTEIc9ZBn3CkPEB7Y+Qp3hP90NvQU1sYP2f6UxFgAgJ4wMr0oVrA76a3tBJnvGy3uFE0PhTwfd9POhlpi41O5uODKRju15fGmvshkWuMRbLAj+KVggAxyq3BGsUSIJAAAByFVCvf61kISsC8tuZohyQHuxn3im2IY5wf3v6VG5HGuJf0p+SM5jHzFRSvw4bgxjfmKEJlOEiTUbiUybRqIwdveasBwf739Kr6YWNsXMee9YvzqyOIHPAPnVMRGCo4vtevmKa7L1l394p+WyfAOfnUbsxPsD50IRDIy8J+1/MU7iT/EPzrpC3AcqPnXFn/CPnTED5Ss+sRrx+CFeInPWiI4AxJkOMedDtKLSXF3cBQeJ+EEnoK9B7K9jm1i3+tXNwkUPLhByTRKSitk3StgPRdHutYdo7HLlRk5bFHLbs7caVcxXGsW8xs1Pj4DnFazT9N0TQb6MQ3sjXLbBVOc/KtkVWSPDqCpG4IrnllfjozlMraTNbT6dDLZZ+rlfBt0oPrMySzo8MYS4jbaVhvUs0smmSvFCV7k7qv4aGyyNLIXfmazit2dOD09/KXRD2n1ieXTjDEMFhhmFd2CubBdNMSnFyCeMN1pk0Al2b2at6dpJdf7Oiov4qt1xo1nhil9IC63NcWnaRXtZiVYbKzeH3VptMmvTCWmkXvCfZHIVWuuz7nxyhXAqeDvoFVBGOAeVDaaJUYtadkDGZrsnYSZq59W48NIcP6VHNEwlEpZQBU4nQ48QzSLk3qh6pwjY5NcYkLcRB4vMGmpKzPw92cedTMMUjN2in3TifcEofM1LcIpg4eHA9KlwBuaazKB4mAoHbYH4mjY8JIqW3uAsnFKzfCmXb5lIDBlpsMEtx4YlJxVf2dTpq5BSO4jkbhVt6SWMNIH4iCKhtbBeLhnZ45OnkadeQS2QDxycaHz6UtWc/x5VFkUy29xGVfhGOeRVCWOOIhYeEj0pt1cKMyTMqDqScUEudfgVilpHJcyfwDb51cYs6IxoMca5xneuYk+yMmhemyX08zPd26Qx9BnJolTejVFtNPmYcXCAMZzmqF4krIyRMFarRuZSnB3h4ccqgzQrJipf6gE/Z36zxNcygynltsKtaVo8WlOTxqzkcxSa9ZXl5ahLG6+ryA+1WbbslqU4MlxrM3ejlwnYVotrbFwSd0bljxIwBG4oXZ6Ottdm4MpLny2rK/sbtNaDNtqSyqPx0X7Dz67qWqmC/RRaR5MkwGxx0HrScaVpkzlFbkbWy02KSEyvPwseQJq9cabJeaK1rb3H1VpBhpVUMao2GpaYL+5hlsnte5GRLOn7z3UMuPpA0S1vZEkW5RkJVR3ZCt61jUm9HHKUpvRr4YJ1tlie4XAQLxKuDt1qaOSMplXyq7En0ry3tF2zl1CGD9j3nj7wZgC4LDyraI17JpUD3KLGMAtGvMUSxtdi9l+WH1kEsRZGIHRiKoW0EE08xd2nblxMNhSQX8DRBeLhAGMGor6+EMGLV1BJ3wKhJhHHJOkMvbh7eD6pBE45jiI5+6o7W8vFVbaCGNZOhfOPjUV5rSQxQICJGAyxPPNMt9bV5TI8R94rTi66Nvblx3ELJoOmm5e5aCMXEm7uOp86bf6RapAzo/AR612m31tqSk2sqtjZh1Bofa6F3uvPLc3Us0SeJULbCo2u2c6coPvopR2c8gYxxMwHXFEbDRmkjEtwGC/hHOiuq6va6S0STKcPt4Ryq3HewzWzTQMJEAz4aHOVFT9Tka0qBD6XCHyEYJ61PLFELdkdR3YG9Y/V+2F0l0yoVVlbCxjfI9als+1Fxcr3VzZ91xD2ycCq4S7ZSU3VjOzunyjXXuoFTuFY861+oXsdrF3tw3CCcD1NYOx1C/wBNuJ1s2SVGJbDHNDdT1m51SQR3k3Ayty5AVbg5MJQbkem20ahe9C7vvk9KGatOjTBQ2cUGsLib6qgjunkGME5zU442+4x9cUlGns1hjp22G7DCR+G4XB6eVTG6jiPAG7xzVPT4IZY/HGwccwafPp8Kni7zgX1qHV7Iajy2Uori7tdQYvGJO+O2DnhFTahc6tF4oY4jGdue9XS8NhaNLPIBEoyWNDdTuH1LRpJrKYxqvjBHM4p97Je3aROmm3VzGrXU/Cx3KjlTdUvZdGtkFta8adXztWTg7X38Ywzg4/Etafs9f3OrwPJdiL6vyxjnTkmuxNy8kulXeo3sIuQ0HAf7sc6NoSVBYAN1rPvcQadq0NvYleGb2kB60cViQeIYrORFEhOxpoY8O2x8qTiGCQaGx3r373EVo3dGI8PGwyCaSQ6LysAcyuobyJrjcQhuEyoG9TWX1PSb7VPDLeh5IjzReEUDns7rTZBBcnj4t0bOa1hBSfZpjgpOmbm/W7ZBJYTLn8J5GgUjXauRcXskMnVApIpvZy9mjYxyhzATz8jWowj78Kt64qn/AJbo1d43TMD9G91bxfRp2XilRiG0m1yQMH9yvWtHBc2awLwqneKdgw3rIdgT/wDm27LKZQwGlWp4SOX2K0btoe+bC4z1LHAoSVDjFcUy81yg1WKaQFVlXu2CnmeYoq13CkZCOMgcjWe1Wzmt7fYg58SMNxkb1JbyLc2qzAAqRk+hqXEXFMLSXKywLJjEkZ4gPPzq0VJYSRyEAjOOlBrO6hUlQCTy3qSK7Qw9wzHvIjgY6jpSoTg09Fy/kaWImIgtGeMHHLFWEu1ZEMKmQOARwnNCDcJHlQWDeh2xVfS7junliSQhkbb1U7j+dHHQe2alCeEEjB8qU7UKurycxARqFztniBNLp4usnvCy56tvU8fJPDVhFJA2cjhxUgOaYzpGuJGHx61Pb39qSEXh2qTKV+ETRW/EueMY9KkeTuVxxhj5YrnnUjhjXJ91SJwFd0wfUVJg2+2cHbgU4LZ8ulQ31oLoLxyMqjfAq2uMbbCopJlD8Odz1pEJu9EKQxrCqxSeAbc81yRxcLFmziqMiK15xI2w5gbZqdgJMgDY9Ko24v7LMckXDxRNx+40qTkkhgBVRALc+EcJ929Sll9qZ8A8qRLih07LODEXKMeWDzoSVktbnBY5HrsRV+4tGllB4sIOpqvdWgViVY8AG2d8mmi4OK0X2t2niUd6AvPw1TubBUZeB9uoqG0+sZKRMVXrnkKvSd2gHeSAsR0oDcXVnQR2yQkScJB86o3kKRLxQyKVz0O9NlhlCEsMR5yATVdELZx8qZcY7uzjLIcZdvnSzTvKF4znAxXLGzHhAPF5VJCHyQFU+hoNNE0G0I4hj3CpGUr1G++xpgHEPGoHpVa8vYLFVDkl29iJBxM3uFHZLAPamVLzWdJtmfgCSNIZG2GVHnXmN5BPdR6lq5wyLOF4y3Mk8sda1Ot95eT6pPfL3a2cRKRA/eY7BvOhWowG37A2cSLh5bnik95HhrohowaN/wBipkn7OQXYiEcrqeNycliOpJ3q92Bjkj0O6u2PHLdXDyZPUZwKG94dH7BpDjgdIMYxvxH/AOtaDs/ZLBo9lBCWykS8WR1xk1jJ9lSXVmW+krvbyHTrVQzyyzjhUda2WkRGHUJYiADFbxJgdMZoHOsl927tYiFK2EBlPkGOwo5pMne6zqZznhKJn3ClJ6oxm92GK6lrsVnZAlOpMUtIDq6urqBHClpK7NMBa6kzXZoAWurq7NICK6mW3geRzgKK8t1K4uu1etpZWG9vGxYufZJ6ufQchRrt5qNzfX8Gg6YC0837wr90e/pWl7NaFbaFYiGEBpWAMknVj/T0rVf5avyzWLUFfkl0DR7bRrMQW44nO8kh9pz5n+lW7+4FrZTzucCNC35VYrK/SRqIsOzcozgzsIx7uv5VEU5SIXyZ452ovWklWPiyd5H/AMzHNWbXUBJG9/N3a4jWPwJwDCj8z61mrqYzd9cOd5H4V91VtfvxFZQ2cZ2VeJ8dT5V3qKdI7b4oLWeoHUNWlu5MiG3XwD1NZzthqLTuq5PjYKB6VPbym3skgBw7+OT3+VANSbv9atYydlPEaafbHLUaIdek+0VByG3yFAr1iLaQ56UX1bxTZPPiNB9WHDYt5kgVSZzzXZe0qEi1jHkoqfuOO4I6CrenQ/2dNugq9Ba+NmPWs3I2jDSBt4hjtHIG+OEfGoEg4IGbGyiieqR/7NF+J8n3AUt3Bwaem3ikkA/OjkaKGz0b6JtO/shkI3JCn3Dc/rXqo2AArI/RtaiHs/FIB+8Jb8/+Va7pXlSfKTZ6L0lH6KWuRd/pF5EfvRMPyr57SLOipnmI8fKvo6YccTr5givA7m37vTbqPrE8qfJjXV6Z+DKatAFIT3cDgfdq+IAyggcxUlnCJdKgcdAP0ohbwZiU49K6ORhwAktr6VWltsxsCOlah7UEcqrS2mxAFNSJliMDeWDxwC/UfZxSLFJ6Bgd6vRJxxDzG1bLs7pUepabq9jKBwzIBnyO+D86yNhHJDK1rcDEsZMbZ/Ev/ACpRyW2gzYajGa8kd+mLdJcezsfdVPGDR0wh4JI2GxGKz0RJR42/eQsVP8q1i7RyzjWwtCBc2ZQ+0vKhbrwuVPSrumycMmM+FhTtTgwe8XkedCYNWrKiJ3kTI2/UUIUGN5IzsUbHwozBsPjiqWoQAXPGPaZdx5461SZnKNoJaHcFYnjzsDkVYux3iE9RvQnTWKz7dRiioNJuiobVEmh6pLp92rKfD1GeYre22pJ9agu428EnhevMZkwzAcxuKI6ZfssZiLeE9PWh7KhJx0exXMQu7VkB8XtKfI9KqafJlMPswOCPI1B2Ivk1aIQyTxwyRruXOxpdW/sd4kw2imOCegb/AJ1nXg6YyTNn2XvzBe9yx8EymM59RXofZedrjQrRn9tVMbe9SV/lXjdi7MFkQ7ggg16d9Ht59Zsb6InxRXJOPIMAf1zWWaFKzl9QvJrKSuPvqFrqJTgNxN5J4j+VcxzExOBvQPXLf63ApZXPiyvCQNh76ITzTOBHFDjj2y7Y29wqlqqMI1+sXARcbBBw/DzpouC+QO0WBbK8EjgqCOHJcED9K0Bu1baFJJfVV2+ZoFpgtPrSeyZMjBbmfnWlpsvIt7Kv9qk/w4R/qP8ASu+qKxzM8kp8mbA+QqJdVtWvvqYZu+zjHDt86vUEbRFJGkVvJ3cYUcJ2QVhG01BJyuuef3Y/TOa3txtbv7qzM00CXHC0yZz1YZpxbNMV7o0lmOO1iOCPCBuMU9hiorBwbZeFgyjkQc1MzZFSZ7TGUO1TS7fUgguOPw7jhbFEDSGmi1oxF9olvFcOsVq7qNuKSfGfdgVZYC07LX0KwtEMbZcNnPkat6tcW6XDiSRePO65yR8KFa1dQnRJFgkUmQgEA78/Kr2zZKTSsyByD5Vuvo7T+xXUh6uB+VYRtxXo/YWPg0JW/G5NOb0Xm1Ej7ZAn6tg451lmzj2/yFantkMpbeHi3NZNgM/u/wAhSj0GH8SKXIZfGOflUbA8+8/IU+TGV+z6+lIQo5R/pVGpYk0m8ECSsyKjjiGTviqbWcsakiRWPuxWj1Ga5ubK3YQ/V4eABcsCWx1oDNE3C32knzqo7M1JvsoliSQXwR7qgn9g/afpXWqygy94Aw4vCds4pZ88B8H6U/JREdh+8/SkJBX95+lK5PD7H5imrkDJjGfeKBMW8nFtp7ScZyEOMdTVexAtNNUvJhuEu245neo9Qzcy2VsPMu4HkK7XHdrdLdFAeZgg36dapEMTRR/ZXnd8PMxc+7pVsFSgzIfmKeq93EsaoOFQBzqISMFGEHzoA5uDY94fmKH6zJ3dm3BISzHhG/nRDifH7sZ99DtQJlurSIoPb4yM+VNEsmgRIYY17wjhAHOnFkP94fnTm4seJB86aWYDZBj30AQgpxOe8bn50wlD/eH507L8TbLz6mkLSZwVX50xETsnCftG+dRXkyRW0rhzkLtvU0nGUIwN/Wh+tu7QRQADilcDnTQn0TaSix2MQLEMRxHfzopBezRDgjuZkQjkrkVWQMqqoVcAY51NEJJJlVF4mI5DNDFQZ7Na2uj6j9aZDO2MeIk1vrHtfNqpZYIBEg+8Tk1h4eyutSxCRbMheYycGnRz3+juIJ4O6yd+LNZSUZDioOVs3Tuz+J2LHzNMzk0+y0ie60+O6Fyr8S8XAtVpJliyoUlhtioR248kZfiTEgDc1btHnEf2EvCPLNCoQWbvJjz5KKJRyQrGCFYt5UMc1aLUc94z8ErMUO2asCHEbDvGzVZbr7MAI2fWp+8yAoJLegqTCS/VFYI0yMrcXEPWqcqPG2HGPKilxK0MeVUsfOoLSSGSQyXMiBuik00XGbSvwMhuZ4kxws3ltVmCaRnxOvCOlLPq1nFKsQkV3PRd8Ut7PC9sSHGeYpGd8n0TOPCRVTgWPAmZWBoU+oGIYe4C+hNXhKZrPvG4WTGeJd6dF8OHbGz2g4iyMoXyzU0WpJbwhIoseZzzoLFNJIxyMR9D1NEdMtRdSHvGARfzptV2aSiuNz6ItR1ciIvcSLHGu+ScYqC2vH1KLvojJJF+IjY07XOy9pd31tPPO7W6neInw5o68ois+606EGNBw5UYAFFpLRn7kVXBGctez51aZ3vpSYFPhQbCjEfZ+KCLhtiikcgBgVYsLmK3tlVg5YnLYXlVmSeWSMi1iJJHNtqlyZnPJk5a6M7dQvBKY3xkeVSWdlLdBjHgBfOitlp6sjtdjMjefSl76LTLeSPiy43UHrT5eEavO2uMezMCST6xJC6FShwc1J1qqLtjcyveyKHY5ydqp3mvWVrkBxIw6A1qlZ0KVL5BYmopGit4nkkYKgGWJOBQPTtdkv7po4oi4xlUQZY1fvey172i0ljePLZS58NvkYI9aNLsmWaKRnzq132h1JbbS0KafG32sx24/QV6NDqVtY2aJHDwhRgKoxmh+j9nHsbKK3QJCqLvjzo5a6XaEfbN3jfiJ5VM5RZhlnB97ILbWI51DSQsh/iGaqavZW+qrxNZK4H3inOrkdhGdUEStmIDJPlRHUp47SDhR+YwFFRdPRnyjGSUFsx2h9nNLg1VJlt1WReXoaJdt7i/j01otLUd+d8nyqZLITATQzESZz5Vdt4GbxXDCRhyqnLdsuVcuR5Vb9r7myPdavZurLsXA50asO1OmXpCpPwOej7Vo9R0r6yzmS2V1z1ArK6h2Ms75sQxi3mzsV5VspRkdCdq0Gj3NxgqysfNTSGMoCeMgYoSvYa603TZpba6mnvcfZIrYANQ6fpna42zrcwRFSpGCcsaVrwxe9Ez+h37QdtJVtpm7p2IPCdjXsOhWU7g3AmKg+uc14rpIi0nXjHfQPFd5IPH9016HZ6xd2o+xmPCenSqywcuiJQlOPxND2g0mW7dXaUhQfHkdKKWZgtdPMNjGuAuBg7E+tBLG+vNYhkhmuY4hywPaNELK2OlWTp4pV9rJ51zSTSpnLODrjLtAnTNJsdPlkvtZC9+7EjPsrUnaQ2Goaa6WskZl5rw7Gq2v61Y3OmvEVYl9hkYwazdn9XtsOz8BI2Oa0jBvbNceG9sBK95DdBVDd4DjAJ3rUxdlbvUY47iUrC7bsGolpUtrHIJpY1lbo2KKS62ScRRjA6mnKUvBTxyWkDYNLudGjCxYmyfKjFpNcBVe+7qFeiAVNY3YuYuOdkUjkKA6/fRm6HcEtjY55VKTk6Y4xc3xaD9zexoUWNgWY0L1zXbeynghaMS5O5PIVnZrqRhlTjHIVntUuzNKBMWyu3I1fs12OeFQQb+k3VxdaYlvZSApgM/D+lZLs123vNHt3t3QTxEYXiO606cq8bLhiCMcjWPukMUzKfOtscVx4siFVRs7S+e7iMp4csxJ9K3nZ/R1uLKKeG/lXqyA7V5JoEuC6MGPXaj0VxKHWOF5UDbYBIFRkj4REluj06/0eCSIXOn8L3cbDBDc/Oou1+uHT9PRVOJcqXx0FZfQ72+0hZDEwKncq29A9e1KW8huJJkZuI88cqiOLfyLWOn8j0odpLB9Ae6gmVn4MBAd81hLbtbc6KZO74ZWlOQredZHTb6GCKQSKWkPsgVNbKWkM06EudwMbCtPaUeyZRUezer2p1W8t1zCsLtyZF50MnudbMgmlLjG3EU6VVs7iaWVZHcqFGB0oxFfzp4ZG7yM80fcU1D6RvjxclZD9dmiRWErhjucHG9ajStcL2Sd9J4xtyrK3c0bqwESqOnmKMaPdQrYqGEJOepANGSKa2a5Iqtgz6PVVewHZVRG2W0q0OT1PcrW2a0iis+8lXxhc+6g30YW0T/AEa9k3ZMsdItNz/uUrTTRGWErIQF9K4+XRyqdpGe+tyTQCBhlQcgnmKHQlraae3LbH7RPceY+daWO2to4mkd1+dALq3kmlF3GPs4Wwx5eA861UjVNdj4oJZFLIpKjrVnTli+sqZM8Un2ZJ8+lE4Y5EC2gIKcy4HSpZrALZSxwMQx8SnHIipcxSnaBF3ZtC+B4ifIcqoS/Z3EUhOx+zP8q0EN3/YgShZiPE/TNDJ7ZbiCQyKyxkeFlH3ulOMvsala2S2scbIXeURsOR4qj7yRpPG7t65qvAe+iR0yQRuSMYPWrLRiNhl1YfwmmVQRe1MoicyMeLmGPIVZu4oFtwsPDxgjh4dzQhSQwI8S/wAXWrNvJ3N2jScCj+HpUNGbiw9ZvLEqmTDNjerL3THZRihF5dYKLbvl2PSpBDOELPcHvMchyrOjneNPbCQeUrjJxULZ+NMtZXeBctnzxSXEwgTjZSR6UqJSp0Pb2SYwpaq/15UJEi8Ei9DyNV5boSeK3Dq/n0qLEtxIDJwk+dUl9mih9hJb2OQcTnDU8zwyR4wxK7hsdaqx2Qx4yPcKuKOEAAYAqdESUfB1vqCuxW4wF6YFXklikGIirelB54CX4oxsavWtubdA/EeI8xSdGc4R7RbZuBMyJz2wN65IIgxZUAJpVmU7HY+tIZSreIZU9RSMaZHe24lhIzwgb0JtcxS8YXiC8/KjMrM6kKuVI51SsVkjLLIB3R+dNGsHUWmNcxySLLGOE9TSEjf2R1J5UzUri1skBMniY4SNRlmPkB1oabW6vz/b8wW55W6N4m/zn+QpotNeBst/LdyNDpaq+Dh7hx9mnu/EfdUtrZRWKSTMzTTsMvM+7H09B6CrqRpFGqRKERRgKowBQnWZ3i0vULjvSndKyheY5dR8apbKMFqctxeW1wSqhNRvQgIByAvSiPbNFuNb0bS4cBECyNjqByqbs/bJe3WlW6se7tLczuynlI1VtKh+v9rr244meOF1t42Pv/8ArWtkGn7TKbltM05P/aLhcj+FdzWhV2hBCnhHWs7G31ztqzA+Cxg2/wA7f8qK61dG00m8uNuKOJiCfPFZPwivsxmhdpLKDtFrFzqEjoJpQiSFSV4V251quxt8t2+pz2zJIj3HhYHmMUG7J29vaw6I06I63kTRyqwBDMTkGtLJ2Q0rjMlos9lMST3ltKUPy5U5NGEnWmaCMsVy+AfSn0DtbPVNMULBdDUYOfDdHhlHucbH4iriapCrBLsPaSnbhmGAfc3I/OsqM2EKQUmQwBByPMVwpCHV1dXUAdXV1dTGdXV1dQB1VdTvY7C0eeU8tlHVj0Aq1WTjnbXu1Xh30/TyQD0kl6n3DlTS8gkW+yujtamfUr5QdRuzxMTv3a9FFaGurhRJuTtg9i14/wDTjqZNzY6bCfFguR6nYflmvXycDJ2Ar5w7b6iuodqtRvifs1YxR79F2zWuFfKzTErkZfUp1hZIlPhjFAWmNzfANuqnjb+Vdf3fePI5OxNMs4zFEWf23PEfT0rrbpUbJ8nYSjkMjuxoTC3edoXP4FAola5KMaFaWeLVbpz+ICovTNX4O1Jczr8aD6+OG2iHm9aLUk+1U+pFAu0ceUtx5Bm+QqkzOcezU6bFm2j9VBonHDtUGjpx2Nuw5GNT+VGIocgVg2dkI6Mvfnj7RwW/PggZ8e84q/qywxR2yyuqsAWRSd2PpVDBft/cL0W2Cj51qtZ0e0udCub+ZC1xaFVjOccOTvTlKmXCD2arsx277MafoFjby6rEsiRAMoRjg9elFk+kPsvIcLq8A/zKw/lQPR/o87Oz6faySWgLPGrHxtuSPfRiH6NuzSjP7Pjb3kn+dcPuYvEX/wAo3eOS25f+C6O2nZxk4hrVlj1kxXl9xNb3Z15rOZJ4O/dkdDkEMoNel/8AQPs/Gv2GmWqsORaPi/Wsdr2mrp2rXtukSRJNbB1VBgbZG3zrXDOPKkq/3Dhq+V/7f/pl+x5+tdn4wdyBw/KjdhFlGBHI1mfoyucrc2b7MhLAema21vFwXbp0bcVs3VkRjpWRdx0xUUlt1xRgRUjwZFKy+IF7Ex51XUYeWGH9az/0maTJpuoJqkCeB2Alx0Ycj8RtRuyh1CHtTeLpssETuqH7ZCykn3EeVS9pU7YSWE0F7oun31u6lS1u5zj3Heo5KOW7La5YuDVmRThkSOWP2JFyKz2sQG11EXKj7ORcSf1ot2Y79IptOvoZILq3PEI5FIPCeu9EnihEiNdIrwg4cH8J2Nb8vo4lDxMytuDHcFf+IUYdBNCQRzFUtUshp10EimSeGM8UcqNnjjPLPqOVFbSPjjBHLpVOXkwUKbiBEhwsoI3FUdaykFvcKPYcZ9x2Nah7XxsccxvQTUIC+m3EfVM/lvVRlsiUKQPjAjmRl9knaiYahtse9gQjmwDD30QFU2ZxOlHjVse+oXQxTHHvqy44kNdcLxRK/UUJlNWXtG1GSwu1niJ/iHmK9LWWDW9HIQ5WRfCeqtXkqr3YVj7P8qP9mtXfTLswzEmBzufLyND2OMuL2b3sbcmYSWs+08JwwNbvsNJLB2wv7NZDHFc2qzLtnxKcHHwNeYz3I03WbbUoyO4lISXH616XpEoi7S6LdJgq7NCT5h12/PFKe4NBkWmj0gWsZ3kLSH+M5Hy5VMqKgwgCjyAxTqQ7CuA47Ik8U7nbCjhFDe0aStZr9XJEvFgEHG3WryI7xgxy8AYknCgk0O1aL6pB30k0si5AIdv0prsuHYFslubWTvrqV2iTcoGyT861H1+AW3fO6oMZ4SRmsxc3tq8LojNkjGSQKUapbKhXuIHGMcT4J+dXxbOiWPkr8lWO7iHaYXMrhIuLiJznG3pWytL23u8/V348DOeEj9a8/tLhIdS77hRkBOFfcUdHaVwAAIAB0zQ4tinjcujUXAVoHV/ZKnNecy3VsszBXnIB5hVUfKjrdpXIwRDj30M+t2vET3MG+/MU4xaKxQlHs2GjKv7NgMZJVlzuAD8hVwgCsnD2jMMSxxrAEUYAzTj2nbyh+dLgzN4pt2ac7U01lz2nbqsP+qmntSR92H/VRwZSxSKvam4s7bU2WVLhnZQx4H4VoJfXFrNpvFb9/wAXeAESNkDbpRe81qC6fjmiiJxj2hQ+4udOmUK1ugwc+CXhz+VWkzaMWqAB2zXqHZJODs/aeqk/nWGJ0rO9uc/78/0o5Z9p47W1SCOONY41woL8RNKUW0LLFyWgh2zz3VthuHxEVkzt/efpRW/7RQX8arcwRkKcjEuKHm/00j/ZR/5//KmotIcE4qqKkp3H2nX0pD/vP0q0b3TDj+yZ/wDf/wDKpUudOblZ/wD68/0p0y9/QYuRxaLZY38FBJoSc+VGkv4HtoohACijAXjO3xpQ1uwyYB/l4jSTomMGjIdyU4gWI35VXnGx+0PLzrXyR2QBLW2PTjO/xofdSaYAQ1jj3XBH8qdtlO/ozLgY9v8AOo2K8P7w/OkvWmeaVrNWMCnbbix6Z60HvL6dImy+52HhFMku6UO9up7lnPAT3aH0FcCtzrTMWJjt1wDn7xp2nS/VdHDtjCBic7U7RY3Sz7xwO8mJkOT51dkFwlTn7Q/Oq+EK5Ln51YYtgnA+dRRlyh8I5+dICMcI5yH50ORkk1OV+I4jAQb9Tzom5ZFJwowPOhun8f1czHh+1kL/AJ7U0JlpinVj8zURKA+03zNWQssmeBVPxphgnzyT4tRYmVQU4m8TfM00lM82+Zqx9Xm42P2e/rSdzNn+7+dOxFVuDB3b5mh0xSfWIVyeCJOI8+dGHtpip3jH/EaG6LDJPNd3AKbvwAknkKaZLLoMZ6t+dE+zuqJpGqR3Qh77A5MCaqC2lzu0f51tew9no0RM+rSo1wp8KNnhAqZPQSdI0Om9sL3UbqKK30yUIx3dgcAVptTtbO8jC3kKSMN8EUObtRpMMscFu6sWPD4BgCil5eW0EJlYqzYyoByTXM++jFLfQDklWyzFZoYEHTO1UGwzFjjJ60kss11cNNdEDPsoOQFd7q0So9XFDiuhcAGi+nRwJFxsylj59KEwxtLIEQZY9KkubSeB1DkYbkBSe9BkqXxsNi5tmbgDLn3VKrr7MXD64oVb6WzKGduEnpV2CBrRHKnjFS0jllGC0mO1GURWrEjOeQrDvoU2rXpLTd2POtRPJJfyd3GuAKlXSuFc97hvSqT4o0SjCNSewXZ9ko7IF45i8uOZ60G1cXbyCJHZEBwxXnW1it5Y42DT5PSs7NOYbhuEB5AfLlTjJlYtpqzB63D3UqcC3hG+TMMA+6vROyR4+wsZPPLDf30H12O+urZkkuYHU7gcIyKLdkj3XYwxTMOMSOoxVN2kY5ItUS6NafXY+Li4YkOCana10i7ufqi3jvMRukcmMfKsnePqNvHLBE8ndPkhUFVOxwu9P1GS5ZQiYwe9FNw7dmko5JaNm3ZuzsSJVurkKD7LuWBo5p8okt8pH3cS8vWsrqupTXyKqXEUYByd+dVL/XriGJYrS5gOBgoTUcW+xew3Gmw/Z6q0urTRTukcUfp7VXNQ1RI04bdgzHqOlYvS557nimuo41kGwKHINN1TVl05FMvC0rHAXPSnw2a+xH8mbfTpI4rRriebLHcknlXWt3Z6sJGCBkTbiNYiWSXUbNoo2aEsM8XSqUOqXuiQtplnFJcTTDeXHhFHCyJYG3aLfahbK4glMTcSRtjI51krPSLjVbh10mKNVA9qdwBn3c60KcFjGLjVTh/wr7IolpaWTRm5s4wvebl+prRPijZw5aG9ltJuuzc3HdvFLcTjxd0BhR5Ciuo3Ou6ncBNJgFtaJu0svtOfICmWZW1lMscYZz+Peo+0Hai7sYYxDGoLc5Oi1DtuzGeNx3Qb0i7uLy3e3u4HinjHC7dD6ihF7FJohYiSR1c5GTyrS6HeWt5o0d3x8QC+NvWszqhvNY1NCkax2IPAPFufWoi9mGOe+ibs219dajxB4+5xkjO5rUy6ejvxSkcR5Zodo+jWWlyccYkd+fEzZq/b6jFfzTwxKyvDzyOdTJ27RGTJJytFVdPELlo394NWCgwAu3up+D8aH6pdXVvEDBavIx226Udl8m+2NvElYkGZUXyziqdpZNK5Z+IL0YVJpsLXUpku4mDjmGowFAGFGB5VTdaRq58VSIoIREuAxb3muvLkWFo904bu058IyalAFOKccbKSCmNweVQZSf2eR9urGTtFP+0bCFw6jy3NA9A19oHFnqWUZdgzdPfXuNssCx4tzEUz90g15V9JvZ15dT+sWNuxZly3Cuxrqx5U/izaGVLo1PZW1i1K6PDc8JTccJ3NaS91Se1vHtp7GSSFV8My9a8n7B9q4ezvFb6lauCTtLg5HpXrem63balbrLaTB42HlWWVPlb6MsvKc+T6MnBpcurzXDoghj4sqGG9UbrSgt3Da3xEeWwG869ESMElo158+Gq99olvq6qt2GHdtkFdjQstF+/Sp9EUXZWzW0VIpJFOOeazM2m3Vvqn1NPE7br6jzr0aJVhiVAfCowCTTQIWk7wBS4GOLrURyyRz4/VThfkzSdm5Bb5knAlxyUbVlNahFhcBJJA7noK9KvJyqFUUliNjWTu+y7XIaaSc8bHn5VePJTuR0YM8u5sx8su2UOSOYoZcQzXJYpEfQkVv9O7O29jITJmZ/xGin1SIoV7pQPdWjzI1lm5HjvBJHkPjbpih2oaWt3OkykAY8W1esXnZezmcuUYE0LbsdJK7CPCx9CTTjkRmqPPbWzFs7GNhhumKJ2UEouYnIHD7qd2t7LatoyG5iVZbVeqcx76k7MXEl5pw4kw6nG451pGpbLxQ5SthZn6UE7TusWmsFAHEelHHhkUZK7DrWO7V3TT3UVpCCzeQ860R2TaUSvpOm99btc5zjpRvTLV38T4K9NqWCyv7DSoY3tXUPv4lo5pPZy+vbFp5G+rxKCVUDc1nKaTtnG3FStmd1Z3iYRxkIoOdhS6ffspYTyZFU9RVxKwljfIOMkYqFUycd1v8KOXlGfutS5INzTJM3CJQoxsaI2fZC9voFnhuUVG5b0COlXUdl9aktykWcAsOdFdLv7yG0WNGYKDsKTbl0apvJ2av6MruNPou7KM7qvDpNquCfKFRWmtLpLiI8fCpHME868s7Nvw/Rb2YH3m0y1A/wDKWtvocTTwQrKSGK71y8PjYljXBMt6iI3mKoBw+lQxMyQvECCrjhIIq1eIsYVFbJHSoFhZlYoMgczQuilVbO0u57iy4eIPcIe7fJ8uR+WKKWy95FxmZjndlzyrOMDBqavyS4HAf8w5VfAIGM4HpQ0TxJRexRzyWPEBGz8QHmp54+P61JdPEgAgACis691KmqCe3yFQ8DuBnCnnRvTdQtmmniuIXZOHAbh602qDjx2gdGypNPFxEcR7xF4fPnvU6DiGPCMdT1qpdq8PBISzBHzjyU0UiQINuZqrNLpFf7vIip4ph3ZUhOXVf505wCu+cVA/CNkzSux9kls7JOrIvERyFSzvcFmaQOobpUmk3MFtKWmQselXZ9Vhc+CFsetS7syk3y0ira3FxbLwYwjciw5UWMkUsAR3RgRv0qvNqUVzbiJYCznYZND2tLhBxPE6r1OKVX2Z1e5aYStLVISd+IHlVhlGccI4aS3C9ynAcrjnUzIQM8xUWZt7GKAAAOVOpMGlpCFXKjkKcuWOOLFLHGH2LAGrEduoHi3NBnKSQxIA25fNWFQBeHmKha3Oco2B5Uy8vYbGJTcP4m2VFGWc+QHWkZSd+S1sB6UDvL1rqdodLUSSDZp2/dR/H7x9BUv1W61M8V/xW9r0tlbxN/nI/QUUSCOONEjRVRdlVRgCjolOgLbaatnOZTI892w8U0g39w8h6CrDBsni50VxUUltG5JIIJ6inZrHJXYNI9KyXbC4AVbEKwS6mUO/QY3b15VuJYYIOFmk4MHmx515p2v1BLvXI4LaXJgVgCpxl3IH6VcNspzvoO6DaJZ6RqerMwVJi0ig7YRRhaGdjrbg02wmPtzvJdy554wcU/tdM1r2O+qRJKokZLaPj2znmB512rk6dp0yxbPBaJbIAceN6pbHGy92OTv4L3UGOWurhmB/hGwqL6RJzF2ckjB8U7rGPnRzRrUWWl2tsBju4wD7+tZft831rU9IsgBhpOMgfKpW5Gj6JLTR55Lb6u85EluiyWsY2xtnOepztW50acz2UTYJBG/Edweoobf2YngTuMxTxnwSKd1/+fKorP63p0DDiV2dixKDABPpSl8iZQclSNPTZI1lQpIquh5qwyDVK1vSyoJhgnrV+o6OaUXF0wbJo8HO1kmtG84HwP8ASdqj7jWICe6ura6XoJkKN81/pReuoskErqN7EP7XpU4HVoHWQfLY1PDq1nIeFpGib8MyGM/mKIUhGRg8qAGRzRyDMciP/lYGpKha1gY5aGMnz4RXGBfus6/5WNAEtdiozHIPZl/1KD+mK4mYDlG3xIpACe1uovp+kt9X3u7hhBAo5l22Hy50/s5pyabai3TfulCFurNzZviTQR55NV7fxwtGTb6VD3jKCCDK+w+QzWmspgI2LLIOJyd0NaPSofgu11Q/WYc4MiKfJjj9ar6rqdtpmnzXlzIoijXPPn6CoSvSEAfpF7QroeiOsbf2u4BSMeXm3wr5n1vUM5iQnJ2JrRfSB2pm1bUJbmVsE7RpnZFrz3vGnuDuSeQ99d8ILHE2WtImijM0wyPAu59fSrchwDmnrGIkCj4n1qtevwwufIUrtnQlxResPFasRQrRhm6uz/GKIaI4ewfOcjOKqdnwv1u6DgkcQJA2NS3otboJajFlAw6NmgWux5kgB5d1J+la2eHvbZsDbG1ZXtLkSWKgbyBox7ztSUvJcoXr7NJ2SkE2j6efxQj8tq1EMWwrN9n7VrC//Z7n9xxqPUHBH862EKcsCsbs64Q46fgzV5piwdoLC/Ufvy8Ln15j9K0XAJey+uRSMFJyVyeeBWd7Sdo9MtLi3spZp3u4plkCJGOFN+rH08qq6t2ubSbjUbWHS7W5IkxxTuSCrDmAKfCT7Knlxxd2em6DrlmuiWHFOgbuVB8Q8qMW3aXTlOGvIF9DIK8A0/6RdYsrSK3h0/SjHEOEccJJI9Tmi9h9JWnXTiPtJ2dt+E/31rzHwP8AWsf8O11/7/8AwqPqcU1TPfrbUbS6AMMyPn8LA1lvpAth32n3IHMtCx9CMj8xVLQrTRtRsVudAlinhbfg4irr6Z5g++p9eNw2iyoWeVYiJAH9tCD+YrOL4y3ov201cHZ5Lpdi+i6npupjP1eeWS1m/hPEeGvRZ4+F4pR0ODUcelW+uaLe2aALklwfwtzDCq+m3EsuhyLcDF1aeCUeq9fiK1jK3THNf6l5DgTOD50pjBHWk02RZrdGBzsCD5irXBTBbQFgtT/0jl4PbkteJP8AMrZrbWcoubWOUDZ1yR5HqKzsKcHaDTpOhDxn4jI/SjlqPqt5NbHAjf7WP/8AKFY5Fch3RjfpD0A/Z6zZRlrm1HjUc3iPtL/MVjrmJZlPD4o5FyD5givZL66tO6aOeVFDDHiNeaahpq2UndwkGHiJjx0U9PhWmKTWic0OS5GaXsVFLpn13TJ5TMsRJhYAh8bEe+q3ZqT6xbFTnjibgORv6Vvuya8ImhJwqz49wcbfmKzl/pR0jtZccCcNvegvjGyyDn8xvVRyNNxZlPCpRU4ra7GSW2x2oFcW4+s3MWPaUN/KtmYQUoBqMIj1W2/8VHT5b1tGRzZIaPPtP41spkYEPA7L8OlGE8UaP+IA1NrVgbW2F0FRY7iJl8J5ujdfXBplipaxh/yA1pGVqzmlDjKhwUkVIqZgYVKkRxUsMeYmzRZSRWij72z23IqKEF4mQ7vDt71q5pO6SKejVFcp9Uv0lx9m3gb3HkapPwTKOrNdYW9w3Z6FNSR0iu1P1WQkEOBz92K13Y7VXuNCh7w/2rT5lDefhPP5V5XN39vLGBI5jXeMFiQvmBWl7NagI9X4shY76MwyDykxsaaM3dUz6pRg6Bl3BGRXN7J91B+x19+0OzWnz8QZ+7CPj8S+E/pRquBqnRysitsdwmPKotSijms3WVA6+RqWE4LIfunI9xpl8f7M/rQC7B9ppFmO9EtrC3jONulWP2Rp3/c4f9NKb6CKQI5PE522qeedIYDKxPD0x1p7LfIyWkWdvN2gu4pIkaJM8KEbCtH+x9P/AO5wf6azeh3UMGtXc1zIIlbOOI+vKtdBPHcJxwsGXOMiqZpktMpnR9O/7nD/AKaHR6PaPqTkWsXdKcEY25bbUfNC9Kuu/u7+NlAeOQDY5yMUrZKkx50fT/8AucH+mkOkad/3OD/TRA0hotjTZQOj6f8A9yg/0006Np3/AHKD/RRGkblRbC2Z+TRbKd5447WBW4PCeHkc1lu2lnbW+oQxQQRx8MQLcAxk1vrIZlmb3CsJ2ybj1+UfhVRTi3ZribcjPQWqSTxjh9pgOZr1CXs9pctqYWs4RleHiVcEbc81gNIj7zVbRcZzIP1r1Y0TbDPJpqjybtJY/VJYbWW3jVoQR3iDHeDoT60EMKZ9nHxrVdt5uPtBIh3RUVT6UAMZDcPOtE9WbwdxRPodnA9yRJGrKV5Gi0WjlZWKoOEnIwelVLCE8QK5BHWtJah8DJ/KpbZaWx9vp8ccKkjxHnU4t1xyqwg8AFLipstIHz2gYHC5oHqOls4OIia1Tjbahl6zqpIP5U0waAtjbdxZ8DLwkZ2rz2+HHqDRgeFWJPzr0sSEWsksp5A5rzYZluZZSP3jkj3VcDmS2ye6xJZ2tqpwZZDxf5aLju1wqscDYbmhGmI81/JMBlI/s1z59aLt3nTh+Zq/0AhZC2ONsDyJqMFcHxNz8zT17zf2aYpcA8ufrQBT1WRUspCrNxMOEbnmaaqRxQRopbwgDrTNQZ5Lq0gJXHF3h9wqxLxlM5XGfWmSWYpYLezLyyqgZsAsahfUbPrcx/A0K1+7eKKJEbhkBzsM4+dBlu72QHu5mJAyRt/SglmqbU7Pl9YT86jbVLMnadfkay7XWoDJMkmB6j+lMN3ff47/AOumKzSX2r2qWkpjly/CcDhO5qvot7bWumxI7txnxNhCdz8KzV1cXUiiOWZ2VjjBfIqUT3igKLlgANh3lPwTezXjVLY9ZPhG1O/atudsTf8AlNWPE12cf2pv/N/509TdupIuGOPKQn+dIdmxi1GKSVVRZ8k4B7oivQtLxHaJlmZyObdK8Y0eOWa/iEtyUXIyeM1vdS7Y2ulKlraqJpQMFidhUyTZ0YXFbZtS2NzScWeXOsT2f7RPqMztezImDsoaiV92qtrZhFb/AGrciRuBU0zpWSNWbLTLtbUNxpknrU6XqTXfHPso9kV53ddrZFULawl2O3Fg4FaPTmkktY3nP2jDJFJxI4wm20aS91IbLAfe1UjrhwYgOKQjGaqrHJIrd2pOB0ofbxBLhi2ePyIpJIPbgtGhsL6O3ibjXLnfNQTalK8odThRyWn6fbQzKTLKoI+7mm3tvZowVL2NG6qNyaNWTeNS32K+rTOpBC77UNwASRzPOucoGIV8joTUUs8UKlpXCj1NUkbxjGPRzxLIRxAY61PZqrWbG3AEKMcgHYGspqV5daldJBZSrFCTgkEcXyrRadbmytFgDs2NyT1NOhXyfxJRx5znaob5DNaSJw8TEbClW4DzNGoJ4eZNPDEg4HKg0W0eeavoGqwW7XAmZkzngXoKAaNpVzq9+IklKgHxMxxivYSQUIf2TzzXmvbDSJdMna7sZD3EhyeE8jWsZ3o58uNR2jVHUrDQI49PikM0wXJ3zis3eTXWo3pk7osCcA9BWT0yXvdRQ3ErAHOWzvW/sdcsLCFbeFe/Q+0x50muJmp8+9IP6RHeQwqt0VaMjbHSiWBnIHyFA5dfgiaCO3TjEo2qtrc2rxoJ437uHlhak6VNRWtha4vLeUNG0XfMv3MULn1i77xbfTLLhA5g9KztzJe2/DdS3DqX5EHnVUarPHiRJm7xtmPFzppGEsxobLXb83yxTKvPBBNT67qSHMKsXLc8+ytZXiKTcRkbjznPFUjSd46l5GJzvvToz9x1Qe0nWrmxgkiHE0bDZOPAFS2t/fTXiugaU8+6VjigiBCQONvnWx7J9n7y74byxvEjZfM5PyqZNJEOVLYa0/U9cnkVGsFSLOCScHFabS7GO1meVCe8k9pmNULq21dLNlhu4ZJsfhxQTSW1aK5MdxFK6k+Jn3+VY1ZnXJG0lv7CC4SKSZO9c4A51JqBWKAsgHeH2Rnmazs+gWssv1n7QTc9mxvQDVJtQtWV7qWUlG+zycgUowvoUcNu0zQLa6mkhuFHGxPsZonHOXIV0KS43U1X0O6vbm1El1JG6MMrw8xRFmLYB6UN/Zbk29kTNhWJBwBnagN92lskhdAsxdsrwkYzR4Sx94ULgMOYoTrFkZ7iLu1hkjU8TDrTjV7GqvZU0KUQQqIbJ+FzniFaEHiXcD3EVDbwrDEFiThHlmpS6ggHPF5USdvQ5NN6QH17spZa4YDIgVo24vAMZ99GLLS0tIVht4EiRRjarFrI6sQq8QPSrccpZyrLwnpUOT6MJzktIbaw9yhBxknO1R3MpSUcBHLeluTMOQ8PpUBixCH60kTFX8mNkkaQ5Y1LaIxbIOFHP1qCpUmZE4VA99M0ktUizMyrgMAQTio52CKUC+EjbFVmZmOWOTSZJ6miiVjobwjOa4qDzFPrqZpZHInEmOVco4VAHSukkCEAg71IpwQaQ7AXaKDUbqwlitO5VGHi4xkkV5/YuIF7lsB4zg42r0XtJqM1lbEQW0lxLJsAo5V5p+xNXnnZlsJl4mycjFdGKXHs1xTcHYXjuluJ1hUjfzoDrnYzUTdT6ikkcca4KcLZJNa3RuxF3tNLIqseY8q0NvoK27Lx3EzMpzw52pvKl0XLMpKhvZuC5fRLYasEklCjmKMAADAAA8hTDEC6sSfDyHSq2p6lb6dAZJ29yjmaw7Zj2Zjt3eaZDAYZLVZbjGeJR7PvrIdnI5Te/WIbD65Gp3XyrVTXt1rRltraG1VZB9/HFitFoWl29hAO6txFIRhiDzNaXxVA1Rxs4dWtIhf2ndqNxETypJNOityI7WwiaMDmau6heLZw8b4yThffVSB9SdCxktiCcjG+BUJsa0ef9iLZrr6N+y0aIjH9mWvtdPsl61sIUMSoucMBjY0A+jLA+j7sqVYqf2Va5/8AJWteFgWUMjl1+9xLT5ao1UqSI47eN0JaYK34QpYmpPqbGItEjMRzyCKIWljbzF3t5nB6DkQaqXC3MMi/WVdo1O2dx86mzJZLdJgzUbR3tmVlZZB4kOOo5VC84ewWYEosgxkj2T1o9d3ZngVREixjlg7igcEfcXk0DpmN/tYw24P4hTTNIyfkoWmmZ71ZpmaNv8J9mo/pcdu1ksckUyuvg4icgEdaSK3XhHdCNR0QHFSjTHS9RklAinXJJ3ww9PdQ5WLJNPtlSaz752hUCQtldqlstOuxYniUNJCSjLnfb/lijFv3kEoSJoHP+ThNCtSNxaau/ilENwuR5cQ/5UrvRHuSckkUy0hJHDj4VEQRnIo/pdjFcL3krFv4R/OrF7JpscbROgyNtl3FPkae/UuKVmYA2qa3hknkCRKWY+Vc4QP4CSvTIqe2uJbct3B4S1UaybrQUg0JwoaSbhfoFHKi1s5EXBIGLLsTjnVGwuLhk4rksVHl1q99YYrxJGcetZO/J52Tk3UtkUyITmMcPpjFLDDxqSTg1DLcTM2eFCPLrTlmIA2ANIdSqiZInR9xkU824L5B28qrNNITuxp/10Rp4+Y/OkS4zLDW6keHY10aGMEuwxVa51SC2hRpOIyyexCgy7H0H86oCKfUXDaoTHb9LWNtj/nPX3DaijP5PRYfUpLx2h0lQ+NmuH/dr7vxH3bVNaafFZs1xKzT3JHjmk3b3DyHoKsSEQ2w7hFAQeFQMACoReCeEhRhiMb0AoNlxXVscJBzTqrWcCwRk8XETvmnm4QNjNAuO9E1dUEtzHEAXYYNN+uQ8JIcbUUHCX0VdcaBIU79VPE4XfoM15jYMmp9sZbwwyPbmY4Ea5wq7A+7NartvqZNjLLbcBS3AJ4jgknoKp9gIlEc0w3EarAGHU+035mtI6VmyjSVlPtNfftPtRoemrESkL986eeOVWZkGrdobGEjae5a4kXySMYH55qho063XbjW9R4T3NrEY1PkeX9aIdkJDJrF5dgBhDGtumfM+Jv1pvQ3G/xNhOoWQjGPQViZFGofSDEhPgg4V38wC39K2sh48kDfrWJ7JKbnX727P4nYH3nhH6GlErxRuXjMOcOM+QNQ9TU0LLk8eCfM0pQNkgqvpmoBOuzlaMJwsAfXHKrlsSy8XGGB5YqhwnIwD76sI3BEUUeIdaGRON9FzIpRVKFH4s7j1xVxQQNzk0jGSodXV1dSJOrq6uoA6mSuI4mdjhVBJNPoN2vufqvZy9cZyU4R7ztTStgA/o3/ALWus6mxLNd3ZwT+FRgVr7QYgA9T+tZr6NIRF2XiwNmkdvzx/KtPF4Sy+uauf5MbHSMqIzOQFAySeQrwT6T+16andNFakLZQtwpgbyv51sfpY7Vra20mlWsvCxGbmQH2V/D7zXiOnRy6rcyX0yFLZDwQIR06tW+HHW32a44eQJqvHwvNNzxmoNHgPc9+w5+z6nqavavbnVNQWyhOIYyGnYeX4avdyOLhQARoOEAVrldPib4sd/IpEHFUNTGLVvWtHYaa9/ddxHJFE3CW4pW4Rt60C1iMqioeed6zi9mslo7s0eK1kHkcUuhJjUrhepH86Z2XYd7dQfeBDfCrmnoIdcKnbjyv86mT7HBaTNHCnFtgDPlWX7QWhOuaFFjb62PlzrYwJjFAO2aPFd6JcRMEdbtV4iMgZ61F6aOnj0y92pubfSe0FneNIMthZl/Cp2yfnWltb+wlYLHe2zE9BKv9a8y7eXMc9/8AUrZy8EBzJIecsnUn3chUWmdmYh2T1HtFqkf9liXu7SPl3kh2DH0FTCopRfZWfM1kbj0D+1rSXmvTC2XLKxR2PIYO35Gher3c7zqJ2bvBEsbFdg2ORqWzmWGJVB36nPOqWpTfWJRw74612NJKzxpZZSloriRx7Ltn13qeF2kDcakqOZA5VXVT8a1v0ZyRL2ts7W6iWa1vSbaaNhkMrVz5JUrN8Mt0wl9HNzdWWrKLIs7ncwhsd6vUL/GOlfRVkkeqaclwD3iOuFkAwfVWHQjqK8S7TdkLnsfrMdza8bWBk4oJuqEb8JPnXv8A2Llt9S0eLUIAENygMyDkX6n31yTak7PYyyePFGSMl2Y0+Sx1C6t3TeJ+n3ozyP8A8+VV9d0r6pqEl1CmVccMyj7ydG94rdvaLDqCy4ww8OR1FP1exEiCVFHEvP1FRbTsiOdckn0zxLshqRttTu9Gu2+1t3JhbpJEdwR7s1tyMrkVU1XsfDPqaXKKyKwwJE9uFuYYeYzzHkamdZ9PAi1ILGw2EnJH9QenuNarIpM1VR0R3L9xLa3HSKZWPuzg1b1mG41FiY+Id0coiHGfPJ9aqXaie1kVGB4l2IORmrGs6zDZaDDPIHeZ4s9zEcFiOZY9FzQ4ttUaQ3KkrbB9zYaetg9xfXdraQAeIjGR6Fm61grzXuzMbm30e8uJ7onKkqTGcdMnFYntLfXOt3byXb8KhiUiTZFHoP50ItVYTI1tGzshzkbCto4oR32zk9R6vJF8W9Hqr6zp+nTmW7vZLZbuBWgZULKzKcjOOVaG7urPXbMTW91bXkigMGt5AWVsdV5ivHNdumfSbSKdftIJnCrnfgIyPkc0CWYJcCWF2jlBDBlPCwpywp7fZjD1ri6W0e8WgE1ujjqKznasNDeaXIikhJiW92N6KdirwX2ltk8To2594z/WndoIFklVT92GVv8A01HKrOhJTSZme00PH2KaUc7e+dfg2386oadDixtSR9wUeljF79HOqvz+1Mg+HCaqW8PBZwDyRf0q4y8fswzw/F/oiSJAWDhuW2POugi+zb31bZATmpLaPNtnzJq7M0gNpaYnuBjk2Ku39qJ7U7biqekSCTUtSj6pICPlR6JcryqnphFJxBumxi9sO5lP2qeHPkehqoVkhdkPhljbiHvFEeA2V+HUfZvsav6vYfWbb6zAMzRjJx95aaZnKFr9o9g+gvVVvdFvrbiBaOYSheoDjf8AMGvTq+cPoF1M2XbaW0c/Z3sBUZ6MNx/Ovo6ufL+TZwTVMjmBBDruV6eYobrCTy9xJCwMKnLjPOitAtZvja3aW4UdzJhmY9N6zQQu9EUtjO8sLKhIViG9BV+bTLeS0IkQceM8Wc4PxoXezy/ZMCQA4JxROeC5ubdMyIRzKcOM+8mqNZXStgPsnGkl/dF1Vio2yvLfpWtrPaVod1aTvI133YPSIZz78ij8aFECl2cj7zczQyZtN2hTQ63jWOZ5VUAtKVOOvKiJqlb+Nwo5Bi5/lSJRbxSU402gaEIpjnCn3U81U1KXuLSVgCW4TwgedNFIfYriJj+Js1512kfj1u7P8WPkK3vZ8ynR7driQySMpYsffXnOpuZL+5fzkb9acezTEvky32Uj73XrbyUlvkK9KrA9ho+LWHf8EZrescKT5ClLsnN+R5R2mk7/AF68YH7/AA/Ko7SLvAF+8OR/lUd4e81C4cbhpGP50QsItwavo64KkX7C3x0o1BHwioLWPYHFXlXAqWzVHV1PxSYpBY00PvVypoiRVW5XKmgZmNW4jp626bPO/Bt5daxOoIto8/CNkJVa9GjtjJctI3sxjC+81i9WtDLqRjA8PGWatIswa2V9JiENhGGzksWOM8yKtMFzzfHxqaGFhF4RvxdfdXSLIM+z8qqySsQgO3H+dRrwktsx39amYODklagLMgkYlQBvypgwfEEm1OeQhisYEY58+ZoxbaaJ7czSyLbWwOA8mfEfJR1oZpaubXvDjMrFzt51a7QRmKS0lVme2ZBwZOeHzHzqiSW4stImZRIkk5H3mbhHyH9aWLTdKDZgtYUOMEAnf5mnQXlikS/2iJM9CwBqwrxuAY5EYeYINMgrSaPYSoVe2UqeY4j/AFofcdk9KfPDHJEf4HP86MsAOQwfTaoy7qc8WfQimGjLz9jIwT9XuyB5Ov8AMUOuey15BusYmHnGd/lW4E+/jQj3binrKjnwsD6UxcUeXT2rW7FZI2Q+TDFXdM2Eg9K9BmjjlQrKiuvkwzQ2bQ7RstAphYj7vL5UhcQdHZxFEOCDgcqHpbxTancEDMcYCj1NHp7eS1tyxUuEXmozmo+xcFqs8Emq5EUjGR6XRQR7P9lLnVWDW0BWLq52FbrSOzl9pSrbQ29pLGx8UrLkioNX7ZQW0a2ehRhYwMceMAe4U/Qe19raaewv5JHuMk79ayfJhbYT12W1021itZ7WF3m2DAAYPnVBbmGIIinic7Ko61he2OuT6pcpPxFAG8C55CrXZTVRb3Fvc3QMgU9aajSNIZOC12es6ZE1vahpyqlt8eVQ6/GjaZLIgQSY8DDzrH9ue1VtdaJLDp7uJGGS3LFedWuu6hMqW0l/IYQPZJqVBvZnbbs9X0vQrWytPr+s3JMhGfbwB/Wr+hQaHePJeWMS8Z8JLn+VeSXN/czRqkt3JIq8gSKiiuJlHDBcOhbbCtjNVwvyB6Jr/exaj3FlPaPGPE2WClfeazt9rQtpXhvLGC6PRlkyKitez2p2yx3FzZG4VxxANKBkfzoZq1/BcOEWzgtCpwSh3FUkVzdVZWF68N8txbpwYbIGeXpXp/Y2WTWtLmu5QFaJuArzztXkkwVZFw7MuederfRIwbQdTUHOJB+lE+geSUVorXt7b6fBI0jDjyTw9TQbQ7+fVb9jO5VE3VV5UP7WZXUZBud6g7NapHY3DLP4VbbPlWvHRvHNbSfRtb9BPZzRB+HKnxZ5V4zqNxdRyy2skzMisdicg1s+2muL3H1WxkyG3Z1NedSsxk4mYknqaIKhZ8ibpBbszplxqN8fq6ghASc1orHTr9rtoYogjDYljQrspez6PN9YdH7mTYHoaIT61O999aExVs5wDtSk9kLikr7C979as5YFuoo0hi3DLzJpn/SKWcyQ3AxAwwCDvQbVdVk1GZWmlOAuwBqmpTbxtn3mpB5afx6CM15K0QhOJIgfCSd6HzgtbsQoAG/OnDg28bfM0oVGhbxNyPU0GbdlmEsyA4B286nXi4lyBnPnUekwG87mKAOZHwABmvQbD6Pi0am+u+7bnhTnFJyS7C6IOyHZmLWYmmlaRAmxA5GtbY9motLuBJbzyofINtTtD0m60G1ljtJDdxk5UZ3pjdopbWYQ6lprxMx8LDcH41i229GfJt0gyHZjgqcfi6UzxG4yzeADZaHr2hWXKtbMig7YPOiUD9/EHKFc8gedJprsvjKP5ImCh48oQ3uPKg+tBbu2ltY07yf8PLFFYI0tizRjhzuTQy81G3huQ8cLzXDbZRenqaS/Qo3eiPTHfT7GOO7iEZG3hOc1dW7Z34Uhlx+IilW5Dpkx8TD7uNxT7e6MxIaJ48beKmUOEKnJZQSeZpqQJGxZFAJ5mputcaVitjcUlWrUjBAXJ6mkkt24yVAxSI57piWwkCsyYx69aRJeGUtJnPKnpFLwe1j0psUYZnD+0KRNp22LJcM+yjGakSE90VZjv08qp8XA/MZBqybkRRB5icE9F5UwnGloYbV98Y/rSx27MDnapFuQ5HdqWHnT55GRQQAaWxcpdFKRCjYapbeEuwLDw104kYrxgb8quIBHGMnlQ2OU3xI5oA+OHAxVWWJoz4qIKwbcHNc4Ur4sY9aVmcZtaBZ58qSpZ+Ev4OVRmqOlOxrYAyRnFVHknnYJGnDH1djVzPupkrogy7hQPWmikWLWYQxcDZPrQ65luo5Wd2jaDzbYiop9UtYkLCTiPkKijvor+B48AE/d5mqUX2VHFT5UUNY7T2Vlwo6yOW6rtUFlcaTqitM0sk38DjlVS80eVpC8kOVXcE+VQ6exsCxtgFDc9tq1UFWjoji8xYd07S7MXC3cFuOMcjxbiiRvoVkWKfMLscKH2zVOx1C2CAyzDvDz2wKj12Nb6BBHG0hByrL0qGrezNwblsMNGjMrMA2OVc8QJ2wB5AVBpFtPHYL3zZboM5NWzFL0U491Q9MybSdWed/Rk/B9HXZfhCg/sq13/wDcrWy0+eYZ4Az529nirIfRfHE/0edlu9coP2Va7gZx9itayFLdG/2t8fwKQaPBbpxo0tsv2YZkCuee2DUjosiFXAKnmKq2GEtwTI7g7gyc6e12qnGM+41mcLi29EMWn20LvxAMG5BulU9UsYreFbuBMmBuNl55Tkw+VXZ51kHsnPnTUR3RlJIVhinsupVbZZWK3eFcIhjIBG3SqWoxQpZsLcBHjPGoXzFVtLN4IZbNnjZ7duHJyMqfZPy/SmzTTW7lLiNTnyPOighDl5IBcyxMJI8mNvEpI6VBq97Jc2ZJTLxkOu/UVDBcuBLanARTxKP4T/zp3CW2AzVnYoJ7aFtbl0Cy27lQwyKS6aS5l45CM1V09WQzW2P3Ryo/hO4/nVoEYoLVXZGIc7Zp4t2LBRnJ232orp0kEKhhEzuebYqzPPHP4TFj1IpcmZvLK6obYafNEMm4GPIbiryyAEo+3rUFtL3EXAq5HSmmQs5ZutS9nM1KTdi4RSTuTTOtJjfNU7rVI7aQwQobi7I2hj3I9SeQHvoK6LcjLGpd2CqNyScAUME02qvwacFjg5G7kGx/yDr7+VLHp0t24l1ZxIAcrbp+7X3/AIj79qLRgeyMKANs0+gYyx0pLQkqxeRhh5nOXb4/yFTTIqNwpnak7xgvCG2pZJsxYA8WOdSQlJMYWCqeIkVF9injUgE+tVJZnYFXwamht1CgvuT0pmvGuy2HcJgMarl5iSO7qCbv0bhhJK8/dSJdyKCHy/kDtigaj9DLsnGGUg+VdbWgnjyG4WHMUyWSWZxjf0Ap8c7W0b8aEDhO5plO0tGS7dz2sIjskbjYyCWXB5Ko/rRLQO90rsnLLOhRlRpyX6lhn49KyfaT/rftbDaWxCqvBACBkfiY0V7e6vc2+gTWUuHaUiNGUY2rTwkZKLeyj2aJtux17ezNh76cjPpWs7E2/caDFIRh7hmmb4nb8qyuso1t2e0TSUiZZJFGR1y3/wBa9DtYltrWOFRhY1Cj4ClJlRK+sXLWmmXU4b2YzgHzoR2KhEVrKT7ZKp8hk/masdp50e0htzgJPKAx8lG5/SrejDu9MgWNMvJlz7yc1PgdbCdTRyxgHjAL9M9apvDNzDgt5ZrkYqn2yji86kHFMuiQvkM23lyp8MPEuxO3UnNVWnUqMsNvIVLG54cByBQZuLrRZXjDYaUAVbHKhqZB4sZxU6TO33gPfSaMpRLddTUzwjJBPnTqRkdXV1dTA6sp9JDkdnuEfelQfnWrrJ/SSM6Ap8pl/Wrx/khx7LvYVeHsrYeqsf8A1Gu7Za5FoWlNcMA1y/ghTzb+lL2NZY+ydizEBVjJJ/4jXnGtPc9tO2K2luWECHhDdI0HtN76aVybZcY29mOv7K41C3l1K9JMUk3dxcX/ALRMef8AwqNz8qG9obtdMsYrS1HFcyDgjA5++tn27vLS11MwQHu9O0eHukXpxkZY+/8Aqa890aOTUryXVrwbHaFT90V3Rlwhzffg3iubo63tk0rTvtDmZzlierHpUyQcEQB59ffQ6C6/bPaWRIzm0seZ6NJ/yrQSJXPLTo64bVroGd1vnrQfWQWuVB3OMmtBJjjxQa6Tvbp26DakmElaAWiyiDtcsR5SwkH35o7q0Zt76OcfdIf5Vi9YuTp/a21lUgEMqn4ivQ7vgv8ATobqMZB2b06EUS0yMW7j9BTSbqO9tUmi9lsj3Yqr2xtjPpcJXGUmUgnpnas7caqezv1Z0QvDI3DIg2z6j1rW21/Za7pRe1kWVNiy9VIPIjpWbTS5HVCavizzhbY3DxqdjIwUn1zg17N9Ieht/wDcsubSxjJSzhSTYdFxk0b1Hsjp+raItpDEls64lt5o1A4Cd/iK1nZO3Godm7rStYiAujGYJx0dSMBgeoNc0JPmpGnrJQ4conxfbo8xwu5ohplmJoGd+aHDVqtatrDsdq0uhXui4voZ/FfvMx44ifCVXlyojpPZYHWTMSY9Fuj++YZCN5H311SyUtnlRx29FLsbo2kG5h1LtDbyz6MrBWaGRRhjyLLniK+6t9qDdir7t92ZtOzNqBfpdIWlt14IuAdCDzPrVa97A2l1e2Vto8qTGE99LwHKADpmqX0P6eNR+mCefu+GOwV3x5EeEfnWM3FRcmt//SnGUdqWj6H1DSbG7haC6t45YmIJVxkZFS2trBaRCO1iSKMfdQYFTytlqZmsaSEpSapsgvYe8TiHMU6H7SEA+WDUuxpiLwMccjQVy1RTlswjZAyp/Kq9xbHhKyIHjPMEZFGRgjekwOR5UqLjmkuzGX3ZnS70A9wbdx9+2cxH8tqxP0iaRqkWmWukaHaXE9tLJmWYniZj0Uny99exvbxMfZx7qQWygjBqlJx6OjF6pQlyas+ce0fY+Hsl2QuNT1EifVJcRRL9yIt1HmfWvMrS4WIAFthXuX/2n5lttJ0ezj272ZpWHngf868Dls3zAu+ZBmu3D/lxTfbOP1E3nfITW72O5jRE3ZTnNCg5I4XGR+Yq9PYOmds1f0DshrvaAO2jaZcXUaHDOoAUHyyds1WTOl8pOjnjjfSNh2HvotCs4rzUJ8abeRhEk4SeGVDupA5bGiXaLtMia3ax6f3V3BPauGCnPED+E+dE/ol0M33Y3XdI1a3ZW79oiki4aNuH15HOK8nuLOWyvLm2fKz2zshPqKwhKLs9PFKa4o9Q0YcP0XMzD/aAQM+pAH6VDKnCoA5AYq1BD9V7JaLZKzSQzhZgSc8JG7D51FKuTU4ur+zo9QtpfRBjCk+QqW3HDbAnkBmqmo3C21uoJzJKwjjXzJqbXJhp2iXMp+5GQPfyreO2kcrdJv6Md2WvOLtNdDI4Z2cfnt+leg6f3ccuZYhIv4ScV4zod0bbVLeYnZXBNeyQsMq6nKsKue2Zenlyi0OvLMXELBRvzHpTtCmJzbybOnLNXohtVHUIGt51u4dt/FihGsl5K12H7N9oNP1m24hFDOsjY6DPiHyr6ls7mO8tIbmBg0MqB0I6gjIr56VLbWNNaOQAo44WHka9N+h7UJG7PNpF2xNzprd2CfvRH2T/ACrLKvJxeoh/qRvqp6lDHJD441Y5AyR0zVyhmvXDwQQ8GMvKq5IrFHPHs6ELZH2AbcnY4yY/T3URGCARuKjhAaIhgCDzqvwvat4D9l0zyHv8vfQDLlIajEyj95mM/wAXL505nVRksoHvpgNlcRxk8z0HmahsE4bZSfaYlifXNPwX4pGGFA8IP606AcMKD0oGPNNp1NZgqlmOAKBjJGCKWbkKoahEz2czPs7rwqPwg1dCmRg7ghR7Kn9TUV9usa/icCmNM6KIWunLGOUcePyryuY8UjN5kmvUtXfu9MumzyjavKifDRE3weWazsBH9peS+gWtXfP3dnO/4UJ/KgHYOPh06Z8e1Jj5CinaOXutFu268BHzpPsie5nmUC5bPU70e06PIFCrJCWANaOwjwBVs7UX4EwtTimxjan4qSrErqWuxSAaeVRSrlampCM0DKiRBYm265rOyWHFNLKV3c/lWrZcqR51WkhABqkxUZeS1CIcjrQu6iVScq351qbxAqHHnWdvs8R8Q+VUmRJAiXgJ9lvkaG6iwS1mwpyxCr7zRObi4j4hj3ULu8yahbwZBwe8bby5VaM2WUjWNEQRthQByq1HZy6xGmlQsYu8k4lcj2dt/nURLfiGfdVjSbprLUre4LjCOCdulOxPo83u7Vra9ngm3aNyhz5iuhLI32MrxN5qa1f0n6b9Q7TSXEK5trtRKjdDnnWQzg561qnaMwrba3qdpjjfv4x0POjdj2ntbjCzZik8jWWjnBOGwDUkkEUwyyj3iigo3SyxzKDG6sPQ1DKM78iORrERrdWbcVrOSv4WNFLTtCeIJeoVPmevxooDQC5lj+9xL5NvViDUI22kBQ/MfOhq3EUykxMD6daglcHkcGgDSq4YZUgjzBqGa3jk3ZcN5jY1mo7mSByVZl/yn+VELfVzgCXDjzGx+VAFt7V0IKeNfTnVSYEuBg5olBdwygd24yeh2qSSNJT41Geh60qAz+rN4VHkRVrSWzZpg/eNO1DTpG3jPGMg4Oxptgnd2/DuMPSF5JL4D6nLt901nNPYi5XCDl1IrR3h/sso/hNZSxcfW0+0I286VhYcbiwTwfmK6OSQH2NxyORTA64/en503vVyFEn50wsvXGpXFzbIkjyuV28b7D3CqQLEZKj51GCoH7wnfzqRWQLjjPzoAkMsrKqE+EHlmvUPogJOn6shAHiU8/Q15YWTbxnn516d9DhBj1ZQxOyHf41E+iZ9Gd7YArqEnvrJT779a2XbZQL6THPNY2U459K6I9FFG5ORvQifZtt6LXe4260KmHixjJpiYb7Np9ekVLu97qGLdUJ51fuwomYQY4ByyaydkcXUecjxCtIChPtPn41nLsrlaoUcXejIXOPM1MofqF+Zqv4e9XduXrVlEUkBeMn41IIegcnPh+dSQq5UA8PDnfnSLEAcEOD8au2lnH3ZaRmHPbelZSRb7PXtxokhe07tjuFLb4o/Y6xe3she8uiXPJRsKymnWp47hVR2AfbnRuCyXulmPErKw23qXRcVuz0vTb+CzsUM0/CxG/FVe/1FNYZbSzIfG7MRyrE3V19cdPrEUvdJgbAitho1vBYWff6YFk7wb8bcqzaS2RJJPki7HpP1bEkbh5AOTcqguLzVSCbe2UkcwasxxzyQNPeOePGQqHYU+1uZVtw0seF6Y3Jov7Dk2t7I9Nlv52b9oQrGmNgKJKqgjhVR64pqyCVTwMOLHI9KW1R3AWVl4uuKlkNk00UWA2R3g6jrVURyGYO2AgGw61ZuntYIyZZUj9S1DItatp7pLK2DzsRkuo2WkiIt0XyaSnMMcqqSXHDMIgpLnlQWgqJY4UABB91RG6bi9kY8qfbxhEBdfH1rrhYuAscKfOkYrjY1pZJI3ZPCAPnQJ9Zt45CrycLj1o1bTx92ULAGvM+1EJXUp1h2BORWuOKk6Z1YIKTcWgvddpityUiC5HIt1q/2d1y+1yeW1eAIic5BWR0bs++qPx3FwkZTz5mvROzmmxaVEyRkyO/M1WTilRWdRUethqCJY1AGM43NSEAjcVwpk+e7bBwa5zz+2JMnGmF5inOvFGVPPFRWrKUJHPrSSXcKNwlst5CgqndIrF5IG4eROw8qsSiTuPE2T6VXuH74+IbDlThO3dlSM7YzVGri3TISKjkOCBxgZ86kBqCYhWLd0XI5Ypo2Q4wqQclsnrQp7CeK5D8XfxE7hqIRzSzrxKnd4O4arAPnTtotScSu9rBJFwtCoHliqttYWsc5aFWBXrnar0rFFZsDYdaD22rH7VZF4iPZKjamrZUVJrR2t6kqK1tGOJuRPlQSxiLzAvGzxj2sUefTobyESFGjkO59av2NrHBbiMDY888605qKpGqyRhGkDoLPTJV4lPLnk8qsQ3ttAe4tQXx0FEVSJF4Vij4OoxzqldaRaTN3kHHDJnJ4eVRyT7Meab+RRntNUubyO4t53iCtkx52I8jWiWedFCswJA3qGEGFAqMeW586cAOpqW7M5/J7R5/9HNtLH9G/ZN8Eo+k2hyP9ylaUW0sTqWjYqeq74rO/RXqUy9gOyqoodRpNovAfSFK2sqNOQ4Zom5kCi2i05JJMiGnXQl4ndWixnxE4qePij8It49+bKamUgrglsilcBSMVNmdt9jTsd6cpOcA12S22ATSYwfWkBVvT9Vv7e6GyP9jLv0PI/Ord3bx3EiAtgDmetQ3kIubaSF+TjHuqLTLhp7Md7++Q93Jn8Q6/zpkqNO0V9UgtraSKYAqqngfrkHr86dbKgfKsSfLFWriJZ4XjcZVhiq+m/wCzhWyJEPAw9R1o8GidKivqMZiuoJ0IRXPdSEDoeR+dTPaFQuFUqDuRzNT3cIuLaSI7cQxkdDTbCUz2sbk+MDhb3jY07GpNFnvAAoCYpccXlSCnDOc4qSRNxyqOe5itYWluXWNBzZjVObUmlmaDTIxcTKcM5OI4/eep9BXW+nL9YE97Ibq4HslhhU/yr09/OmIiMl7qR+x47OzP32H2sg9B90ep3q9Z2cFnFwW6BATknmWPmT1NTkb5NczY5b0WFENzdx2vD3xI4uRxtQ641YpcosDK8Z5+lGEfMY4lXPrvUF2/FIixcHLoBSKj3tEryBEBwSSNgOZp3EAgLbD1pI14FAzn1pk7yKDwqGTFBNEamMzHCceeRFTP3v3OED86p20ojc5Gx/KnzzLxhomOetBbi7LJPdpk5PmagaeBgQVx64rjc5i5rxHpVNovv8JwetA4x+y4lxEgwoPvqnqs0UkJaY4gjRpGB64FNHlWT7f3UkGnsEfhDYjIBxnP/wBKpK2EorsFfR7Et32hluZshFVsHyZv+VXO3KNe9qNI0yEcWW7wjz3q19HllGmjLdlR30rk58hyFVtDkbUu32o6gx4o7KMqpPIY2/rVeSapFqDvtT7fRq4Bjs14uEnOMDb9a34LHyxWL+jyM3Eup6pIDxTylV9w3rZk4G5qZdiMxrS/WtYEAOQiBfcznH6ZrTqirGEUbKMD0rNaMPrmrzXHNeNpPl4V/ma01JgRoHBPEu3SleNWOWzj0qQMeHh2FMfiC7HJpAOCgDAAp0MLE+FiQDnlVfvnU4IBNWreZWwGjKk/eFBMrSCEUYxllAJ508xqVxwjFJGpVd2zUmKk5G9jVUKMDlS0tdSFYldXV1MR1Z3t9CZuzNzgboVf5GtHVLWYBc6VdwMcB42GT7qqLppjT2YWw1YRdgzluFYFfvCD5HYfEmrfYnTxoHZW51e9GLu4jM7k/dXGVH8/jWS7PSHVZo+zfB7Vys87AbFF5g/EVqvpo1f9j9iZo4R9rcssCKPX/lW8l8uP2aPWjwjW7qXWtUSwDkqzme5bzJOcVF221RNF0MxW+Flcd3GB09avaHZDT7OS5uT9vJ43Y9K857SXMuu67FGMmMuEUe81s52+fhdHS1wjx8s2X0fWP1TQUlf95cEyMTz9KP3DhI2c9KS1jW3to4k2VFCgegofq1wBwxA+prCP7OpfFUQpNu7HoCaZaxcScR5neq6t9i/8RxRJcRW5c7BVyafbouCvZ5jrdt+1O19taruZbsRjHkMCvUr2y/YmpyWb/wCxTHuwxPsyY2+f615l2fuUXt3odzOQEN0srE9OJ6+lO0OjQ3un3/exq5ZnUjqQTsR6jYiss8nHIvqiPSNS5LyeG9s7N5I7UKhbgkPEB5YqX6O7GKPt9a2hdhBewuqsp3DAZHvo/HFIl5DBqAH1i2lUSH8anbiHoRQW3hfQu3GnZ2+pXylT5xMcfzpOXKLX6NZw4/M+jtPhNtaRQu3EY1C8WOeKIQTmFgyHBHWmXERTOOXSqckvDgDdvKuVGlLIjHfTZoFp2m0pbj6rNHqlsuYrmGPjDDqjgbgeRxtWF+jntpPoGktpWp6TPeQZwYZYGPyIFe1CbA5700XC5J299aOcvFEr0+Nqmn/szEydr767spLTst2SurRZhh5FjwT/AMTYxRj6IOzV9oE2q6hq1rDDdXxXgVH4iijofXNaNbsAbk+6rtvMSPFzPTyqZSlJJOkv0jKWCMU0l/y7CwbJzTs1VjfIqZTSs5nGiQHNLSKKUjHOgkUGuJpmaQmix0PzXBgCKjJqKR8UDUbPGP8A7TJthqnZx75JZLYcfeJEwVyNuRPI1lJuyP1+/wBEudPjlgsLiI939YILZ8iRtXo30wdmr/tK2m3dlHFP9R4uKAnheQHyJ2+FDOzPaXRn04dnu0yTWpibMTupSSE+WOo9Rmuhy5Uo/RaxyhG2rR5l2v0GTQAEkh4pp28AIPiPuq8vbrVex0cS6Tp9lYJJHwyWoDNG7/4nCTsfdW/7Zf8ARfTdGmvEvpNTvUXMbOSSvz5ViPoy7HX/ANIvahdU1VHXRrZgWZhtJjki+fqacp+1HlJf0vLMpxjNfo9d7HW+qXPY+01bWyG1C+zO5CBMA+yMD0r597X93N211eSDBjaY79M4Gfzr6x7YRSTaMdN0+ZbXjUIZFXJjX+EeeKxWn9j9G0+zNvFYxSZGHklXjZz5kmsebjGntvs7/QJVyn14PM4OJLKzhLZjiiBX0Lbmh+r6tZ6ZCZLqVQeiA5ZvhW07YaNpvZ/s3dzxwHjC8MYLndzsOteGXmjnhRIopbm9k54yx9a6MNcbkV6tycvhts0HZ67Ov63bXMqYVCzKvMKByqP6T9WVUj06NvEx45APLoKk7HsmhdnLzU75TGIwVAbYk55fOvPNQuZ9Ru5L25OZJjxe4dBW2Pbc/wDg8/NJxgoefI61YtxeYGa9d7JXgv8ARIGJy6Dgb4V5Jpq8Tyf5TWz+jS94L+azc+GVeJfeKp/Zl6eXGX9nptm+Rwt7Qq4UWSMqwyDtiqAQghl5iiELBlBHKpPQaoCi4fRNSiZsmzmYI/8ACehredn9T/ZOqw3yeJMcEoB9pD/TnWT1W2+sWzptxc1J6HpRDTyyWFpMd4J0JXHJXGzp8Dv7jQ96ZjNLp+T6BglSeFJYmDxuAysOoNUdagM4tsYwsoJzWM+jnXwsraVcvt7UBPl1Fbu+O0Q83FczXF0ee4uEqJIPYPvqQ7jemQewffT6RJDwNF+7HFH1Q9Pd/SuiMLnwKoYcwRgipqa8aP7aq3vGaBDZziJz6VwwkY4iAAOtU9TW2gt+KVeEMQuRnG/uq0kEQAKovvO/60yhpmDbRKX9eQ+dcsZ4g0h4m6eQ91TUhoAQ1VuBxXFup/EW+Qq0aqseK/UfhQn5mgpFLtRJ3eh3R814fnXmcpwtehdtX4dFK/idRXnjb5zypx6OnB+J6J2Mj7vQYSfvEtSdsn4dFkX8bKPzq/ocfdaRaJ/4YNB+27/2W3jz7UmfkKldmUdzM1p6ZI2rRWiYUUI0+PlR63XCiqZ2kyjAp1KBXYoCxKTFLXUDG12KdSYpANqGbYVOaq3JwDTGB9QYcLZrL6gylj4CfhR+/k2ffyrO3pJY4cfKrREgceE/3R+VULXhl1C7l4NkxGNvnV64cxxu5kACjPKqelRlLYFmAZ/tDt51RmWfByWI/IU2QDgb7M/IU4ZwcyD5CmSZ4T9qPkKADjQRdqezg0u4IS/txxWzn7w/DXk97bz2VzJBOhWRG4WB6VtLl5IYBJFOUdcMCuxBqe9ksu1EC/WXjt9YUY4zsk/v8jVKVENUeeE705J3jPhO3lV7UdMltZikisjg8jyPuoa8cik5GwrSyGXRqMZ/eIQfTeue+tWXhcFlPThoTID1plFi5MJ96Yjx2cjcP4SeXuq9Y6oJ8pNlZP1oGknCKY0p75WUeKnYWappN6jLZ5E02zjnuYVaON2HnjAqyunXPM8Az5tSsY2OcqB1xV631aSLqWHk39ag/ZlwBkBD7mqtNaXCg8UL48wM0WgNAuswPGxc8BAzuaodn7gXXePJcbMxYKSPOgsicQ4CrY5cjV3TtPha1YhmUhsDBotAaW4tmeB+7ZXyDyrJQxT294izQsjb7NROGG8tSTbT8YH3WqxFraleC8iUr+IbilSYFdmbHsjPvpE48ElF9+aIGzt7scdrMRn7udqqSx9y5jkLow6E0PQEVsWCk4B386lbjJ2C/OoFAUH7Q8z1NSoUz7TH4mkArB1AyBz869L+h1j3+pqcfu1O3vrzR2GPab869H+htgdQ1IAn9yDv76mfRM+gf24UfXpNutYyQY6Zrcdux/1g/vrFOMVvHopFC5U45b0IuQQT50auvZoNcE8WANvM0xMhthm4j5e0K1CxN5KPXeh2grpPCW1MyibPhCcq0EDQwzmSKJnjzsGzWcnsuMSj3Td4uy5386v6bJJaXCylEcDoadfXEdyUKWxjxzwDXLKHi4DGQBtyNQV09BieS2uFE/d8Mp+6OVW9Igikt5JJwMA4oDCIzjiD49xrUdltOlvgUSKQ2obJ2IzUtlcvLEjtoreCU2BMs0pzspOBUUJuxIqg8EiNnxLzr03QtNtLSNmtrfuWOxBFQ9pdJW6s5ZbaNRchdiOtRz3Rl76cqAFpI2qgWssIiK+06Ls1XrKxmt7swoi/UwNyw3z6VY7OuDYIjFe9XYjGDRRiFG5AFJsbfgrSCSMkxqGQD2KrpqMiL47KVCPSr/tjwNTg+djz9aSJAyytd3aSRWgUdXJxRC6tUuI+BnkT1RsVLwhSSigE86dQ2N14BiaFZDJkV5WPMyMSan07T4NLkkktUxx8xjlUt1HK8Z7mThbHlWfsdZltb76tfEtxtgP5VSTaKUHJBjVdZhsSDchhxcjjan2+o2XAs5njOd+e9QdobaK60uQTAEL4lJrBjCrwqAF8quGPkjbDgWRG+1HtNawwkQNxyEbAVk5NYv7lyQ7MfIDOKrabbLeXSxPII16mtrbRWNhb/ZmMKBux3NVSx6Ss04QwairZi21G7RvE7A+RolpGljVGE93OAmd1B3ohqd1o1zCS8iF+nCN6ybtwystvIShO2M1a+S+jaNzWlTNzcWeh6eUDKyseuTv8ahhuZ9P1AyQxvJYMNsb4oDA9tFbg3Mxuj+ANjhrQ2Wo2iQKrzoMj2Sc4rNxa/ZzSxOK3bD0OrWUrqiXCd433c71PPMgQrnJPlWIv7CWfUEnsosJzLZwDRQapFDHwzuplXYhN6zeNeDB+mWnEJ8hjO1NkkSMZP6VStr2G7GFJAHPNXBwOpXYjlSarspxrs5VSRhIVww5b1ITTMrGm/hUU4HIBG4pEnVFIk7uoR1CnpjnT2cgbKSahsrm5Fwe9t1CDkwNND3VoI/UysYII4vKqx251Ya6c8gBUSgyyAdT1qTOLktyKt5EJrdkJYe7rVS0hYwCO5jVB5DmaJ3EXA2G+BqCNQpZuPiDHb0ppmkXa0cYTlOByiL90dalOAN6aG91DdQhv7o8ETLDF1OdzTSvspK3TZehnjl4ij8SqcHyqdJcphcY9KBaTFJbOUkuE4M8qNIFA8GPhRJUOcUmKWG/pVWS8ZWIFtKw8wKmaM94rKwHn61J8aSolUYr6L3lX6OeygSGJf+qbTxN1+xTetmjZQbqT1K8qwP0bFj9HfZTJ/wDxTaAZ/wByta+CaaORVaPI8gKKHxuKCIpRXIxlTJAXfljBpQcVJmdXE0tJigZ3ShxBttWyP3d0N/Rx/UUQFQanbNcWZEZAmQh4z/ENxQJk9U89xqI/BOMegYf1FT2kwubaOZdg4yR5HqPnTb6FpbZin7xPGh8iKAJHbuxlvhVK2budRmhwVWYd6oI68m/lV5JYnsBdyMipjJZjgL50C1O5ur2NZ9ORo4YW4vrDjdhyPAp57dTtTQcrCt9fQ2YXvSTI+yRoOJ3PoKrrb3eo76gzW9r0tom8TD+Nv5Cp9PsYLcd5FxSSuMtM54nb4/yq5tyJ+FAPY22SKOIR28axomwVRgCldRnIyD6U/GFPCBmmPKqJl9j5UgQjbnhUnPrTgq8s70OluHdjuQPIU62kdGYqvH50F8HRJcRSGQBMkH5VHCRHOA3i6bVKLt3zxJkdcdKjuXjZwYgQR6YplK+mXnHGpHQ1zeBPCM4GwqpHd+DEi5PnVSCafv34eIJ0FIlQY9t2O2DnlUr27LEH+Y8qjkEmeN1I9cVzSsw3J+dBpvwIwA5H8qaSeWTiupGJ6CmOha84+keX6zrNpYxZLYAIHmTtXoFzIU4EUhWbPiIzgAZNeb6Dx6128e4fDpE5kJA2wNhVR+yJfRumRNF0GVuLIhh5kY5CsZ2dmax7D6resQJbuQop6nP/ANaNfSXeGDQBbqSHuXCADqOZqheWoFp2c0RBl5GEknu5/wA6a6FI3HZCz+o9nrKI7MU42953q1rlyLPSribOCFIHvO1XEAVQoGABgCsz2tnF5qGn6PE32kziSQeSCo7ZAR7LWxh0xZHGHl3+A2H8z8aMVHGqRhURgFAwF8hUlAC12Mikp3SkBGFUHljFSxTtGw2ylN5nnXMpYYBAoE6fYWRw6gruKdmh8FwsEfC439KtRXCSDI299ScsoNE4rqYkgYnHSnZzyooho6urq6gR1U9Scd2sZPCrHLHyUbmrlZXt3eta6PeMh8bqIE9Cx3NOPZUVbowXZTVILf6S5bgL3dpqDuiMRsW6YPTl+dSfTBc/tHtHYWAIaCyQzyf5zso+WauW+i2919G0txLL9Xngma5t5h91l2HvBxisTPcTzF7i+cPdzHvJmHLix09K3S5S0dWOKcuX0ZbtjeYSKwjP2lwctjog5ms1oNkH7QxsRtEpkPv5CjVtZXWu6zK9nC091cN3NvGv4R+nvqxaaRNourajDdzRzXCOI2MY8KkDJUeeM862yUo0aR+U7CryhFyeQFZ2eYzzO56mrup3BWIqDu21CozisvBtJ7otRqSyL65qTtLc/VdBumX22Xu1952p+nxcbcZ5ChHbe4Cizt84HEZnHoo/rRBXItvjjbPPL2Qx6keA7wlVBHmo/rX1d2U1qPWez2j3WcrdwgFj/ipsyn1618iw8dxd8stI2T8a9r+gzX7W2vZ+zOsNw2d3Ir20xP7mfpv0zU+ohzTaOPBl9uXJ9HoPbTRkv5FazjxfRLkNyDL+EmvNe11vPN3l/wB20c1qid6rDBG/9cV7pqljJZSZnOc+Hj5b1mdbs4JeKK5Qd1dIbd3PTPs5+NcUJOLPbTjkg0vJu+zl2ur9lNNv0Oe/t1Y+/GD+YqlKvAWJ2HL30C+ge6cdndQ0C7bN1pNy0eD+Btwa1GoRfauSNgcAVTVHD6edNxYK7945Ay4GPMZqMsxbkAeeOi+pq0IGzxMPF09KaYc+Ecup86mzvTQyAEnizsN8n9aJWzEnw/nVZIs4A2UfnV6FeEYA2pWZZGmXoDVuM1Ti5VajNI4ZoI26DGTS3CDgzUME2Bg027uBwHfYbmrVUcvGXIhY00mhtrffWTxocxnltV0NU2dTxuPY9mxVWZ+ZJqV2qlcHJ3oKhHZXmm5np0FBNY0/T9YiMeo2kNxHyy67j3HmKJXGWJGTjrVCXxbckFHfZ3Y1W0Ye4+jLQbidZIZLyFFOeAycafI16Pot1JpllHax3LNEg4VXgVAB6BQBQ+MpkiQOABsFxsemaSEkN5n16UJb5Fzgpqmv/AfMxmGXO5qPg3qG0PEQKJlUggluJzwwxIXY+QAzTpydI5ZTWJbPGvpq1AfWLHTVJ8H28gHnyUVm+zFtc2cE14beISuvCDKxDAdAABUmmXR7Vdrr/WJxmESHuQ3lyX8q3j2SIkbuOJgwrTPPi/bj4Oj02NOPuT7Z4N9LEV/ZjTNPlTurSQGVcHeRs7k/Os1NB/ZsgbgV6d/9oCNfrGg7eNUf9RWESLih4ccxXbhuUVf0eR6pL3GkUdEh7yWb0Q0zTLqSyvYLqMnjifOB1FFezdvh7kkbAcNULS37wSAdGNPwY8dI9zsJY7u1hniOUkUMPjVlPs29D+tY36M78yWMunyn7S3OV9VNbSRcqalHoQlzjZ0pDKfOtH2EtItWsdV0WVuFzi7tj+Fxsf5VjxceIqefKtB2Lvf2f2nsZ/us3dt7m2oatMzzJ8QfdTTaZdxXHCVmtZcOvLkcEV7XpmpJqVjZyKwZiQSfMEZBrBfSnpIt9TF0ijub1SrekgH8x+ld9GeqA6XCsh+0sZTC4/8ACbdT8Dmol8o2cs/nFSPVoPZPvqSo4PZPvqQ1icvkSlpK6gAX2gIMEEeDxPMoHzonVe6hSW4ti4yUYsPlVg0FeBDzpDSmkPKmAhqrEQ15OfwhVq0apWJ4++f8Uh/LahlIA9vJMWlsn4nJ+QrEAFpVUdSK1vb2Qd7apnkpY1mdOQTajbJjm4/Wmujqx6hZ6lbp3dtEn4UA/Kst2ybjurWMdATWsOwxWR7Q/a6uB+FAKlGWFfIi0+PAFGY1wKp2UeANqIKNqo6jq6n4pMUANpMU7FJQMbXU6mkYoGmNxQ7UH4c0SHWgWsS8LNQh2A7+UMsnXlQO5IJP2X5Cr11Lxd7g42ofNvn7Tf4VaIYL1Y5thEEw0rBBy+NTqoQ4EewAHSq8p73U407zwwoXztzOwqw+Q5+16elUQKxGNo/0qJsgH7P9KeMdZf0pjY4Se9/MUgKt5/sbeD7vpQaInvVPBjfntRq7x9UbEu3D5igaNiRftM78tqdiZJdXsiWzLI3Gig4V96HNHI0YeMqrMMlTyp2psW4I15u2KnMMmxAXGPxiqszBMlvcsd44z6hqiNhcMdwg+NGzE+Puf6hTe5fPNP8AVRyFSBKaaRjvJR7lFTxWsS3sSKOQLMScmr/dNyJjH/F/yqDT0LzyzZXGeEb0WJmmsDm0QeQqUb+6htlfxRRhCRkZBFWRfQ49oUFWX0wVpccI51R/aMAXY/r/AEprajERzOKAsl1BgbWQZ6VW0ZOO2lHLxVHcXccsLqpIyMcqfon7qbbqKBeQpwBVIG+1ZSMMbsKQCCxGM86122DWPXhF/vxe2eRNFgwjHFNbtx254T1XOQaL2l3Hfxd1N4JV+Y91Dcx74L/nUbYyHjLBxvneqTAuFJIXZWCk523504F8clqzJi6sFlI8a7nFUR3Y/H+dDAkfiK7hRXoP0RMRrV4pxvB099edvwcPJvzrd/RIyr2kkVc+KBuefOon0TPom7fJ/bX99YaTlW++kFQL181gJcb1tHopFG6AKHoaEXS8VGbgZU4oVcZxvVAypAPtQRzBFbJHlCgAqPhWPU4batZbhCingPIdKzmNEgSQuuXHyqwqOPvL8qhCpxDwHn5VZjCHfuj8qgtGj7GaZDqGoD66690m/By4q9YiltbWERxd3GijAGwFeVdldHj1GRi8jQ4/Dsa2cHZexU5lkmlP8TGspbZnOKk9mkju0ZieJWHThOa6a4yDjZepodZada2RJtogpPM5qW5MhjIiwCepqa2SoKwbdy8MxMeUT+EYyak00o3E8s+34Sam+qrLEBcjJHXNVl0aFpeIsRH5Z3NWqo6LjVFqbUrSDI7wEjotV4tXjnmCRxnf1qxJptm0RXu1UY9rrQrRrWH69MMcRjPhPSmlGgioNNh5TxDiwRUU0mFPt7dFqSUcSgcqo6gl0zR/U24cc88qhbIik2WllUQ8bnhwMnNY/Wr2K9nwkSoVPt+dSatDe8eZ5Q2eQBp2laOs47yeRcfhB3raKjHbOrHCONcmylcXN1PAIjNxIOlCmyCQa1J0ieSd+FFjhHs79KE30MEcxj4gzDY4860jNHRjnF6QOijeT2dh506aOSOMkyHHlmrscYGFQZJ5AVLq+kzxWYl2YDdlHMU+Wy3NJpMA8998U5HZD4TipxOqRcIiOMbk9abBazTqzxRlgDyAq7+zS/sbCUMi95nuyfFitPaW2hFeMyliN8NQWLSb4SJi3bn97lW/0iytIbdGnhhWYjDAAYrLJNI4/U5VFa/8AOLV4p3NrYlUQDAZuXwqleaBcpH3kT94r7tjajWpaXpn1pWiiKSMf7s4zVwgwwBYl4iBsCcVnzr8TFZKpw0ZjTAtlOyXEbsT0B5VofrZEY7i2kJ6AjFULWzvBeGdgigncZzRwE43pTdsMsk3ZA0YnjHf5BI3TNdGjR+Fdk6CnKuZSxTGORJrpovrEZTiZAeoqDOyrrMssFjLLauBMoyoIzmhHYXWr/UZpRq1rcIc4Q91hB7zRRYILBjK85K8uFjmg3bV9S1DSVXSmaGOPxMQ2C48qpK9DcOSpf8AJtZL2zLGMzwlx93iG1QxTIs3EpBX0Oa+cZNX1CHUfrDB1ZNmBUgEV6L2V1aDWQgWdopOqg8jVPEkuwj6VJdnp14yNGrFhtVVSrgcBBHmKHPpnHb8DXEjHzztVO2stVttSR1nie1xgpy+OKzpfZMYKKpMNXFoJeFizIV6ih1xftaMVeGRoRyc0cyTCSB4seVBFdtTikt5fA6thtqI/sWOSupA8ahHezGKXhhg925ohb39mjd1FJgL949ar6t2ba2t++tWLgDLKedZtUZiQoJIrZKMlo64LHlVxZqbvVxxLHagSSE9OQq99YRFUSbMRnGKzFja3UJS4jQk9KtXTalNMX7kr0wKlwXgmWOPSIvovVX+jHsiHUEfsi05/wC5StUu2MVkvoyi4/o17IHg4gNItDjix/cpWtHIZGPSsDlXQvvpSa4UooA6uxXVwpCFApKWq17ewWaAzN4m2VFGWY+QHWgCvaD6tqE1schJfto//wAofzrrjUh3rW9nG1zcDmFOET/M3Ie7nQ/U7e+v4RcSj6tFCeNYVP2jjqGYcsjoKNWUcEdrGLRFSEgMoUY50xAiy09jeMmpv3x/exRD90vnhepB6mjhVWQqw2IwfdVTU1KIlygHHCeL3r1Hyq2rBlDKcqRkH0osZV0jKxvat7UDcI3+7zU//PlV0r4uQA9aoTDudShmXZZR3T+/mtXGdQcMd/KgVMWdwgXiOFPUczVS7lDhTwtseorpomll+zzwjmTyFP7xo1CXADL0IoLikiixySQMU6OZ4wQh50kvDxng9npVmG1BQNIwAPrTNW0lsSyZ8tggLzJNdHJCbgiVgXY4XPWo7mIRnwSBlPQGqlxH3kOBs43U+RoBRUtha5WONMyR4B5YFD0kMb5Q4qrJeyTWZaRyWQYIPQ061yYE4jk4ooqONxWwgt4TtIoYVFKI2PFGcehqLalPKgXFLoaH8fD1p1QR7yyE9NqmoKoB9sbz6hpElyDuFZB72GBQP6LrHu7K5vnB4pW4FJ8hz/Oqn0lXcsrwWCMxZnzwDkRjbb3mt/2b0j6t2bslhBXgj8auMEN1qnpGLmlLZg+2LHUu2Wm6cN0iwzj37n8hRXRSbztpcXIAMdlEI1J/Eaz2lTLcdoNc1aTeOLMaH3nH6CtP2AgYaTLdyDx3UrSfDpQ9IFtmxW5AQlySazOmImpa/c6wWJEZMEAHLA5mr+uTLBpVzI+44CAPMnaoezWnLpmj28CszHHEeLoTvipXRXFWHI5QvJfEeuanEqLsSMnyqj1qVIyx5bedITii7kc87VxdQMk1UKkHhZth5GrEQHDgZx60ENEikMMg0oqLgbiz5cqchfPiAoEKy+nF+VPiJxjGMdK7Gedc7wqmMDi8xQSyRHYE5bKnpVtpQka8I50MV2bPAMj86t24coMYyOhpGc4rtlyJy4yRT6hgfJIZgT5CpsjzpGEls6vN/pLnISyhz7cjyn4DAr0gV5V9JbE63ax9FgbHxarx9l4Vc0UtX1EDsdoemxn95GZ5ceQY4/OsLrLyvbmK2VnuJ2EUSrzLHaiX1r6xED/hKIB7lJ/rWm+jHS1vu031uWMNHZR8aZ/Gdh+Wa6oVCLkdEvhGg99GPZmLsxYXsk/C95GgDuR7B4clR+VeKXV19Zubu6J8U87yH4sa+htQm+rdlO0F11+2bPwxXzcicNnEd/ZBrFJybYYHttlG7cySnyWoImyak+47+eTUNgjPJExwVZvPPL0rSSpGsXcjS2UYSFR6V5/24uRLf3hXkirbr+rV6JxiK3ZzsFUmvLNRU3V6qbniYyOfUn+lPGvJp6qVRUUVdAsQCbiQYwNs0yF2aS5kQkEMGUg4I3ovdkW+nOqDBI4VFUNMtybW8B5iHi+RrSS4qjkit0fQv0R/SVB2ltItB7RMg1VF4IZpPZuVH3T/AB/rWy1Hs+kiSJC7BDkGJ9wPceYr46V2jlRo2KupBBBwQfOvoP6J/pOOqImj9o5kF+oC2905x338LH8XketcebDy3E09PneB14/9E/ZG6vOzH0vRQamhjttVi+rCXO0jDdST59K9k1G34Z2OOe4rz36RdMbVNK4rUFdQtiJoDyZZF3H9K3fZrVF7SdlLDUwMSvGBKvVXGzA/GsfyRtmfDIsi6kU5IcGo+69KKSRZFQGKsmdEcuioseKnjXlUqx08LipE52cgqVaaBTqZkx4akc8QINIKQ0E0VUhEbeEADyqbNdjekY7UUaXfY1jUEgzUrCo2FBaKcseRiqUkW+23r5UTYb1EyA0HRGVAwxbYXYedcke+FG1EGizSCHOwpl8ybSITLcKqjYczWZ+nPWXstCg7Paa3/WGqMI2C81j6mvQtFgS1tJLmXCqoJyegFfPE/aEdo+39/qIWWZsmG2IjLLEg24s+da437cXlf+39nBGL9Vn4LpdhLRNJj022a2iAAQKvF5kDc/Otlaxm5iiUjcgE0M0vTZ5CqmOQKTks43J91C/pH7WQdldIl06wnSTW5xw8I3+rqebHyPkKywYpZpVH/k9D1fqIYY/vwjyP6ZddTWO2Rgtypt7IdwrD7zZ8R+e1DoU+zHurNXKMblW3Y8XExP61rLZC5RBzbAr1o0pUukeFbk7fbJtMg7gSAj2lL/Ohmkx4c7e3n9aNRMDNeON0UcCn0AxUFjCES2bHXf41Fdm1dEuj3H7K7RW8oPCr7MPMda9ZOGQY3z1rz240Vr60upoFJltIjOAOZUEZ/Ktj2fufrWjW0hOSF4SfdUt7N8Xxk4lHUm7q82PMZonYSN3cUqnxDDA+6g3aM8N5AfxAiiOgvx2QzzUkVpD8qFkZ7r2hsh2g7G+EBpzCs0Z8nAzXm30aoE7TPG2Al3A6Mp8xv/WvSvo9u/rfZi3BOWiJjPw/+tYWe1Ok/SHGuOFPrYdOnhf/AJ5rGC3KJwRdXE9N0KVmtXhlJMsDd22evkflROhUY+r6wG+5cLwkdOJRkflmitYMyfY2upaSgRE29yg8gTUpqFcm7Y9AgH51NQMaaTpTqbTGMlYLGzHoM1V08YtUOOe9S3x4bZh1bwj40sI4YgKTKXRhu3D8WrIv4YxQ/sxF3mu222cNn5VN2ulDa3P/AAgL+VT9io+LVy/RYyafg6+sZu2O1ZW9XvNVmPqBWoc1nkTiuZGPVjSRniRZt0wKsgU2NcCpMUzaxMUmKdSUwG0hFPxSEUh2MNMc4p7VBMTjmKChYm4uP0rI9o5+G5Zc9K0UN1FbtJ3zgZ5YBNZTXolurwyR3EarjHiVv6Uyb2Au84jL125VS1eaSGxmkiQCRRkHY4ohJbdwsjd8jgrjwgjHzFUNSkWOzlPHxHhxjbfNWg7AfZm6knuJ1m+0cgNxHnRxs96fAOXmKg02ygsoh3TcLsBxHPM1YbHeZ7w7jzFOxJDSrD+7GPeKa2QDiMfOnNw5P2p+dR4XJzKfnQBFIjPBwBASwwN6sfsy0h4VaAO4AyxY8/nSWvD30OHJ8Q61Q1fV549QnSBYiinALAn+dBLKxtreftKsaQKIoI+JlydyaMtaWi8rWL8zWR0/UrhLi5uQsZeZtyQenlVw65eZxiEf8J/rQ2SaEW9t/wB1g/00zuYAzgWsG2PuVn/21e77w/6D/Wmftm9BLExZPPwf86LEGNWeG20+aQW8IbhwMIOZqTSbRLbToI2hjL8OWLICcmsrf6lc3TRQyMmOLjwFxyq8NXvT/eJ/oFOxGoVIhkiCEH/dimEBWX7OLB/gFZv9q3vSRf8AQKQ6leHBM24/hH9KLA05IH3Ix/wD+lNLEDYL8FFZn9o3hO83/pX+lI2oXh2E7D/hH9KdiNMJHweE7+4Vxkk4PaI+NZj69eD+/b5Ck+vXn+O/5UWFmlJxn31lG7wal4cY7w8zUpvbw79+4+VVoCHuEaTiLFsk4O9JgHMSZ+7+dOCuBjC/nTOFMbhvkaXEfk3yNUMvaP4rKVD91iKrqHAGCpxVjQ/3FwAOb7A1TeLgkcOjA5PQ030Ikl4gh9mtn9E7N/0qAbGDC/IVhmChCOBs+41svopdR2uhAUgmNx+VRLomfQb+kRf7W2K89lGxr0b6R1/tDEV5rOfERuK3j0UircMAvL5UJuSc+lWdSuu5UADJNUGlEsfFjB8qbAYP3la604jHH4xuB0rHocvWstAPq8X2ZzwjoKiY0aLRNJl1C9WFSrj0FekaT2VsLFAZYxNL1LchXlGn39xp0wktGaNycZFFn7SapKuGuJt+fKsZWy3vSPUksbBJT3SIknXgODVlIBGSys2PImsB2R1Oxte9udRncznkG3qTU+2k9wzQ2UBRM44idzUcXZKi26NiuoI100K4wgyzGpYyty3GAxReR6GvO7ee5kbLhlz+daeDXntLdY3hzwitHD6N3hdfEPXsAmhIeUxqOZFZ2eUi4WCxnlbfG5qKfUrnVHEYxGn4c86MaNZpAvGyqZR1BziiuC2NReNXIuWlqYbYiaQyMRk5qlbR97cPLbkxhNuEDY1PrFzLFbfZAZJ3JqTT51mt1IChwPEo6VO6szV1yZLA0zqTOFXyAqnqEZS3OLnuQTuTVqaZkBIQsR5UA1GC8uQJJFJGdlJ2FEVbKxxt70MW37+cRwzLNtknNFbbSreF1l4WEn+banaZbBbdTJHGknXgq8y8QIIolLwOc29EF3PFbxfaNjO2BzrK3giZ2KQ4XOzGjsFpPHNJJKUaPORx74FOuJtOljIlZDw9BTi6Kxvi9bMzbJM90iQDxE7Hy9aJ32n3XdF3uO8UDLAkiqt5ftakz6ZZ8QHhYsdqzur9pLmVgl4kscZ5hB4a1SbZ0/KTvo0lxBb/ALIS4jIJHtEUO0V7trlo7IgZ354AoZFIZIA8EheFuYU8/eK0emWljd2n9mleC56+LeqdRRUvhH7CdrdfVZeC5uXnmx4lXcCpJdSia8VOIpGoyxPWl0TTo7OJ24+8dj7TCh9xpNw0kskhjVScjJrH4tnMuDlsSbtGi6gqhR3A2LEb1ZuLq1l/tdzed1bDYDPOgYtlkmEbFAM4yeVaG10i0WDhZFnzz8quSii8ihFKi5p13bXEQFmxePGzY2+dWO8WIhSSWY7Cs7rCXelwfWbedLe0iH7hEzmqFprUlyyXaMGyNvSoUL2jKOLntGyaVe8CcQBPTrVe6lR5RblmXI9paHWV5dT+LuEXzkYbUSa5gWEyPIhYDfFTxong4sq3WjRTKO7kZWHUnNLptg1uzBplkXyqRb1TZmZ9weSinwS97YF7dMMQcA+dO3VDbnVMFa/LaKvdxaYt7K5wyhQBn1NP0XT7GKEyvY21pON2VGDcPxqCyvXiYwTL3fGTlyMGof8Ao/PYakdQ0thdBx9pC8mA3uptVoJR4hnRtVj1MzmAHuon4OL8R9KIyYUNJjLAcq8Q7adotbstXmgiWTTIGOREmMn1yK1n0bydp9St1m+swyWWd2n3NJwpWRJKK5M3+h393PAXuoliBJ4V649aJtBFN40CiXG5HWshq0XazTTJPZC1v4efd8OGHoKxWpfShrFk/cnS0tLjk3e5/Klw5dGPDm7gerXmsRafJ9XvFbcbMNwazC28kt+01n4ImOQaBWOqXmvWkd3do3eEb4G3wo9okN1G3eImVPIMa0UeKOzHiWKPJPYaidYSscoPE33sbGn5dSQquR7qkHeumTGqt6nNPQycPjC59KyMbAH0XqP/ALmHZDhGf+p7PJz/AOAlamKEOueLest9E5b/AO5r2QA66RZ//BStZPKynhXaoOfekhDblVJyOW1UBdKsrJJwqF6k4oigeVQOLA61SvLTMp4mJ6gkZoHB7qQ5ZUbHC6nPrSyyJFG0krqiKMlmOABQG+1aGyLxabB9dvORCnCIf4n5D3DJ9Kk0XT5dRc3WtzJOynMcSjEMZ9F6n1P5UUaNUr8Fn63c322nr3UB/wDaZV5/5V6+87VZs7CG2kaUcUtw3tTSHLH+g9BVxkCt4TkUlIlbOxnbGaHWjG1a4teFj3f2kYPVT/Q0TjznCmqmr7GG6RctAfH5lDz/AK0IlypnQ3McyFWYZPNTUVjL3SSwSHxQHA9VPL+nwoiIFRO+CoRjIOOdCNRjWO4hudwueCUZxseRPxplKSk9Fi9j+s2Trsre0hz1G4pttexTQwyMAXYb4+6ev50qCdXwqAINsE7UNPFb301u3CFf7ZAo+YoLUVYbldwylf3f3sVIY0Ykooz6mqltdKUCyHBG2aJd2GOU9kDPFmgzn8dEUkMOyzRDJGcqaFzRkSFYw5XpkUTbPfCPj42IzT+AJIA+VJHPyoCM+OwGRjblSKCxwoJPpWgmsreQhnOD5g86bFAlkGKtlW5EjcUWX/iE1pbMfqMUsEhwjLHJsSRtmr6DhQDyFHriTvEKTKpU+YoVNHEinD5fPKnZrHK5KmiAUp5VJBCZWxnAHM1LcW4jXKvn0oG5K6B6HFyy45jNMuLrgglZAcrsD0zUlzxBxEBwuRuT0FVNdmhsdGnZih8BwOL050FNqrMZDEt92n1C+ZHmjsSAni5sPPPT3VstS1uSPs1eXqcUWYieEtnBPrQHsAVg0cNPgvdO0nEN8nyPrS/SBdA6EtpApDXUqxjAxnfem+yKXG6MdbXD2fZuK1Ebd7euZGbPtDkP516lohgTTbeGDYRoF4TzBrG6dbLcdpLODuiYrNASOeyjA/PNb9I41YsqKrHckCiQ4pATtHJ31zaWQzwlu9kHoOQ+dHUXCqM8gBQCxdb7Vp7gjZpRDH/kTdj860R2XNJiRwJXcDix0q3BIxTLRlQfWqkUq5BBBPkaspNuOI4A8hSFJE4UMM4GDTG8Ljx4prXGRhRj1qJmZ/aNBCRZEviwNz504HhPiyD61HbLk53qdlBIJ6UiWcjHO2/vFQuMbkZYmrHTekDKeWDQIZb8KyANsT1Bq1hs8KnIPlVMoO95HFTRTiNvCCfdQTJeUTqjA4BwaniBV8YHqapi4eNuJ4zwnrioZ5y7EqxGfI0EcHIM15j9KVuU1W0nx4XjK/HNb2zvAE4ZWJPTas79J9ssuhR3PJ4nGPcdqqGmTBOE1Z5BGQUOPxH9a9R+h+PGnahKebTBfkP+deVWp8Mo8pDXrn0RYPZ+58/rDfoK6cusZpn6Hdr2MX0da8Qd+GUH4mvBLxe6sB6IB+Ve89vx3fYfXoW6sR8GxXhHaI93aqo+8wWngppsWJ6YHkThsjtvw1V0BeK4z5Cid0mLZh/DVLs6vjkJozLSOjD+QV1iYRabJk+1tWHijPE0jDxMc1rdffiRYBzKlj+lAhbscBFJYnAAHM1rijqxeodyBd0hknjU57tAW95q9oVp35uIwMmS2fH60b7WaONKvls+EiSC2QS/52HE3yyBUfZFOHUbPPJsofiMUS2rM4LZ5444bgDHMVbCHIPL1q/rOmtb61LAQcpISB/CT/WrdvZR96gn4xFkcXAN8elZpWJxphfRfpC7QaZbLbm4W7hQYRbkcRUeQbnivUf/ALPPbh7vXNS0fUjHGb1jcQKmyh/vKB6jf4V4lfWiI8pt+MwgkoXGCR61Fo19c6VqFpqNmxSe3kEiH1BqMkbVEyjapH29PEY5GU/Cq7pUfZnW7btV2Zs9XsyPtE+0X8LD2l+Bqy6158o0zXFk5IrYpacRTag6LO5Uo5UlB5Negt9W+o3sUtrxfuppAO7l9A3Q+hooai5dBjNca7II2O1NJoENJpCaQmm8a5xkZPTNBaRxNNO9L1pOdIpDWUGmcG9S05VoHyohEeantbUySKoG5NSKmTV5JoNNsLi/vHWOCFC7M3IAczVRi5OkYZs3CNgH6Srt49DTRLB+G91D7IYO6R/fb5UB0fSLDQtMVQIoYoUy8jYAUDqTXmp+mjTJe02o6hqGm3cyE93bNEy7RjkN+WTvXnv0gfSPqva+UWyqLLS+MFbWM54vV2+8fyrrl6Xk0puor/2Y4fUPFj4wXyfbPQ+3P0qI8Uth2SZg3svfkYOPKMdP81eMM0kk8rzO8kjHLM5ySfMmitvbcK8qgFhPc3kyWsRkKJ3jAdAOZrsSUY1FUjKS3ybti6Lppv21NQMmKxlmH/DvRPSgVhkusbInh9WPKtN9B2kjVu0erQMCUbTJkP8AxbVQtrBop7PTGG8R45/eOnyqXKmysSt0UEtzBbSRn2iMH3mpe54YcAeyNqvXCd5dsANixNTC38BGKMKs6JKjc/RPDFe9pI4J1DRXFtJGwPUFaqxaU+gX1/pcmcQTHgz1U8jVr6EwZO1NiR9yOTPwBFab6VoVTtbayIMF7YhvU52rF/k0TGX+dX6PMu1P720I/ER+VWezbnu5l8mzVPtU321oP4z+lS9mTmSce6tY/ki59s9q+iK44odStyd1dHA94P8ASqX0jx9z2t0mZdu9ZF+IYUz6IzjWdRXzgU/+qr30jxGXtH2fGedyi/nn+VRJ1lZwv82bO/U9yJUHiilD/DrREenKqsq8dpOvmP5VNbHit4j5qP0rm8GLJabTqSkBBCeKaY+oFTVFa7ozebE1LTGJSGnGkxQBVuvE8CebZ+W9PQeAVE0itqPdb8SR8XLzqXOIs+QoZR5nruJdWu2Iz9oaN9hox3lzJjkoWs/dHvLqZjzZ2P51rexkXDYzPj2mxTZ2T1Cg7KcKx9KFW0fXzolcfu291VYVwBQiIaRIopcU4CkxQVY2kIp+KaaBpjTTW2FPqtLIMn0oKQ2eThUmgmoXjKDwlquX9wIwDnFZ6/vyAcTMPc1MpBLszOlxNeC44SAoxx/86yXa1nXVuGHi4OEbJy/Kori9ldiBcyf6qqvcyk/7VL/rooXHdjLcyEyBg5HCdmqC9DS3FvBwDGeNhnoKswyOzMrTu+VOxbNVrYJLdzy942BiNTn51SGWvFj2B86iLMZQQi8vOpHCgfvG+dRNwh/3hxjzphQrlx91fnTW4+QVfnSKUOcyPgdc0jBdyHb5mmIZmbucIFDb8JJ5GstqCzQRyGQLxdTk5NaZeHh9tvmaDa8iSyW0KEl5HwdzyoJYIhjkSFAAmD55p/dyfwfnRh7CHYB2G/rXDToTzdvmaVCoDd3IB9z86ZwyEkeDb30aOnxdHf8AOq9xaQxQyuWbCjPWihNAWBWe5kfK+Hw1bKMFyOD86s6Zp8Zs0aRmDv4jzq0+nxcJwzfnTZNAwl8bcIPxphZzz4fzombCLG5fOPWo/qEPm5+dAUUg7ciFxS8bbbLVr6jEJBu/LyNONhEfx/I0CKQlbPIVyyMw5Crn7PjG3j+RpIrBMDPFz8jRsCo8hIwAB8KW3LCaPccx0q8dPi3yHP8Aw1GLKNGVgG2PlQATy5GOJflVrTbcyLPMeFmiA4QRtknnVAqgH7tvkaPaNZ91pkl7iMq7hBGTk7dWWqXYETvLbwMyvjqcKKF6lqExjTJUkkDJUbUa1i4jezRe5jjl33jXh4hjrWW1Ijhj6+IVYgg4YqTxry8q1H0ZzLD2stGlkRV4WBJwPu1RSCNokPAnIdKCa5qcOmSLE1qH4wcHYYpcb0DV6PUPpDmheQtHIjD0Oa8xuJ1yckCs5cdormROBMqvIZaqP1y4lzh29yD+laJVoaQdulWfdckjkQuaHzDgJDZyeZIxU1rI/cHvCwJ881Ru2JQkMc++hhQ5CePA5VrbEk20J4/ujoKwcVy4PMN7622lNxafASnNee1RMaL7H2fHtkdBUwYgfvdvcKqnpiPr1xRaPTxJB3kRRj1Xas6Lim+hLO1nuWAiySeuBgURXSpF373hlHPlVjSHkW0eO3XEg2yQMCktLm6W6WC9iYuxwr7Yx8KpJHRCMV2EbUyKFDYdx1qaRpGIDjFNVlhDcXMnbbpUUk5cY5CtEdKRLKpjYbnFGNOGqLCBbqFQ7gnrQdJUdQJuY61odJjneEG2uhwcsHfFTN0jPK6iXo4S0QOpFWYcsHAqBLiFJnIKxwrywPaqK8tL0yh+LvPKrsFsJYF+uIpbyPIVjo5tJXYIuLr+0A2csmD09aqXV7czOY5m2U7gjGKJSCyt9RQIyxqg4m32zVTV5LeWYSW7Fmb2hjatEdEGrWiGyuzbuOIuU8gav2+t8JYSqWXOxFB5Y5Ix9ojKOmRUY86bSZo8cZGgg1Nbq4EXc5Vj1NSaktikZM6IuBtw+1WXnuo7RO9lmESj7xOKprrVhMx4buMn1alw2R7KvQctr+3WxnidW4WyVOM+7NZ9mec7qCPIijOlpBdgSRzQtGDuOLnR99ItJrbwR90cbEU+aixvJHGzN6dcrHGIU09AznBdF5etH4dHEBR7UlXPtE1mtP1z9m6+1jPbOY84M2MgVu3lzF3keCCMjJxUTe9GOWTT+JzxBkUHp1FB9SSBpGEt4wONkqhrWpa7JKlvpWn5yfHKx8IHoar6UblNQMd99XSUHxBpAaUVWycarbYR0zSxJiSUB4zy3o5BBDbrwxAAe+nRogHgx8DVXVLWS5t+GFu7kzzzUttvZEpub2UtauoXRohEZW92RWCuorjS7h57VM27HLxDp6ivRlf6mipcMjk7eFd6oXs+nQqSIe9ZufFWkJVo3xyrSQEttakvrBFik+yxggc/jVmPTrqRAyKSjdc1kNYs57C5bUdNJEQOZIByIrU9m+1P1jT1aEK68ip5qfKtHdaNnaXxQa0VTAzQ3aFSfZJ5VZ1e6ew7poAOEncYqrJq1vdWbCQcEyjK486rabcm7uFS7biGNuKs6fbMeDb5SRaW5tdWIinTu3A8LA9aM6TpdtaRcT3Dsx/i2FCZYZoLg/s+z41xucUUsIZRHxyxFHO5GNhUy60YZWmqi6E1vsno+uoGvoO9ZRhXzgisXYw3HY3WJUsbeaTRCPtQzZ4T5ivQ5tVt4EWOR8SnbAFVLoRToTOFZDuc8qlNrswxqX+rodbaxFPYpNE7CFhszCvPfpL7OXvaK6t3sI4gsa7uXALVr9Q1PSrKDguZ4kXog3J9wFYeddL1a8ll+v6nb5OETgYA+6qjp2awiou0XOzWkal2cgiW7v8Ajtm/ugvFit5AE7sNHjBGdqEdmtOWzg4lec5GMTEkn1o2OWeQqZOxydiF+QPM13APX500cJPGW2HnT1YsMrgjzpCM79FmU+jPsgTkA6PZ7/8AuUrUkso4ywx5msP9GGqQf/c07JxRs8sq6TaL3SDJyIV+Q9TWhmtpr2bM8ptoyN4YW3b3v/T51Jko/Zcm1uCCUxR8VxcYyIYRxN8egHqaqXIu9SDrqTNBAN/q8DHf/M/M+4YHvq7Yw29mpS2hjQcyFHM+Z8z76ZJEl3KVMsiP78Cgaik7YLdViSNIVSO3GwRFAAoyrwLbhICQ3TbY0NvbaSBfA4YDng5pthZXN0RKhwAfaJqvBtJRlG7DQYwyoJ8cJ5MOWaS9YQAudweQFOhmjnX6tOPtORBoLqscll4biRniByp9PKpowhHlKmGLS4WTxqCCOhHI1OPEeF4s8Wx91Bf2pCLVTbpwy+u9F9HvWvI2MgAZfKhqgy45RXKgf9aNnE9jJu0LeHfnGeX9KZbI2oSSRtjgZSCKh7WxTJdR3kSMyRLiTH4Dz+XOinZ6ILa94faff4UiU1HHa7K9o5SzCztiaJjE+epHI/EYqjqkkYSK6AzJC+SPNeRq7rnBbXay8IKzjgYeTD2T/KgsobDI3IjcVSVm2CPONsNBft42jRCvtZ6GiLsJ2WNsLF1x1rO6VeMLI27qe8hPBxDy6H5VOt9IGCKSxooHicgzctbqypGoLnqvMU5HVY+FlJB/FQko31Z5mk7thyGOdSWs7kRR7tkZJPSlRn7euwhPKsmF4cMdhjnUdxFObbaTAXffnSXEJEXesjOV5Ac6AXF0/iZ5GCjzNCVlYsfP8SK5u5ZdSWOSRuEDYHzqwwHN32+VU9MjbVLxmZu7iTkwG5oqmkxJMZGkeQYxwvuKp60dc3GL4lJ72GM4V8nyXelguppZlaOE8IOSWqc2cMD/AGUZQE8yKu2yIu6sT5jFK0RKUa0iPUoY54UZva9DXn/0gSKlha20EUim5k4A5GzDrjrXoN4oigmYKSeE4Ga86uUfXe2tlZDHd2UIY9RnGd/jQjFyajRvNKsbKztLcRQgPFGFIGcZxuccs+tYztfcB+01sI0JhsozOy+THYVttMvoktMzBe+UHj4WzjFeZ6jcTXSahqcb8P12cxLGw+4uwIPvoXYdeDQdg4C0F3fNuZn4FJ/Cv/PNG9eu/qWlTyj28cKDzY7CreiWFva6PaRW0i4hQBv4j1zWS7Ua/wB/rFratpuEtn76RVlB48cum1HbLi29JB3s3YGP7MYzbRBCfNzu1Fz5UL7L3czWju9s8Tuxdi5G+f8AlRQnJpDpp0xGQMNxmuRSpxnb1pa4EHrQMb3qiTgJw3ketTDeql/IsNu0hQOVGQD507TLg3tms4Th8wDnFANasIRqq82yfSp0B3yc1ReaSPuhHEjFnCZLYxmrb2twZipCDbPt0jGTS7Y/ibPgXiHnUMnecXiGKek3A5hwOJDg4NXWhDxkhlO3Wghy4lJVdF65NTeJPEp3HpTYlbhPEacUbGxFANjZZ5mQh2GD0qrg1YkSQAk4YVErDGDuKCo1WhoyNxQ3tu73HZK9BGWiAfPoDRu07oPlyfQVYv7OC90+4teEYmjZDj1FCdMzySp9HzlZzK1zeRA7o4PzFeufQ7JxaVqEf4J8/Mf8q8qi0eayj1C5kzx2t0LacY6EEK3zA+deh/Q9dcN9qNqTjjRZB8Nv510zfLGwyvlFhv6V0ZOy90654ZWjVh68XOvAu05zc2UfnJX0D9Lv/wCBdw34ZYz/AOoV4D2jhkk1C0kQZjhPFIfIE4/U0YXUGTh/Egu08DbdKpdn14Wm99HJrYspFCdNXurmZT51pm2kdmJVIkmt/rN7M3RVVP51p/o37NLqva+ySROKC2/tEvuHIfE4odo9txo8n+JK35bV7Z9FWjCx0iW+lQCa7bwnyQbD881LycYOhepqML8s8T+kS3M2t69cnJJnbf3ACs1oOInt5eqMGr0PtnaCSPX3A3EshrA6THm3UjqBW+J84kyVca+i3240kCWLVIl2jl4ZcdY36/A0DaDhcrXo+nJFqmmS2twMhk7twfyNYpbOSKeWwuARcW7cKk/fHT5ioxupNMqceSsB6upTTZeH2uHAoYsHBCisN+EfpW60rSPr/wC0WkQ93aWkkzEjk3JfzNZ67tB9e7gukQwBxOcAbVWRW6RgbH6Du3B7Ma8NL1CTGk37hSW5RScg3uPI19LXUPAeJd0blXxHPCcZI+Ne/fQj9JS38MXZvtFMBdIAlpcOcd6o5KT+IfnXHlx3tGLvG+S6PUnG9REVduoTE2DuOhqo4riao7ISUlaGVHNFFPGY540kQ81YZBp9JUs1RQg0qG2b+xSz26f4avlPk2cfCrzBkGCwLY51xNNblQVt9lC4trmcFRfSRA/4aKD8zmq9nodpa3QumM9xdDYSzyFyPd0Hwop0rjyoZopNKkJSikFPVcmglnKuamRM7CuRM1bt4C+fuoPaY8hTSsxyZFFWzraHjYgkBF3ZvKvnP/7QX0lftaZ+zegykafA2LmVTtKw+6PQUc+mz6U17ubs52UnHDul3dxn5op8/M18/mAuSF6c69LFi9lW/wAv/X/6cO8r5PoS0hMsagDLHbFSLaEXsKMpDceCD0qXTlIVgNmVuYojYRmbU0LZJUFiTvvVqOjTthQR4oVft3dxJwAq5x4wxG3lR/g5UNmsZLzUO6hGWY8+gHUn0rpapDmrPSv/ALOtq7z6y0LcM8yLbhxzRObN8hQXTLFra+1SR2Z+C4lijdjksoY716J9Hl1a9m/o0urqyRPrF1M0FuxHilI24j6ZyfcKxWpqYoBZwHM8gJZvIHmx99cnyk2maYFttA3SIfrU1xKBlVPAP51cmh4Dir2g2Yt9PAAxkk0uoRcPCcVvi06OiUfiaL6CosdpZtv3ccn5kUf+lUcWuwN+GPhoV9BELN2k1eXHgih4c+rEf0q/9Jk3FqMZ23d8H0AArnmv8xnJB3mR5P2mfi1K2j/Cpar3ZVfHO3uoTqMguNVeQHKqpUVouy8IW0dse01Wl/mI2bu2enfRMv8A11qDdBAo/wDVVntyGbtp2fiD8Ra5EmPIAVL9E0IC6nORvxIgPwJquwGs/SesqEmOzBA8sKNz8yBWWXc2zk7k2egg/wBnl938qnhXhhjXyUCq8eSvAOvD+lXKwMGJTXOEJ8hT6o6tci1tCSrMXPCAvmaAStk9quLdPUZqWmxbRJtjYbU+kAlJSmkJwCT0pgDLF+/1G+mUgquIwR6c6nuG4LORj0Qml0+FYrUsqBTIS5x1zVbVm4NIuD17s0Gi2zzpQWJPnW57Np3ekp5kk1kLeLiI2rcaand2EK/w0zqyPVEs26EVGowKlcbU3lQSjsUhpedMZgOtAzjUbvg4pks6qCScAUOe7BBYtz5UFJF6WdY4pHPQUMabA8XPnVWKc3180SNmOFe8f+QqvcTYJ33pofkq6xdFVA5nNAbmV2zsMe+retv9kN8bjcUIdkJOZG+dNmseiEu7SPwqDj1qM8echV+dOHB3jDjPnsaaSvV2I95pDE71olkdgoAQ759KdYxPDZxrwgsRxEk9TvVWcLPNDAGbDHLb9BvV9SnCPE/LzNNEs5jLj2Vx76gYyBx4UJI8zUrFBnxP8zULFA67v+dMBQZAMELt60jNJnkvzNIeAci/50xyg6v+dBIxWk4TgLzPU0IDPc9oWJ4cW6Y9MmiYKBGJ48DPnQrRAri4uGVvtZDjnyFMTCknHt7PPzNKeMHfg/OopinDsGG/rXeDJ2f5GmA/D4x4fzoTrRdglspHFM4G2eVEyUHRz86FIFudbdgpMcCYxv7RoRLCiqyoq5XYYAANIwkKndce41wVD9xvkaSQJwkhW39DQIaePhG68vKmYc7ZXPupBwlQCjHauATO8bA+6mIRlbvFAKk79KXhcHYj5U11TvF8DZpGKA7o3yoEP8fVl/00xSwU+JRud8U1uDA+yb5UxArZxEeflQBLlz98fKmuH4dmHPypCiZ/ckfCuZUwcRn5UCH5bfxj5UV0PIhvBxA5VTsPWhDBefdbe4UT0IgG6AThzH/MU0BJqKghf8p/Ss9qzBLRHbYKQTitDfjKA+/9Kzt4veadgnmKsGXou1VksajPIY6/0oTr15p+rNFIbruGTbBUnNQJodsYlb7fJGThhTo9Ctg8cp74lSCAWGKSkLZZstItUQOymVvN+Xyq6saovCgAHTAxVrh4cgdKifY9BWgytIo5YoXdKFYg0Xc70Mvdic7mhgDXiRzgqDWp0gBdPiAk2AxgkVmTsR61pdJP9jTCA898is5dDRdfHCPtOvpUyvwezKwHoRUEnEVJ4fzFXEuOG3MfcgsfvEioLQUtNZitbNIolLydSzDGaJac5uH7+6kBP3V6D3Vk04mcDgA95rYabDGlqrvgjHXlVROjC77LE5DyZRiaSFo1mHfqxTrjnVCe/t47uPunDAHxYO1Ldava215ExHeht+HlV8kdHuRo1tlDp1zwrDbyuOrHpRngt9Pi4kUKOWPOsQ/adrx0g06DuQfI4+dTd9cXHd95cM/dnOemazqzBQc/Js7i5jRE7yQRl+VV9Wuhb2mEPifYGs1cu1y6vO3Ew5Y6UryySqA7FsbDNCgVHAlTCWkWiTKbi4HEM4APL30l+bOKeNoAC6tllU7UKlmlWIRqzEeWdqfocqPd8V0yqiDOD50+Pk0cHuTYY1S/47ZVWE8LjfjUjFCZrd4rNbk+wTjA5iit7q0bI0cK8eRjLcqoLeP9Ta3ZVZCNj1FEU0LGpJaQIuraDUIgk6hk54NVk0PTlOVtY8+eKKcIHlXVZudptmscoSziVWG4FaK3g1PiHeSKE6g0CtRmdQJDGfxCtELO6aAj64SSNtqzkzmzPZFqIt4YHNvEj3XTbO9ZzU5rq4tO5ld0l6kHFHbOyvraboUJ3351dvLW0WJpZ0UEb5NJNIzi4xddmDs57vTB4Lqd1/CWJFAtWs31C7adoijHcvk5o5rr3SQO+mwrLLnYE4FAI9M1zUx/1jdLbQnmkfM1okb+2vBbsu0E2mWaQWsz/WVcZZmLBh5Yrf2evvdWyjuR35XJHSsXpOgWemjMaF5Dzd9zRuylFrMH4cjqKTiiXhVGjsL57mUxvaFHHNiNqdq1jDcxIJmEeDnI2zVmwuop7YSR+FeuRioL/Tl1KeCYznuotwg5H1rHyczdO+gEdMlkgZ1XMe4wfKvPbrj7M633oB+oXB8Q6Ka9st3sJmW3+uxgkY7sHBNVO0PYXStbtu7kDxsPZZW5GrWWuwfrFF1JGNgniniWSJ1ZWGQQaniZo5FcdOVZzTuy2o6b2lfRvrOY18SMeq16Yuiy2NuF7yKfhHiDLyq3NG79TGl+xmka9eSSrCIlkHkNsVpl75l/eLg8wd8UAgtbeHE8eI368Jq6F7+P2mAPUbVjKn0cmWEW7iqItcHcWzGIq8o9OVYrWu0txp8EbhlIZwhV+RrZxWCxNJ4nmB3PFvXl30qpHItvHaRHCyZbANXCujbDVcezSWGt9n7C7Ml1bFZ38XEy8Y+Fa621jTdYgBs3idfwkAH5V5vFpaanaWqBgj8I4WYVe7Mw/wDRzWpItRgkl4/YeMZBqpQjV+R5cMfyXZvpVZY/szgqNs7ihWojWXWM2Uluu+WBB3FXLu/dIy8VnNITyRSM1HLJdXdgTacMM/MCVT8qyRiiS1mlmRVMOOjknIBq4p4Bwqmw8qH6VevIzQ3Rt0nX2ljkzv7qJ4FDBmR+ixYoPoy7KcCrHx6TaFioxkmFdzWplcooKrxHyzivP/o1uHX6OOy8XHlTpdrsf90taCd3eM+NgwGxzyqUjSGLSLN7fzxmNkiMUjnHC1PjvpEbDZb3jag9pNczgS3LmQJslGtN4XmVn8S45YqmqNJwUFtGgggt2iUOAWYZNXY40jXhjUKPIUMBwApyFHQVdjdWj2Zhjz51mebkiylc6ehu++MzK5O2OlCu1Vu7wCUOXxzAovJ7XtZ9ajliE0LIWK8QxkdKadM3xycGpN9GSsz3kIxzG1X7e7exBYsVj5n1qzBpqW05RXLcR8qsJpTveL3qnuRvv1q3JM6p5oPvosWmrm/t3zav3TDAJ603Rrx0SSzlTDwbA+an2T/L4VcYIDiNeEDkBQ7UgYJYr1Afs/DIB1Q/051BxOMX0ia+gN1DNGze0Mj0PQ1BaRR3Fqsq4E26uGH3hzq+DkAg5B5EVRH9m1MjlFcjI9HH9R+lFlddEID22oRPKoCTjumwdsjdf6UQS3iSTjRAGNRajB9Ys5EHt+0p8mG4p9lOLm1ilHNhuPI9R86LHZJIgkBV1DLjz5VxjXAAyoH4dqfSGlYhZLxLWLxtwqPxHOaAPYNrF0ZQDFbKc+XFRqe3juABKgbBzUmABhdl8qadFRfDceyG2s4rbh+rpwgfnU7c+QFQSSSpIoJxFnfh51YcLjKtxUmS7u2RPGHHiHxqKLvBKUOGHnjFT4Y7KB/Skjt3SbjMvFGTuDQPlRT1abubCVuLgGCC2OQ61iPolMEl7qd7cOTNKeCPiGSR/wDIFGfpV1WG10E2tu6d9MeE8JyQKt9kdHWy7OaeoAFwU7zixuC2+/nT6RCal2UO2wl03Tbq7V0YOOBAq4PEdqA6VZwz6pptrs1vYwCaUt5jfB97H8qs9tRd3WrWenT3UbRxq105VCvDjlneq/Y/Qb27nMou+6jvQ+RjPEqn+tHg0ck65Po3Fve2l3bGVYmTzwMf/Wsbaj9pvdSuAfr1x3aMV3WJOZo12gs7jRtIlhS472SXhiiGORY4pOzmizx3bxrcK8dqogX7PYnm3XzosrlC9MvR90kWLRiwQ7hTmnI0z3IdcGDh3zzBohHYsgk4EAwd+FcZqNlIJHI+tI0U0+iJZlZyqnxDpTSwikyEYlvLpUMdjLLcjhm4ST7ZFX7vSJLqzUMxyR7SbYoByhF02Qyos8fA6gow33pdGtxYx3EIbMbbpnpQjT7GcI0LTHgQleIZyaL2sXcxBM8RHXzo7HNKqTLt1Ei/U1QhnEysxHlRC5k4bk4OPDzoSD4lxtvufKppldW8R4gRsfSg5nj2rYse9ySACTzqdxK2QAAKqKSrZHSpTM56491BTRJGxibhkHPrTnEhz3ZwtRSTF1AK7jrTnkcAEHagmmIDLngJ3qJlKnDDBqdpuLBVfEOtNlkL8xQNWRqRkZ5UWtlRlBRz7qEhSeQqa2do5Rg49KCckbWgVq2jW412fvVAtNYhNvN6SD2T78bV5/2cNx2V7bwWt8Cvi7lmPJ0bYMK9mvrSK+tjFKDg4ZSOakciPWgvanstbdobKNLh+C9hH2Vyq4IPqOo9KalWjnhNLTKf0rRNN2E1PhGSiB/kc15x2X0Vdds+0NuFzLJZARnybOR+leqXNtPe9lrvTL8L9bNu0bcJyH2wGHvrE/Qo32t4km0ohRWHqpwfzq4SqLHF1FmBtEMlujSIVkxh1PRhsR86A30P1fU5MDAYBhXpHbDSjpPai6jC4t7s/WIT6n2h89/jWL7T25BimUeak1ry5RPQhLlBSRZ7ORM2nQBhhjKR8zX0bpdutpp1tbqMCONVx8K8cttNOn3ViqgP3scM4HvUZ/Svao3EkaOvJgCKxk9I5vVT5KJ4z24tO5j7TD0eQfFa8l7MSpLYWZYgGVAoz5+Ve6dvLcHV9RgPK6tCR6kA15ZqfZN9HMEUQ+zVYbqMjoGAz+f6104JqKNvyjEfHI+lzrdhWaIeGYDmU8/hzq32p05b62h1SxxJJGuTwf3kfp6jnR1LASwkMuDuGB6GsZaalP2X1+5sbhWk0tj3igbmHPMgdV9Kpvk+S7Kn8VZqtItnj+jLUdTUQ8OoOIDKdm4Q2AfUE5rzbtNaMupRYX21r0jVNTaTsi9pYkXGmvKk6GPfuvFk7fhPP0rOzW31i8gKnKBCduRoi3TZnCNumYeSydIyxU4xVV7bgEb7jOGVgcEHzBr0PUNN47KYADi4Dj5VmJbNjokbMuJY1GfhUvwXLFR6h9Ff0qo6Q6H2wnw+yW9+52byWQ9D69a9euISgDKQ0bbqw5Gvi+TBBBGR616d9FfbrW9CsJo54ZdU0KFwjRE5kgBGcoTzH8J+Fc2eEUrejHDgm5Vi3+v/AIe7tTTUGl6rp2u6el/o9ylxav5e0h6qw5g++pjXI1R0xfhjScUxjTmphqTVHUvWkG9OVcmgHoULmp40pYo+I7DJrGdsvpS0Hst3lvbsNT1Vdu4hOUjP8TchWuPDLI/ijmy5lHS2zcXMlrp1lJeanPHa2kQ4neRsDFfP/wBKX0uT68kuk9mDJaaV7Mlz7LzDyXyX8zWJ7Ydqtb7X3nf6vcsYc5jtYyRFH8Op9TWedeDAxvXoYsUcW1t/f/w5njlL5ZP+CqUCjA5UQsLMtbs5HOk0+ze8vUiQZzz9BWuuLH6tZkKvixwqPMnYVqkr2bRg2rMlFYyQfaOpCTjjT1A2zRXRbXwSTFfaOB7hWu+kfSP2bNoViqjvE05AwH4icn9aZZaX3VvFHjAUYJNGN2kxwjy2gZDavI4VFJJ2AqvqPDbRS29scyybSyDr/CPT9a0zxrDGUjGMjc9T6e6m9kNNS/7TWVuiC4nnmA/giXq3qcfCtZSpWOcUlvo0nZPRtS1Ow0+0htyGgi4EVvZiBOSzHzNQ61oQ0fWb60ErTyFly7cySN8eQ9K9+sbOCxtkgtYxHGo5Dr6mvG+1Egm7ZaoefDKsY9/CK4ITbexYMvKdLoDwQiOJVHIDFD9Y8PdgdaPSJ4dhyrO6uxe7SMbnHL311Yts6crqJ6d9DWm/szsvfalIfHezNINuSqMD+dZX6UZ2hv0QniaK3BwPxOScV6rolmLXQNNsPZSOFXl9Bzx86wOj6aO1nb24vZUL6fbTd6xIyrFdlX5jNc/K5OTPPxypuTPHrvSbnRdVurC9z3yqsh9OMA4+ea2miWvdabCCMEjNE/pWsFn+kQCMDMkEfH8zTpI5BGkVpA887kRxRJzY+VPHK5WdMPw5M2Nhfx9muw4kJVbu7LOgPTpxH0Aq79Gultb6dcalcoy3F0cKGHiEY3GfUk5pmidkLm7u4b/tKUPcqohskPEkYHLiPX3cq2VkB3DHzZv1rKcl4OOclTSEsweJiefCtW6r23tH3CrFZmTOoXrXC8lnEQSWmHKilD722M+oWrCRl7vLEDrQOPZfxXGlrqCRKgvCVtpCOeNqnNVrs57pPxOBSGiRV7uAL+FcUI19saRIB97AoxJ7B91BNeObJB5sKDTH2ALK38QyK1kY4Y1XyAoFZKONB61oMVRvNkUjcOKgeYDrVfVrkQyhc9M0Gnv/AFoKirNHbP3iOw6UPlusZq1op49LEn4smstdXaxh2aQgLknegcFbaJdSvy0iW6HxPucHkKpXt/3FvI5wFQedC7KbvzJdSFsyHC89lqhqEv1q9jtFZuAHjk3PLoKDdRNR2KDmK8kl9uVOM/yqO5OJCPWl7P3tvZ/W5J5CF7vAG5yfIChdzqU8rk22nzsmdmchc01szcXyZBrGTHtucjrVFw/UL86Zql5M6BJrSaEkjxdPmKcxQnm3zNNmqVIgPH3pxwjbzppMmTsp+JpxK94d25etQ3MiRwsx4thnrSAZYh5dQlk8PCo7sfzq2ved2AOHl61Bpkax92rcXGRljvzNTqE4Rs350yWI/eD8H51HIJOJdk/OnkJuSHz7jUcoUFDhsZ32NAhMSZOOHHxpj8ePu/I048H4W+RpjcGPZc/A0xA/VJXh024fK59kY8zS6dA8GnwR+HZcnaqes8Ms9raqrDjk4m2PIUV4UGPC2PcaYiOVX7o54SM+VKyvjGV+VJME4ThGx7jTW4CN0b5GgCOVmjjd2ZcKCTtQ7Qo3MMk7YDTMXO3TpTtaYCz7pEYPMwQbVbjhSJVjWNvCoHKmT5JjxgYBHyqNi5TmPlSEDl3bfKmkLuO6PLyoAaofgGGHyp54sbsvyqIBeAYjJ+FJ4f8ACJx6UCFJyyjiGfdSFCebj5UhVeIYixv1Ariqg7xc/QUCEKsfvjHurgSobxjn5U3wDP2X5CkQKeLEe+fIUCHHi594PlTHyYz4xj3CnEYG8W3wprqpQ/Z7j3UwH4Ocd5j4CiGivwzTDjBzGenrQ3G37oflVvSBi6bwBQUPlQgCN3vGo9azU29gw/OtPcAmNR0zzrNXHhtZFboT+taMQ+1PFbITJ930p4JCD7TI222plp/sqYjHL0q7pNul5fWsEilY5ZFQspGQCaz6AePabFQuu5J3rddrexf7HXvLa5aWM9HAz+VYmRGBIO2K2TvaGnZVcbnHKh12BknFE58L1oddChjBp3IrRaQR9TALlSCetZ5l8QNaHRixtWwARxedRLoEXGwEP2p+dPLLv9qfnSScXATwj/VTsvnZF+dZjEDg85T865rlyOA3MhQDZeLauLPxDwqPjUZLd4SQvLzoCxTIoH7w/Oql7Lh4GEjEB8HerRLnkF+dVNR4/quTjwsDzpjsv6fLwsFSZl48AkHpW7tpI4rRCclVHMCsDp5BkhM7ARZBYjOwrR3WvQxqVtEMhA2LbAU0zfFNRVsPifjiMgGFxn1qnBdx5Ud6GZ9woOT8qD3GtXFva26AxvPJ4nBGwB5CiHZqyZImuGj8TnOQKdm6yW6QZC75IOTTQgQkgbmrdrayXUnDGAccyajuoGgnMbEEjyp34NFJXRENjTjTTgHnvU0NvLMCY42YAZOByp2NyS7IsZHlV2ya12E8LO3p1qqilm4RzrT6PY91DxMiknqamTpGObIorZJY2Fo68bwiPyU86uwm3DtCrDwjOQeVU5bYyyECYo3TeqFjZcKTSXV33SkkbHc1l2cbSe2wgksT3TqJeJl6dBQ+7srrVZSYSghXYZbn8KfpWkLL3kzyyiMkhCNi3rUWp6XNpqG4tLhuDrk4OapUnotSipVF7Bc2k3UaSN3eRGcNw749ahtdOnvELQcOx3yaJ2Oq3kbSSSRtcKVwxIxgUJW9eGWQ278HGTsKu2dMZTdp0FY7OxaMrK6pMuxAPWopLWLT5VaY8cbnHLpQkOQ3Fkls5zT9U1XvIo/rBwE2GOtFMfBp96Lur3qHhhtWxABvio7C4u2VorXiYEeyN6TRtJn1de8hAWL8TVpdO0VdKlWVrxVby86TkkqMsmbHBcVtmXk0nvZEF9HJFGTvIBgr8a9C0aCG3sI47aZpowNmZuImrTIk8WHUOrDr1rGdpu1Nt2NkSKWImCTdAorNtz0cE5v1GvJD2/1rTNKkS8WN5dTh9kIpO3kaEXX0qWE2mL3NvKty4w6sMBaxuvfSAdTu3ksNOZy3mMis/Paaxrsi/wBiS3QnduHFaxgvJ2Y/TRSV9ntnYG/s9TspJe9BlzvGx5U/W79rDVIo0l8L8k86850PsbqaAHTLyYTgblTgCm672T7aB++cmcryYNuKKje2NxjHJcn/ALHq1lqd03EY4VAH3WO5rznt5q11Fq9q1nEBdl9ogPaFS9nNf1rSFjt9Y0a7mbkZ1yxpnbDStX1DtBY6rZWQWGLDcRkAJHqKSpMElGT0bG0sZ9RsreeeMWkvCD3YHI0TS2eMB2+0dRgLSWOow3FvGTJGJSo4kDgkGn/tCLvxFwuWPULUNtkNyZUvdH+u3kV4Lq4tpkXHChHD8RWQ1OfXIO1MNtJNdzWLnGUULj416MeVRCJu8LO5ZeinpSUqJToCTdl7T6pL9QZra8lPEbjPE+au2MUlvbJFeXaSTLsW4sZom6q6lSNj0rzHtQuuW2szJp+lQy2+xVhnehbCLvQ/6OEU/R92XJG/7Ltf/hLWm6bDNZr6ODj6Pey//wDS7X/4S1popUibjkAKDcg0HRH8UV9B4Hu51uMiIHcCtDbNb27E25bfbA3oRpFoXs7jUIyAsjnC+lSxysj5U4NKW2KdZG6NAJeNdwCfOlV+78ROB50C/aDrMqcfibkKne9ldCpIwRjapoweFoJd9xs3dqGGeeeVSHYZOQKCQytG4ZeYq931zcqOI5TOciihSxtf0XEkVtxk49KnFy6gAnPvqj9aRXCbnG2alSVW5MKRnKH2iV24m4sAe6msoZSrDIIwa7NLQFUUdOYwtJZud4t0Pmh5fLlUuoQGe2YIcSr40Pkw5VHqKmPu7uNcvCdx5qeYq3G6yIro2VYZBHUUARWc4ubdJRsWG48j1Hzqtaf2e/ntzngk+2j/APyh/OlhP1bUZITgRz/aJ/m+8P512rAokV0gy1u3EfVeTD5UAX66uTDpxKcqRkHzpCd6A7FpMeRxXV1IYvI01ixXChR60tLQIYHGQGIDeVLMW4VA3G+B8KUKDnIFVNQm7q0kYZQAbv8AhHnTB7PN+1ok1TXtG0qIF2Ucb4G+Sd69OtGaOCJn8LIvLGMDFeadih9f7a6jqEcTm3RjFGy5IXO2f1rZ9s9SGk9nbqcH7Qr3aZP3jtTYqMBqF9JqeqajcoeJ7uYWsI68IP8AWvU9MsBZXOnRQL9jb25jJ9dv+deX9hEjfVrVpYnkS0TixGuSznl/OvXhctDGZZozHEqljxkZFJmcotGU7VXHfdq4EXxpZRd7w/ilbZB861eiWn1K3EBOXVQXPmxySfnWB7LXB1DWr7V5kklhWQy8K7knkg+A3rTRdr9OE83EJwcjYp/zoYvanJaQcUuJ5mUgKG3+VA9UMgTjY8OWO4p1t2t0zMpLS7t/hmht7rVrqCL9VLlkZmPEuKRvhxTjLcS1prGa/TidmQg42wK09r/sS4/CaxlvqyRhJrjKRgYPAMmiVv2ksodO7wrOUbODw/8AOgr1GKcnaQ2KTjkkULgKefnSTXEcBHenhUnAJ5UNg1FGYzLkQPvuMEVT7TXcbwiKM8RxkmhHQsbtJmodk4Igo8bNw7daIWMLcTpMDjh5GgelTCa00sn2xMFPwFahf9rf/KKDhzScfiCTDxTyIhB4TjHUe+rFtGAAWOR7qZaYN/ebf3m+fdV2zjHjDDOGJHuosmWR0RSQLKuFIDdMio+4HDhic0SaNWOSN6a0S4OBvQQsoGKNG4yCPKiK8DhSYwTUqQ5BEgBFOaEcAC7YpjlkTI1to+MMPCfLNSSQJIN1APmKQRHh54apI+LHioM2/NiqMKB5UtdXUiBCASCQMivM9LspOzH0ntCAfqOqB2jbyY7lfmPzr02ql/YW98IvrCZaJxJG42ZGHUGmnRUXQL7ZaAuu6cFjbgu4D3kL+vUH0PKvIda0+R7SeCWMpNHnKnmCK99HLc5rLdstA+vQtd2ij6yi4dR/eL/WqjKjo9Pm4Pi+jL9ywHY/UDvBMsdvKfI4wP516HpDFbdrd88cDcG/UdD8qznYy3h1TsVHZT79y7R56qytkH3jIrSrHLEyTPgvw8MvD94edKT8GM34M/2609plgu4hl4sg7bkeVDL3SxrfZawv7NQ9zaxlCmP3iDYr79sj1reMqTRkHDKap6Xpy6a06QMfq8r94EP3GPPHoaVlLK0kvo8xgmtp0ikicd42I5FOxJGytj8iPMVifpJ07u57K/VduLun9xr23tD2O0/V2aZC9pdE8XeRbZPmR5+tYTtVpc0um3OnahGY7gDMbn2ZCNwyn+XOtITaZ2Y8kckeJtNR7LWd/wBm0FrEkF8LVVinjHCQQoxnHP4141Z2ssd3CJy3eLxLKMDAbkeXLevoDs1P9Z7PadKfaMCZ94GD+dZnVuzK/wDSWSZUxaX8TRuVH7uQjY/GiGSrTObFlcHTPObm1+zdccxQG+sTC7RSDwyxrIPUEYP5g16FP2X7QpaNLLYwyvxlRHBMOIr0Y8WBv5ZqSPsFf6lYWUl5KlhNAHjYOA/FGTxLyOxBzWnNJHZLPC07PnXVLU2l5JEc4B291br6H8yprcHQJHL8jj+db5foz7Lajet+0NcuZZUXcR8MKH3MQc/A1d7P9j9F7O6xqUWg3Mk6SWX2gkmWQg8Qxy5VlnkpR0GLIoZLRmTpU+n6g2paBctp9+fb4RmKYeUicj7xvWl0XtxHLcx2WvQLpmoOcIS2YJz/AAP0P8JwastZ4TlvQq/06C5iaG5hSWJuaOuQa85OUT3JRx5/y7+zeqyuNjSFa81srbV9FI/Yl8JLYcrO9LOg9Ef2l924onF2i7QSjhfRLaF/xve8Se/AXNUpxZyS9HNP4tNf3/8ATb8SrtzNANc7Y6To7mGSVrq8xta2o45D78bL8azd8up36ldR1KQRHnBaDuUI8ifaPzqCz0+3tF7uzt44geiLgk+p60/cS6V//wB/z/6NcfoU95H/AMf/AEyn0ndsO0t9obk/9U6fK4iW3gbxvn8b8+XQYFeTLGETAFeyfTRpNzDpOhW0FvNPNLI88giQsQAMDl768ufSNSRQZNOvlHmbd/6V6OCTcFyZ52f23L/KVIMWunh7eNsc1BoZqtg8M8bj2TlfjzrX6IsUlnGvGvEieNc7r7xzFO1jR5Z73Q7IgiW4R7pgRgqjMAM/AfnWkHStizJNKK7Z3YPQmFq95KuGk2TPlWx0Ls8NW7S2sDJxQW7LLJ5Fvuj9T8KKw28VlZKkaeGNQqqBufIVu+xWkDTbJ7u5XhmbLuT+LqPgNvnUKbpt+SM8lihxR5d29i/aH0kXQH7qzijjHwGf51AbYczvRAg3N/f3sm73U7SD/LyX8hSTAIhJ2xWsJaLxrhBIzesp3FjcGEAScJwfKtr9BGgt39xq0wOIU7iInqx9o/8Az50J1LRppbex05Y86lqcgfgPOKEHIz5ZO/uFe1dndJg0PR7ext8cMS+JvxN1NGbJUeK8nDnycughPIkMLySMFRRkk14Os6ar2i1TUIAwtxMyJn7zfeb8gK9U7S34awuZz/sUI23/AH0nRR6ZrzuytVs7RY9gd3c/xE5J/OudaVGnpIdyZG6YQk8qE9mtNbXe19vDGR3YfvHOOSLzpO0V5dtHFb6dbyus792ZgDj1C/iPur1D6MuyzaFprXN4nDf3IHEp/u0HJff1Nb8/bi/tl+pyqqQa7TTyWWkSRWSl766+yhAHNjtn3AVJ2U0SPQdHitEPHJ7Ur/iY8zRUwoZhKRlwMAnp7qh1S8jsLCe6lIVIkLHNct3o4Lb0eSdpwLrtpf3PMRhYl+A3o/8AR1pv1vUJtUkH2FvmGH+J/vH4cqz2nWd1r+otbWuVkmYyXMw5Qqefx6AV67ptjBptjDaWqcEMS8Kj+Z9a0k+KryzpzZOMFjRZbZCfSq9hn6onrk/nU0xxC59DTbUcNtEP4RWJy+Blv7Xw/nVioIPb+B/Wp6AZ1V08V456KoHzqxVa03aZz1fA+FMEWa6upDQI6qz5a9QdEUt8TtVmq1v4p536ZCj4Uholl9g+6s/2jlCRQKepz+VaGUfZt7qx/bGXhuLdM8lJoNsO5DdLl72+hQedaoisZ2VJl1YeSqTW1oZeXUqMN2nu8apKgPsgCgElyTzNTa9KZNWuz5yGh6DjmRB95gKZ1QVRPUdJj4NHt1693n515nrckk9ythHjikYlyDyUGvUpZI7HTi8pCxwx7n0AryzT0E0k97Jxcc7ErnOy52oRn6fbbJ55Ba2zMeFY4186HaRDLwS3MgHeztxHPQdBXajw3d7FZpxcC+OU78ugq8Ag4gA2AdudB1Bjs1bpPdy9+itwRllHrTLxD3j8tj0qfslj67OFzvEeeah1OVIeN5WCqDzNNHO75sDartBtVEhzjZfzq7qTB7VmBDLjIx1qkAvD4g3yNNm0eis5cSnHDy9apXJkkmih2IJ4258hVpwpl3VsY9apwIrySzEPgnhXnyFIbReg4++XJUgnyNPTjAAynpsarWhRplAVhg+RqwFQYyjH4GmQ0KRITuV+RqKUSAruvPyp7CMn2G+VRScB4cRtz8qYjsPjmvypni33X5UpCH+7b5UyVo442cxHAGeVAgRCGuNfmcYKwLw5x1NE2487svyoZoKhread4yWmkJ2HSiZVP8I/6aZJFKH4D4l+VcVckeNflXSKndnEX5Ux+ELkxbYydqABs4M+tRJxArAvGdup5Ve8Rk9ocvKh+jKJDcXTRk9654dugq/heP8AddOWBTEhSCDs4+VNcHfxgbeVO4BjPdfkKZgEbw/kKBNEKg8AxIDj0FN8WSBIAPcKfGMqPsv0prKDyi3+FMQx8gKO8HPngV24P7wbcuVNlGSvgwc+ldvz7vl7qBUNY5/vPyFLEdm+0Gx9KTBP93+lJH4WbKdfMUCJCc8pfgcVG5AQ4kB235U7PEMiP4ZFMk4uA/ZgD3igB6kdJMfKrWnOPrijjzkEdKqjOBhRy8xU9kT9aj8AHxpoArPsmQeorPXQJScfxGj90SYSRzBoFdqQbgfxGrYMZYYNsuZCOmMiiWikJqVme8O0y9R51V0u1m+qJ4AwPI5q7bQXULxuIOIowbHEN96hphWj2n6QV4rAEcsV4vcg8bb9a13aX6QoL+17mS2SDAweKbJ/IV59c63aljwEtnyFXBUqYoRaRLKudhzodd7ZGKkGpxyuAqtvUV444SwG1UXQPYYfej+iMn1d/Gw8XnWaa4jLYJPxrSaA3Fbyd2VbcdamXQUX5GQRt425edLxJtmRvmaWTj7tgQvLzpV7zhAHDnHnWYEbFPxsfiaZlO89psY8zU/j2A4fnUbh1kGeHl5mgBjFM7O/zNV70K9tIoLZx61bbjyPY/Oo3VyjA8O4PnQBDa8JtoyS/L1qRSgPN8fGo7DvHt41QAnliibaTqKRGWS2cRjrwmgaLlp2d1HUlSaGB2jJzxlulbHQ9bisI00+5HeqPCX6D41kuzsuqvN9XsbkRrzZSdsV6XDptpd6ekDmIy83MYxk0mWrouWHBBC03dKsbHKlDnIoZrd3pNozS3crGRtwq7mrNlqCQyNaXKrEkey+WKF6pqVtPef2awiuCBw8b7fKhJlqE09AzT7hb644raKRoOLrsSK3lhPE1oYYrVoVxg5oX2R0YqrTXURhfiyEU7YrUTiCOMs64UcyBypSlejHLlUmo1YKg0qCP7RE3zkcRohEVI4V2AoQ3167vWjtJM2zIeFz0ojptlcQqwnOSB0POk/2Rkf/AHPY66a1jRjOFcrvw4yaitJLeO3eXuO4h9rDjfPurrKVYnk+s5jldyAGHT31Zmjiu4uGZC0ZPI7UjN60xmn3n1xXZQAmcLvvj3dK7uY5ZCjOZkByVbBANRaZpsentP3Tl1kbKqfujyzTbu5t9Mibu+Hjc57sbljR30OrlUB99dLCRblVQOMcbDCAf19KFS9lNOMQ+ro0cw8XecRPFRCyvYtRjMTqWbGXBXYelC9Sjtr5Vs7DU7m1k48ERkkY6iqSaKjGUXrTRiNWvjptzLBOpEqHBXrTLOM3iCa4Xw5yqkVrbnsVaSX8bB3ZQuXkkbLE0P1m0isbxooH4olAwc1pGVnfiyqbpsba6jc2MRW3kKJ5Chmkaxqdz2iSTUbZvqEZ3Lt7XwrpLyBThnGfLNTIk0kfHBDI48wKukzWUYPs2tx2mhjVvq4ZiRsCNhWH1m3TWroT6mWnYeyG5L7hUqlsYYEN1B2ovHoN3JYi5ThIO4XO+KlKMTKMMWHYAgsra2XEMEae4VNy5YpfFkjGMHGDUckqRAd86oCcDJ5mrOlUHdFu7+1ib6kqupO4ogmv35lEFxEq8Xhzg0Fge1t4BI920cnVF50UttasTZhy7O67YYbms2vNHLkgm742FIobkRtxyxs3MAisx2jtrzWtKuLSK5kilXmsa860v1wdypZlWR/ZU02eaOyh76VVMh/AOdQjJWfOV3NrOk30YlSaF4GwGYYz8etex9j+1cl7pqSTwF5B4WwN80680S27YapBPdOVtrc5MQPtn1rT3M2jdnrNe9+rWsQ2A2BNXKXhoqc+PxaIbLWhdXggMDxgjZmoq5wp88VTu2tLzTDPC8bKV4kdTXm/avtXruj2oksmilgHhIdclajjy6JUOauKo9HacWtuPrtwAWOA2wAzSpZMAT9cuHycglhXlUvaW21Xs/G2vWgt7iUHuZS54CfPblWJve3vaKCbuU1IFIxwKU5ECmoNk8T076OCB9HnZfbf9l2v/wAFaJazP3Vpwr7Uh4RQr6OT/wDm97Mf/wBLtf8A4S1c1VhJfWkJ/FxUoo6sK6DWnI8NokQZgoG4pt1ciLwRDvJj7KDnVS5v2jfuLTxznY45L76s6VarBKJZizTE5L+VDVbY2q+TJNNspiWlm8U5GSPIeQq3jG1GEKunEhGT1xVKeF0lD8Wf4jUXZh7jk9kcEBlViDgjoasWTSIxUqSnXPSrFuWZdyh9VpZIWfK5IXpg0jNyvTHoEEhACZ57c66SFZGBYnA6CmQxqsh9otjmeVWKRmxo4ceEDanDlTHQHBxkjoKcvLkRQIUgMMHlVGzzbXD2jHwbvCfTqPhV+qeoRNJEGjIE8Z44zjr5fGhCO1KFpIOOL99Ee8T3jp8alhkju7VXG6SLy8vMUtrMtxAkqbBhy8j1FU7U/VL+W2baOXMsfv8AvD+dAEukzmK3kgkXJt24CPNeh+X6VKqTSq0sRDAnwx9R76H31wtlqUMyYYTjumA8/un+VWpVmnUBJlR+fCOdMpRrZJDLIZmR1C48qs0G72WyciYcRPI5pw1TzQ4puJo8Te0F66oLe4jlQFXGeozT3njRgHcAnlvzqWjNxadEvT0rMdvL5bPRZ+8AIMbYB5E8h+takSjgwF4s88mvNfpSuo7+60rToMq0kp4iTsRnHyoRGwj9FtqbTQisiMGmPfEkEbchv1oN9KN8LnV7HS4n8CfayAH5flXoayQaXYRoykQQxgAjkABXjtsza9rt1eHd72fuItuSdT8h+dNDpnonYHSBBpEd03gnuW73OOS8h+VT/SLqDWekPaxZee6Xu0I8ycUaBW2tV4IpCsahQqDfArEXapeduDJeTXElraxh1iB3WQ8gMUrBRbZo+y/ZVNPskhNzcRzcAaTu2ABY8+nSrMXZLT3lm4pJ88XPiGT+VDpNWsQ4Qw6grHb95y9+Gq4ZbCJGbu7k7ZOJ2OfzqbK4ZV02PtuyGnkSHvbgeM/eH9KGX2j2+lwK9u8jFywPGQan+vaOLdnSKdd9w0rf1oRrV5pN0sQgtJ/DnOXOP1os1xxyKXybouaNaRXpihmJC44tqLt2YspLQv30sY4c8KMMD51k9Kl0u2vEkntJDGAc+LP860H7Y7O4wLCUjy4f+dA83ucvjYLu4o7SGSFH4lQYBJGao6yAqRvxLwsmBv5V10+mS3Mjx2YCM2QCOnzpl6LCazhSG0VZEYltuYppnSn0FOzd8n160geRQO+DDJ9K3y3UH1p8zR+yPvCvK9JS1t9StZp7ZBFGxLjAORjyrYjXNEB8Onr/AOUKTOL1OJylaQW05lkv7xkIYd5zBz0q/CeC8YfjXPyrO6Jq1q+oSRQwvGJnygCgAbUflIWeF8fe4c+8UHJki06ZeNJXV1MwOrq6uoA6urq6gDq6urqAOrq6uoA6urq6gAXYaebDVLt4FAtroiRgD7MnInHkaKV1dQDdncuVdXV1AHVDdWsF3CYrmJJYzzVxkVNXUAVdMsINOthb2issIJKqWLcOegz0q1S0hoHdiHYb8qzeoX/7QaRIyRYRnhYjbvm/CP4R1NX9Uu1kD20THylcfdHlnzoM7A8KooWJBhFHICmkbY4+WZztZpMmsaRPbW9zJaXIGYZYtuEjkMeXpWd+hhbq0tNYh1gW/wC0u97tjHGqMVHInAHOtxIfEay+vWz2GoR6pZjDezIB94eRomnJJLwejgmmuEvJqjEGXIofeW33gPfU+iX8V/aiSJs9CDzB8jRBoweY2rkaOxTcGZzu6XhxRG6tShyo2qv3eak6o5E9lF4eLpV/Q7FXu1dxkLvTe6PlVoX1vpFjJdXThY4xknqfQetOMeTozzZGoUjP/Srr+r6Fr/Z//o5FHLfXayWwDKW4M4PFj0x1o7pY1C3lglu9RuZboD7R2kPAx6+Hlj4UP0eOW9um1vUkxcSjht4z/cx+XvPWjEZ4n3612bk+9Hkz4xXFL+wrd6JovacKdTsIvrcDhmI8LqeniG5U/I0Iuewk152kudVnu4I+8VYo0SMnu415KOVErGQSSIOLu7qPaOXzH4T5itBY3yzs0Mo7q6QeOMn8x5j1o2tHI5Sxu4sDad2St7a6WaaVp2T2OIABfUDz9TVHt1rIggGkWGe9kGJeAZ4E8vea2gpFRVJKqATucDnTT+yFlblyls8VuLe6tbcStYXfBsq/ZY4j5AHc1pdE7NTRxftHUrV5GXxQWYG7N0LeQ9K9FKIzhiqlhyJG4p1W8jLn6mUlRluy/Z2a0vbjV9YkWbV7nnw7pAvRF/rWhmgaccMr4j6qu2feasV1Q227Zg3bsw/aex1XWNRhtNPtAlhb78cpCIW88cyB7qJaT2StLYK9+frkw6MMRj3L1+Naauo5Mv3ZVxXRUGnWYukuPq8ZmQcKORngH8Pl8KtiurqkzOoVr2jrrUC29zPKltkFkj2LY8z5UVrqBp0U9K0yz0q1FvYQLDHzOObHzJ5k1crq6gRBenFrKRzxUsQ4Y1HkAKhv/wDZ8fiIH51OKB+CvAftse/9as1WiGJ/ias0AxrnhQnyFRWSkW6Z5nf5114SLd8cyMCpUHCoHkMUw8DqSlrqTEMc8KknoM1DYri3U9Wy3zpb5ituwHNvCPjUqLwqAOQGKB+BJv3be6sF2wkzqoX8MYrezfu291ec9pW49auM8hgflQdHpl8gh2HjzdzydAuK10rcMbN5Ams52ITFvcSebAUb1WTutOuX/DGT+VAZdzPK7t+9uJX3yzE/nUujQ99q1rGOsgqoTmr2h3UVlfi6m9iFS/vONh86Z2tfHRru0hbVdSttFhP2Tfa3RHRByHxrL6lILJbhiEWOMkAfHYVsuytjLDbS316P7bet3j/wr91fgKwOtBbzXJLVQxhhkLykZ3OdhQZYHtr6I9LhkSFp5cd9OeNs9B0FWRx8TY4efrUhVMey3yNRALxP4W+RoOkN9lOL9oSBiP3R5VHqESyPIjqGUncEZFO7KAftNsAgmNuYqS8/euB50I55fmwHqSiO24UAUAbAdKGjjKDJXl5UW1RM27UHAXgHgbl5VTNY9FK/MiL4SOIjhG3U0xIZERUDKAoxyqSQJJeoOBuGMZO3U8qmZUP92flSKIrZSrqSRz8qmw3Dsw5np61HGqiRMRnn5VNwrv8AZknJ3xQQxhDfiHyqKQHbxDn5VIwXP7o/KopQuBiIjfyFMRzA9HA+FDdelaLTZQHBZ/ABjzogQuP3R+QoNqqie/srYR48XGwx0FNCZbsou4t44lYAqoB2qyQfxj5VGFAdvsvyFK3CTjuj8hQA2QeAgOKHa1M0OnuVcFnAQDHnRBxgEdz8cChF4ouNUtIBGQsY71htv5U0Sy5ZwfV7WKIOMKoHSnHIkH2g5HyqQAH+6/So2A7xQIsDB8qBHHP+IPypDy3kH5U44/wv0ppGx+zH5UwIUHg/eAc/KmPjrJ+lSRjAPgB38xSOT0QD4igkrTHIX7Tr6Umene4Hwp0vFgHhGMjqK45z7A+YoAjJHSbHypq8PE2ZP0qViwI8A+dM8XeNxL5daBMUspG0mMeopr8JVvtW3HmKeOIn2Rj30kvEEICjl50xDI8BcmU8vMVZtGC3URDk5OMZqvGX4RlRuPOp4Gf6xEcDHEOtCAL3RzE3OhNygM8oPI7/AJUSuSe7bnyobcn7SQY+6D+VaDYR0UD6iu+cEihnbOSSLS1Mbsh4wDwnG1AF1u6s2eFYwVU7HBpk/aWaRAk9tHIuc8LZNKxJg2CKW4bESvI3mBmidvpN4QAIsZ8z/SjenK8kKycCRcW/Co5URxIqjhkYe7arKQDi0S9jYP3e3lUd+skH2ckfCxHnR6UMw3Z2xz8RrM3cWbhi4J8tzQN2CJI27w7itH2UUxpcLISASCCp/pQR7dePIZvnWh7LqymdVORgHxVEuhILvwcLbuT7zSJ3fAN3z8anYScJHhz8aaofgGOHPxrMZGRHk4L/AJ1Xm4TIMcfL1q4RJ5p+dRyByy54c79DQIh8GBkP+dcQmOTn51KePHNQPcaRg5GMr8qYy92SOnMXW8jlaZHPBwsVFekRaz3aJFIiyQkYwdyBXlvZ62M+oyq7BYVcF2AyRXopsrJbfjhv1fA5FcGmkvJ0Yop/kgRqOly/t5b3R7VxCDlidl9aPx6kloA0EaLI/tgHOD6GuTUOCzNnb44WH7yXYfChLKVJU7kHmOtEUa44K2mXdVliuuF1lZmPtDyqkpVSMZwKVslaYdjg8sVokbJJaN1o3aG3a1SFkZXRdyeXzqHUNSOpN9Tt3Ku5wfLHqaxnFIEZVfCNsR1pyuw5Mc8s1HBdmC9LBNyXZ6PoVpBa2/DBN3h5Fgdqlm1a2ivRa94C+Msc7L7zXm0VxLD+6kdM8+E4qOWRyc7ux55POl7dvZi/RcpNyZv7rtDYxceJDI6/dUc/jTbbWomt3uJ5Y1H3YlOWHvrBD3Y86eHGMczT9tGn+DhVG6sdbt5kd5po08k6getN097e9vjPb2gCrsZWPM+6sMj8J57VcgvZ4Y2SOZkRuYBxmjgvApekSviavVrmbThM1tbjhk3MoOwPuoHp+sTWbScMSSvIcknY5p11qmdLjtIeLf22bfNCCr7ECiMdbHiwri1JGl7RMWsoppJTDdsoBiR9iKA6ZaLeO6SHIxtvV+wt4L2I/WJCJR1J3ofFeCxuDwMCqNz8xSXVIqEeMXFEqdnLeyvVu5IjPGpyUNFI+3mmrNHaW1lMX4uDgCgYq6j2Gt2YSSdRC2OLhfFWlm7OaOEVGtI3zhcYLZrJu+zz88rdNbLOp6VZajAj3EfdyYzldmFVVL2FqVsOKRVHJzmjM4gkiE0pHBjIOawfaXtF3CXD23DHEqlR6mnFNi9PFz14BGqajAJ5ZZ5I42zkqD/KgNk76pqJun8NtDsinqazMrmSRnkmLMTkkkUS0mSSVWtVuG7tjnu4wOOQ+QNa8jtWW3T6PQuzOkW+pySXtzIGhB4UjDc8dTWlWDSI37kfVg5+7nevJLvTNW0aLvJpntIpPZUPj4Vb0Xsrq+qxi6jkeNSfC7tgn3VEr7sxm23bZ6ysVrbkCONGc8t8mm6o0MOnyvOFC8NZ3stpOo6HPO+oym5Rhs3FxcNRdo9Y/aIWysUZsnDbdaIR5MMcHOX6Aekm6lviliWyx5A4qr2x+jjVNXDXUd4zTAZ7p2JHwrQ2PZjUogs0UqwydMHejumx63GHW6kjYL7JJ3NaTkn0zozZE/xaPm+2v9b0TU/qLXMkLI3C0cjHhrbprWkXcQtbu+hmnk8LBVIUH3minaDTrS91l5dQs42nV9/I++gPbKO+j08o3Z2wkgx9lPAnCUHwqtov5QpmK7WabPpN0UR2lsn3jJOQPSs4W93zozJqN+bFrS6jJgXpIN191AwobJyB76DGbTej33sTdx2f0a9mZGOT+yrXA8z3S1HZW1zql00xdlA3LfyFZ7shcPfdj+zFuowqadbJ/wDql3r0ixhjtrdY4yNhvio/FHTD4QVdktlZRWSKI2Dsd2NG7eUgqBbgSEbY22oSpq6t4WVeP215MKyZjNNhWOL7XjLHl7Jp0rxhcMRnlyzQyacLKJInLZHiB5VHLcNKcnYeQqaMljbCEMEiOXSTG/IjY1ZWdDJ3fEDJjOBQ2zaR8gyMsYq5ayxTgyxFWA8PFjegmUfstgb533p1VI7rvGIjjYgHG4xST3Xcg8UbAeZNIji26LdNQtvxlfhWfHaJTKyJHxKNgRzPuolZW/dFrhZHlaTfhbpTca7LlicPyCDMFGTypBh8HnTUJfdkKmuYcZ58JHkaRmDpphp96SRiCc+7hf8A51Dqcv1y2HcHhuYzxx+pHT41Y1WHvoTFI7FW9OXrUenqrQMCoa5jPC4J69CPfTRapIhk7p9I4cENIvErKMkHp+dV4b+O5thJ4o5WGGK8+IbEH41Np4urS7ltHKBJMywht/8AMP50Il4oNWnhYrwy/aLwjbP3hVI1xpOWwhBLGsubkNJjpmiiXllJGUYBV8iKAEipbYhnwRmqa8m08Seya5ESynuGJSptM7s3atKRt7OarzoqIz7AKMn3Vlh2z08CQx29zKEOM4Cj4ZNLtEyceNNm61W/kRWW25qMlh0rA6Ki3/0hXEl05uobP7NS+PaPkPQk1Xn7c2N3byxRpcwEqeIEAZHlkGjX0YI9ppEstzE6yXL96JPa4x5Gpao5pJOlEJfSbqRsezrW8JPf3bCFAOeOtUPo/wBMCXzMB9lYRCBTjnI27n+VBe1l+updsuZa10uLjI836D54FbPQbO703TraENmaUd7J6u25oIUeTNBeXKWttLNKcJGpYk+lZfsgPrWi3N6QWuL6ZnORkgch+VRdv725i0pLE8Be6ODwncINzRTs1ZPZ6PaBgFCxhsD13pUNILWdmkMQ4kUyY3OKp32mBhJJbQKrHn5tRVGDoCKhaW5Unht1Yej71IKUk7MdJZwoxVoFU9QRSPBBgEwx7elF9aZ3kVntzEfM9aFSexQd0HyVkrxQSYBgjAHkKbLbWbEd3bqvvFOrqB0Ri1g/wk+VcLS3H9ynyqYU7emMh+qW5/uU+VOS0tlO0MfyqQc6eOdBLQ62hjjuYZ4o0R45ASVGMjrWzufFbsV6DiFZfTo+9m4SOYP6VprFhLZR5/Dwn4bVJ53qu0XkbiRW8xmlqCxJNuoPNSV+VT0ziemdXV1dQI6urq6gDq6urqAOrq6uoA6urq6gDq6upcUAJXYpa7OKAOxXcqqXuoQWi/aMWc8kQcTH3AUOsL2bV7q5ilgltreHAKswDOT54Ow9KTdFqDq30X7nUYYZO7Xjlm/w4l4j8fL40g+s3CEzYto8cgct8+QqzBBFAnDDGqL5KMUP1m74I+6Q+I86aVjVN0gVdyqW7qEcMS8vX1queVdy50xmqzoSoqybMaikiSeJ4ZBlWGKkm9o1Hnemaoxubns9rBeEFkOzp0df61v9Ou4b+2Se3YMjfl6H1rP9pDZm0jN3MkMrMFjJ6mg+hXMujayokJW2nISVTyB6OKxyQ1Z2Rlzj+z0F0DAgiqkkABzir+M00oCN656CM6BM3CiksQFAySelYppX7Ta5CgyNOgfKL+Mj7x/lRjtxeHKadAcNKOKUjonl8aA9nNctrK9kjNu4hGI+/wBuEH3c8etbwhSNZSfG0byUhQEUYCjFdDnvBUPFxeIEHO+amgO+a2/R5zJ3TxBl51eiuEuVSO74ldD9nMhw6H0NVVO1O4QeXOjszew9HJf26cRCX0PRkwknxB2P5U+11qynm7gyGG4/wplKN8Aefwobp989s3C26dRRl4rTUoQJoo5k8nUHFS00YSSX5It11CX+s2NxHDaqskDg8KyOcgj7oP8AWrUN8hfgnR4JfwyDAPuPI0WRxfaLldTeNce0PnXB1PJh86BUOrqaXUc2A+Ncrq3JgfcaBDq6urqQHV1dXUAdXV1dQBWvdzAvnIKs1WnObq3X1J/KrNA2QD99/wAR/Sp6rZxPj+L+VWaEDK90ctCn4nH5b1Yqs3ivlHRFJ+dWaYM6urq6kIq3PjuYEHQ8R+FWqqxYe+lf8ChR+tWWIAySBQNkc+0ZrzDV5O81O6bPOQitvfa9b5khs45ryVfaEC5C+9uQrzq4a4knlk8MasxIBGTnPWmjs9NBq2zedj4+DSQ34nJqbtU/Bodz/EOH51irbXNUtbZIYpoo415cMYJ/Oq2oarqV7CY572Royc8IRRRRfsNz5WD2ABxRPsbYJq2tF5d7a08XD0dulAJ+9aQQxyuzH2thsKu2KvZoywXV9GDz7p+H+VOjonG1SPT+0GpLpWly3BHFJ7MajmzHkK8yine0aYTqzXLuWlbA3Y/Gqcj3F9c8TXeoSQwnws0hYhvMV0lu2SxkumJ3Jc7n8qKIxY/bLp1Ifgb5D+tQ/tNQzEo+/oP61QeyZmB7yfn1P/KoXso+LDbg9XYnFFG2jUdmdds4tVzdTJDHwN4nIA/WiMl7a3DGWGeJ4ydiGFYizgWO5RYAzknhwg5/Kp5ols72IfV2iMuQVK44vhTSM5QTdmg1BkeFzGyn/Kayr6xFGOFlkJG2yj+tXLgFI2YxSIMe0UIHzFZq4hYxGQEMOZx5UMqKovRavEniZZOJiWbCj+tPOuQeUv8AoH9aAkkkADc7UVvOz9zb6c120kZCjLJvkVNibS7LEWtQvMigS7sB7A/rRncFsuBudsCsXpiGW+iUfiBNbYqONvs87nfamJkbA/4g+QqCckAYccx0FTsBk/ZfpVacDhz3fX0pknODn97t8KC2f9o1y7lL+GJRGp2otcOIoJJGj8KgnpQ7QIith3rR5aZi5O1MReXZ3+0HL0pp25yj8qU5704jHIeVWI7dnTiKqo6ZoBlGRgASZv0oVo/2091dNJjibgXOOQotrK/VNOml8BOMKMdTXadp/wBXsYULLxcIJ8PU0ySPAxgy8/UVG+ONcSnrvkVf+q/xp/ppv1LLA94uB/DQIokA/wB6fmKTC/4px7xRD6qM7uP9NN+rAcmH+mmFgxcYOJTz8xTG4TzkPzFElswAQXOP8tIbVB98/wCmgkEyhSn705zyzTPCCftGPxos9ohGO8bP+Wk+qpy4m+QpgCwFycyN86jDL3jBpDyGN6LfVExgu/yFRiyQOWDuc+6gTKJ4Qf3hz/mpG4OFvGeWwzRBbJQwbvHwPdUF4qRYCtuc+0aBFOPgCrxOeXmacbiK2HfuWKxniPM05CxUEAEe+ubiPMKVPME0ACL7teryFYYT3PmTgmqk/agyvlbYAYx7XOrtxolnLIGEITPMI5FRy9nYTGDa4jkU5HESwPvBp2LZa0K4WeB5CrKpO1SzXIDtFBGZZBksSSFQepqsLjVYx3TWijAwJIRkfLIAqWCwuLhMXP2cOSTHxeKQ+bEfpSKCUEyRwIZJEUcI60kmqWar++4mH4Rmo4+xOoRwJdahBciFxxIVXw8PTepY9JtId0hBP8RJrVOxqmVf2rEzYjRznzqGeJ5AzAAVfe1iGfs1GOuKH3UOcgDHupsoDyyBH4TzHPFG+zjxtJKMk+Ecsn9KBvbLxk4IPvo52YgMVxIUO5XfNTLoQdIiIOA/LyNIojCjwN67GpiHwclflSR8ZQbrj3VkMh4I85CP8jUcix8a/Zt8jVoiTO5X5VDIJONPEufdQKjoLdLiTu1XDHlnIqeTS5kIzbu2fwjNSWFssxZpLhY2X0rQ6OXkZo7aaSbgHi22FUjWEU+wfo/Zq5iP10MYXP8AcuOYrZ6bpdpd25l43DL7SetQSQMYftp2z6nal010ClVkKsD4vdSvWjZKo/FjryO2cLbSl1BIxwDcUSiaBk+rd2S7DhDHG3qTQjUr2HjAgwg5cZO7Guso4p7rFwzlACxw2MmhR0HHVlHULdrW+W3mIeNt0dD+RHnUj25ZuG3DKQMsDtt8asYtxL3sGU2IIY5x7qr3Vy0TgRENtzB51SbNYtlcgqSDzFIfdSyuZGJIwT5UwY5ZzVmwoY53G3nS8WOtQySJG2HYgHlUqxZ3RiT5UAOz1B50q7nypsjkAHBI9DmuDqR4TmgQ8Yz6VxbByPzpmMnlTgoAHOgZbtXDToW3A51obu0tWtDMhAbG2DWcjhBAYSjhPPAzir6WCcJHG7cQ/EQPlWc3s58vfYPnhu3cmEpwDzOKzuuNIluWikR+I8JVW3Hwo9+zb23uig1FIoHPJufw2pLzs4dOvIruHjvZDlghG3vqeRlKd6MrfXk1vpcFqkEkRYZcnahJlk4gwXfnnirVavBqusziN+BY1GQqnABoamjrYzBtTc9znkjA0X9mU7b2QTa9qk0CRSXMpjTkOOq1zqF3eRqsx4gOma1ltoumtdW9xG0qpnJikXZqsz9mrSTU/rPGUh590uwzSsFB+DFyaddxQCaaDuoyMgucZ91af6P7yy0+5eW7tnZ/uyBchaI63o8usTRhZjFDGMDyNVtZebSNOjSya3KDwsynxj1xRd6CUPsJX2t2PaLX7e1mYR2EJ4uJ9izeVF+0vau10i1WPTzHNOdlVTsorza00nU9Y+3ijmkQkgynZR8ahTQL6XVPqSEvIN2ZCWVR6mlSMuCN5pPb9biFo7q2/tG4yp2qXszf2MNxcXN2QkrHK5HIVmZez9vpUfeTamEk6hh/KrvZnTX1ySYRyp3cRxxjr8DWkHGqZ0wWOMWpeQ3qnauQ3IFmAIVO5PNqsRdrllHCbbhOOfFVS97IyxJxR3MWBz4ziszeQ/V5zGsiyY+8nKtVGElo3x48ORVEv30kck7zy4LMc1TkvUYcDqSlU3LHrmk7mRkLBCVHM1ooo6lFJGY7b9m4rmz+tacp70HLLnmK81eJ42KupVhzBFe3NnhAztVC40myuJDJLboznmcUuBhk9OpbRpPop0KCDsH2eu7kh2k0y2kA8sxKa1MdqDG0uURfLrVX6Mo45foy7JqzZH7JtM4PL7FK0F9DEYCzDdRtvXFybOOOR0rAo57U8etX9Okt0tmdmHFnBJFV51dsusZEXRguM07NOe6IhS00AnkCa4kAEnkKCiaW57uyaGBGa4k2AFP0jTZNOCyJNJJx+2h5CsneapKt8JbdypTZalh1S7gHeLO3evuT/wAqtwdFywyqkeiZwPOqF1FBfW5MnEQDjh4uHesTNe3lzOn28plJ6HGK18USLbQi9mM7KM8IGN/WoceJzyw+3Tsfp9hZIwK2xSVeXHzq2IZDKW70ADyqKISSMJCeCNTsD5VZLMGLYHd45jnUmUm7HqSrcDMWPninca4J8qpi9HCQQc55iobmVlTiEwKHpyooFBsISOqrxMdvMDlQm9nW3YX0brIqjhdQN2X/AJc6l08vOxLlgg9nB/UVZuoUMeO64j6CgKUXTBt7crdWKTW5xNCwkjGefp7iKj1O4insre+tVQtHiQBl5jkw/Wo7MJBdNazlxG2TER081/pU8cEcNw9jIOK2nBkiztg/eX+fzplOkypKQ8uX4FGMjg5EU9BFkFcZFQ2cZbjsURQbdsB+rId1/p8KSWKSO4C+BQPM5Jqrs6YtSQupNjT7o+UbfpXl2mqAnIb9a9P1F2h0e9yVfMTcxy2ry+2Y9wQDvinA5swl1El5NHZ26xtcTyKqtjkOtepm8OhdnGkmeKM28PsDcE42xXnvZiMXXalJF4QtvGBsOZNGvpR1Dv49O0W1J7ydg0gHl0pS7MoOrB/YS0fU7uNpUZpbmc3UxYc0U7D4t+lesSAmeN5NugA6Vjfo+tfqpubn6zxwL/ZolK7lV6+7Oa0naTUxZaLcTxHLBcL58R2FQ+ykmjJavK+q9ppGU8UCSC1Q+g8Tn+VegWh404hKHXoAMYrI9jrWOKdzOR/Zo+7PF1lfxOf0FGHlEMpa2dgc755U6sqMOSoNM4jOHPPlmuhkE8fEhx091A7i7lmQLI2R6VXW4mtXBik3PMUqL9i1+w/cWsM7ATOSegzihepaQI4meBiVHQ9Kr3l+bpU4kCyL98Gqs083d4MjkZHWpKhjnHdiFcUoFcKWmbnU4cq4ClxQB2KcopAKeo2oEwjoe98vuo5pvg7+L8Ehx7jvQXQ/9tXHkaNx+DUZB/iID8qk871P5MsWh4ZZk9Q3zqzVUHgu0P4wRVqmjjkdXV1dQSdXV1dQB1dXV1AHV1dS4oASlpksscQy7BR6mmd67/uoyR5tsKQ6ZNUU9xFAvFLIqD1OKiaGWT95MyjyjGPz50sVnbxNxrGOP8Tbn5mgdJdjUuzMf7PE7D8TDhX896jntHnybm5cR/giPAPnzpb7UrezU94wLfhHOs1qOvTTgpEe7Q7bc6dfZ04fT5MjuKpBTs/Dbpd3ksCKq54c8yfeaJaZEiJNIpBMshcnz6fyrI6ffG20u54W8TycOfIYovpGqxroMTq3E+WXHqDQkX6jDJNv/YK6nei3ThUjjNZ9mZyXc7mmGYzSs7nJpHfNX+iIQ4oR2qLPOlJphNMshn5iqd7dxWVrJPO2EQZ958hVyblWG7S3xvL0W8ZzDCenVv8AlTX2zXHHk6KM8k2pXMl1crxM2wXGQi/hohZETW/1S6Y8IGIpG5r/AAk+VFdJt1htFUgZYZarMunQSjZeBvNazbb2zp9xLQQ7Maq8ubC+OLuEeEn+8Xz9/nRjUb2KytZJ5mwqDNYa8tri3KSAniiOY5V5ofX0oVr+vXOrXNlYwIxmB4poxyyPM+VZOKTvwaRxqe0N1Gea6mklIPf3Byf4R0HyqpPZyW8ShomRMYGa09lZrCqvKQ8xG5xsPdUl5CJbfEq+BuRrVbJeWnSB/ZTVH4/qFw2QBmInn7q18Ps++vNbqGSxuVkQ7o3EjVvtKvEvLKOZPvDceR6iqOfNGtoLIc1KDVVGqYNQc5ZBB51YsrprWbY+E8xVFW3rnbfNAmr0aLWJEOm/WgdoSJQR6GrjPFLEnEFeOTlkZBrLz3PFod9Azf3TYz7qGdn+0IQWNndtghwFb0x1pcdCj6aU4tx8GqeytLW+jJgj7qY8OCNlbpj30RFtAvswxj3KKr6lEt/p0iwuC2OKNgeTDkaTRb8X9hHI2BKPBIvkw2IqaMJcmrLfcRc+7TPupklrCynEaBuhAwRU9cTigztlG2mumXDQoQp4SRJucemKma6Ef75HjHmRkfMU2M93euvJZBxD39anmUPE6nqMUFtq+hwIIBG4paHWcVzFCnBKJkA9mQYI9xq5DMsucbMNip5igTVdEtdXV1MkrMOK/T+FCfzqzVaLxX0x8lAqzQNlWQf2jP8AEtWary/vfl+tTscKT5UAyC3y0879MhR8Ks1XsRi3UnmxLfOrFIGdSMcDJpar30nd2sjZ3xtQCIoJVitJLhzhSWc+7/5FCrVbnX1764LW+nk+GJThpP8AMfKkvZVliVJH4baMABR949PX1xROC6EUSqlrcLCoxxFMbe7OfyoNK4r9iX0UVnpUywRrGiKcKowK86iGYgTvnNej6mhvNLnS3IZpEPDg8683vJP2bKLe7V0k6gDOPlTR0+l6a8mm0vQra60+KaZ5eJxkhSAP0oB2wjg0yWG209me4cEsGIbhHQnyrQ6W+pXemwRWcYs4cbzy4LEfwr/M1nu0tlBY36xQ8TPwcUkjnLOx6k0IrG3z2wFbJJbglXy7HLMRuTR2NDdWFvaW5Z9RumIyDgRxjmxoJczCGPJ9o7Ko6mt92M0hLDT1uZfFd3Chnc9B0UelDNM0uMbEuNCsdN0WTuhIDFGSDxcz5157JczuPFM+fh/SvTO10vdaDc4O7AL868wdfMUIj07bTbIWklAP2rn4ir2lm3nikiumYSn2W4iD8KHvsagfJO9DOhqzW9m9Lt4ddgmWeWV1B4Q7ZxtUfaOMrqdpwxFwZSCQQMbUN7Ft/wDfJa+uR+VF+0soh1GzO5Hf4/KhGTtTBkylVmjBxttQi20JLu3LtfPGH24eEUT1iTg4mjDB28IFYK6ZhI4DMME9aqXRrVo057KRKwYX52OccA/rRPWwP2BeDmAleeoziVDxsDkdTXoerLxaHdgdYv5VmzOSpqzG6BH4zJjrgVqmPicceN+W1AdLTuokX50fYnibwA789qstkbesv6VXmwEP2v6VZOeiAn3ioJslT9mPmKYgT2gmKaeY0ky0rBOnWrkCLDBHEsuyqBjIqhfL9Y1u1hCbRAysM0WIPVB86ZJX27w/a9PMVLLfNEYYIYe+fg4yeMDG9NPEJCO7HLzoBrUF1LOeCNmU7+EZx5CkxMsaxdz3d1a2jWvDhu8K94NwKvNf3Izm1jHvmH9KylnZCYSyy5GDwj309obRThlkLDnhCaZJpTqU4/8AZ4B77gUw6nN/hWw//uBWZMVoP7qY/wDu6VY7YnaCc/8Au6BGk/acoG62f/8AsCmHVJTnP1If/wBxQAxwdLWY/wDBTWSIDItJv9IoEHjqr53exH/v6ifVnHKbTx/700Ek7pbZXNuww3snANVzcW+Mi2f5imKw8+sMOc+nj/jNMfWX/wC82AHvY0Be6hx/srH/AIhUZuk/7r/6qCbD51ttj9Zsfk9N/bT9Li0z6RuaA/WkH/sw/wBdT2rC4Vz3SpjyOaBWa+ze4eI/WTEc4K92CNvjQ/tGMQRHJB4uYonZqBbx7c0FD+0Q/sqFfxdabGC9MkBVgzMcDzNEBwlc+L86H6MXJbHDjFFAHH4fzoQEDhONPa/OplEYGcN+dcwk4lPh5+tSqJB1XHuNMaGJwE44WwffUiKgJyGxn1p6hs81+VOjDlm3Xn5UDPa7bEnYayOMjuBzryfUVCXLgcs16xpY4uwdl1xD/WvKtVwLp/fVY+jPEB5wdzzAoTdSKdlOKMXBHCwPWgN74DgVobFCRsPz3ovoL8VweIE+E8hQV3y3L40W7PZN4ApC5B3NS+gRoWEf+E3+k02IR92Mxt/pqYq/4x8qigD8A8a491ZDEIQHIiP+mopFTjX7NuflVjDgnxjPuqKQPlftBufIUCIyij+7OPdVixvriwdmtGeMnnwimoOFwXcMOowK0WjWUFw2Uj+zfmXplxjyM3Nrt6shd5HficAl+g9K1HZ94oJfrl7MzW5HEVI3z7qh1PRNOtr2Oa4kJteIExKCSzdBtWmgVZZ4mXTzKqjKoy4wf6UX4NI2tMGvr9trU4t4LPuwjZSR1GfhjlV+70w/Vy0k7W+22GwW9MVVudCmn1d57ZVteFePu0HM1FqEN1bupnDgkZPEc5ppWaQVqiLUG063xJcSCOYLgcLeL5VHHfW0lmh7zJXz5mgV9PYOzK0RSQ/e9ar6NaXMt2ssZ47dDvxYwaOg5NOkawSK0AxEwPME86YyMCMpw5GQc1JNPLsIRGM9CKa5dyq5xVI2TZBePEkBMoD45D1qjZl2zKSys3TPSrU99Z6fcNHfKWbhyAN6K6A1jqcgBQrCeRUHINLkRLIkCwzBeeKs29tMeEmNvGMqcc61N72bimdZbcqEH3QueL35q5DaxtAtu3HGQMAhMD4UvcM36pVoxrbHBOCOlOYggbEmtXN2dDlQkirEOald/nQ2+0cwHhXZM4DY3NHuIqPqIy0DrRJk8USnejGkWzXj91dSPGFIZWU4J9D6VdtNDgjhEkN2zEjOGxii2ksDF3bx4Yczw4BFZynZz5s6lF0VLvSZTeLKndtb4wYiuc0Se0Eluqn7MAYwBjbyqxI5QAgEqOYA3oZqNjHqyxlJZ4wrb4YqD8Kg5OTlVsBarZWt3fS2DP8AVhGnELhRwAemeprApCLXtDGkUiX4VsAk7GvZ1sI+4MTsZF/i3z8KoXHZ3T5ILgPbI0sg2cABl8sEcqaZSy0zJ6j9fEAeCKF26rzI91T6XZ3VycTuFLDYeRq7ovZi5sbd1ur8GRzlQRxFR5ZNaGKNbWLghXLAZLsNqdm3v6+JTsNO7m2ZL0I5zsy5O1V5dO0yyt3M1uqFz7QHi+FFba6Eh4SRxenWotTEMiBXkCyKcjA3BpWZW2/kQ9nYLS2sTDYrO0TOS3erjBqza2kdqZFiiiVWPExROHiPrQ+1uriOYfbFoz7Qff5UVNzACOJwM9KBSi0wPr/Z+01S0lxboLjHhcbb0C7E9lruzeWfUGaEg8KxK2x9TW4V0mUPC78KncAc6je/tE48SeIdADRYlKXSBsmi2810zzSTOv8Ahk4FZntDo4tX7u1tg/HuCGyR8KKNJqdxdTPDK/dkZCZyQKz1xFqH1wvcreMPxIOYrbG232duBST3IqxQ21oxTU7ecPzABxQ68dTK3cM3ddAavajLZyYWKK4WQbEyPn8qGyx8J5g10r7O+H2yHB+NVZr6KGQo+cjyqz9WN03dlioPUUPvNFsoJyklyeLmedTOTXRGXJKPR6J9F0WPox7K91FlzpVqff8AYrWg1Fbl4litXSO52LKxzwjzxQD6MbsWX0ZdlZJAzN+ybThVQT/critRaRgKZXUrLL4nycnNcXWzzIt6ZHA4eUQymMlRucdaI2/AEaNwGVvTAxUSpwn2Rk9ajknhikEczcDHzFHYpfI6YdzbNFZxoHbnwnNZPtG62sKxLLmVxllxgr762dxJFbW7T95kxrnYfpXl2qztdXckrZ45Gzv0rTErZv6VXKykMlsnnVy0Xjky+6rU1hahznGcDnR/RNNQytLOoMEY43/pWk5paOvJnUUM0u1WNe9I8bfkKM2du87Ex8JK74J51KbX6w6SWkBELbjJ2NGra2ECArEiSYwcGsG7ODLn1+wS0LzsxJdcbEEYqxa/boU4Twrt76KsMe1grzOaqy3EFoPuRg7586mzBZHLSRQ1BYLaBmYKCKFQwtO4NzmJOajHOrq3MOs3ZVOHuITnHVjV2fhCDJ4QOtO6N4ycFT7II4FiwFY8fQLViFnZcyLwnyrioyCVB9abcl1t27p1EnTIpEt2U9UteOElCVfOVKj2SORqh9de/tTG0TxX9uQw8OxYeXoaqXE8k9wQZSGX7vEcE0l29wOGeNnDIOFwh9pf+VM29vWy3fTQcNrqPiSCQd1MAccPln3Han21kLqPvFbEZ5N1ND0QtK1s+Hs70FlLcg+Onv5/Ci2lTNPYJ3UiRyR5jkU/iGx/rQSm46QH7SQG20a9PEcCM4PnXlcMnDFxE4UDc16h21GNDvS7BmCEgjlmvJJ3/sixL+8mIStI9EZndGk+jtSJ5p5QQDluI+VU7OWTWe0N7qW7BCIbf/Mdh/M1JcTvZaJLHag99NiGMLzxyNH+y2krpywQvjNrH38x85WGw+ApMjGrZqdBtlt7UQIcKrcAPuob2plB1WC1ZuOG0X61Njz+4vxNFEl+p2JkmGAil2OfiaA9nwdRu1e5zxXEn1yfP+Gu0afPepN52tI1mh2ht9JiSe245mzJIx6s25qKdAJGOy/wjpRj6zGyIeLwscZqtPbwAkpFx+fC24oTFCXF7BYNczKAc7N7qVyvGeFeH0NNdeJcGqZ0kXCpjBHteVMmQhPEOorgpU7O1c65U8TPnnzFZsdjqcK7C9A3+qlAX+L50CsUc6WlAH8XzruHyLD40Cs7FSLTFXzZvnUiqP4/n/yoE2EdDH9tHuNGrrwXVtJ/FwH40H0YYuQwzt5mjWorm1ZhzTDD4VJ5+f8AMkn24HH3WB+FW6qv9rbnH3lzU8J4okPmKaOSQ+urq6gk6urq6gDq6urqAO2AyaqPLLOxW28KdZWH6DrSzsZpTEpIRd3I/Sh0Wp/VNQFpcMGjk/dSDl7vfR2awg312FILWOE8Ry8nV33NSvKie2yr7zWe1nW2jlaC2OOH2moBPdvK2ZHZj6mnSXZ04vRTyLlJ0bW41S0gUlpVPoDms/qXaB5QUtgY1P3utAnlGOdVZJtzg0uVdHfh9BCLt7LE05YksxJ9aqySetQyS+tV3l9amz0YY6L3ff8AVrY59+c/IV3Z2Vl+uwFshZe9UZ5Bh/UUMFyGtp4+qyBvgRiobK9W11eFnICTL3LEnkeY/OmmZ58DljlRs4X508tVSB9zUxbatDxWPzSE7VGWqK8uorS1luJ2CxRqWY+lNK9ImgP2x1f9nWKxQN/a7jwRgfdHVvhWQtV7l4u8zwk7k+ddBLLrusSX9wCE5Rofur0Hv6miF3PaxqY5XUv0Rd2+Qpy3pdI7IR4KvJooD4QatI1A7S9neFeG1cnH3yEzUxbUZR4ZbeAfwoXP54FRohxYayG2IzWflt4rDtB3gQAXacIbyYb4+NTjT55P3+pXjeiMIx+QqObQLCfh+srPOVOR3kzHB8+dS/6Kj8fJaeQDrVeRyRz2ph7O6UfatFPvdv601uzeln2YXjPmkzj+dO/0LRS1Ze9jjjA8bNtTtHvv2RciK5bFtMwHF0RunwNPm7OKjB7a+voyOX2vGPkwNUbvS794Xhe5guYmGCs0fA3zX+lVZVKSo9ARtgRUytWI7Narf6dafVNehcrHtHcx/aAr0DY3BHnitba3UNzGHt5UlTzRs01vo5pwcXTLfFvSu/hqHi3prv4SKCaK2r3HdWEi5wZPsx8aBTRhrq1kHIE/pTdcvTNqcdqh8EC8b/5jyFQ/WD30abYAJqJ/R7Xo8Ljjv7NFp+o3NmfsJmA8idqk0jXWt+0c1vIAiXi96mNhxjmPiKCJNVLXu8azS6tv9ptHE8eOuOY+IpKXgeT0sZp62z1VNSJ61L9f4hzrJaffpd2cFzCfs5kDj41dWc+dXZ4Tx06NDJcl7ZZl3eBsn/L1qZb0Fl8iaDaZOHmMLnwSqUNRRSmMmNj4ozwn4UiOC6NTbbRkeRNQiIvxtGeGRWPCf5H0p9m/Er/A/MU3TZRKszDl3hFIx2rZLbTiVSCCrqcMp6GpqpXsbxyC6gGXUYdR95f61ajkWSJXU5UjINAmvKILPxS3Deb4+Qq1VXT8GAt+JmP51aoE+ytOcSfDP5069bhtnxzOw+NNuva/4TXXJ4pIE55biPw3pDJ414I1UcgMU6kzSZoJFzQDtZqEVtDFExDMzcRTO7AdPnRXUrtbKyluGBYRrnArJaOovjcapfqrFpAqFhso9KKNsUf9TCOmwLZxJf6gQLid+NsjcDGygUYS+dgHktJ4oz95gNvUgHIobpV0+qXn1t4gLdGK2+evm1HadCn3sq/WIbeUBnVY5fErE4GfKvOb+ZbztNeSqQyLspr0O+sRPC6IYwG3KSRh0J91eX3byWGpSyyBWjkcqeBcDbyHSg6fSpNs9K0YY0y3/wAtYTtddRjWrnibLLhQo5nam/8ASLVdQt0sdIgdMDhLoOJj8eS0It7OSCZ3uSTPkhgTkg++hI0x4uMm5MbBA0kwlmHjY4Vfw167aJ3drCn4UA/KvM9Pj7y/t085APzr1GiRn6l9Ga7eS8OmRx59uQflXnz+nKtp9IEmGtIwfxNWKJOaEa4F8CBx5VWkOBj8qsTHAJ/KqcnETz2NNm6QY7HbdpLLB6n9KL9rBjUbI4OBcDegPZxJv21arauiTFsKzjIHwoj2psCkqPc3c87iVcknhHPoByoRnJfMi1kiSdiPZj2+NYS/UC5lBH3ia1d9ZpHGe5lnRc5xx5FZW6U97JxHiOedVLo1S0UcYkHvFel3QDaVOMbGP+VebBdxsefOvTpV/wCqWPnCP0rJmWTtGQtcA86NMcFsyEcuo8qDW+PnRtmYZwoIwOZ9KsuRBxLnBkPzFNkK8DHvD86mBduaD51V1GUw2M7sAAFPWmSCtJIn1G9uS5wW7tTnoKKsVA/en51V0KBoNMiAA4n8ZJPnV1g+d1GPfTZJXbhMn7w8vOq+pTrbWUsneNxBdsHmauMW73AA5edCtX4ri6tLPbxtxsM9BTQmVkg7nTLdScsQWJ9TVi0tkkjVm686samDwJkAc8Yp1mv9jjYUEojexQTKPumrP7PiVSeEVPMAVRjUqkNHtQFgZ7fhbIxipPqqNCdqnkQ4z609Ae6O1AGa1yERwoF+VAnjYttyrV66gaFc+dA+7wcChk1YO7ssMcsU3u264Iq668NMVCcmlRNFF18qu6YCscnwqJ1GDVqwU92+3lTJNZaEm1iJ/AKo9ogGsctnHEKv2G9nEf4ap9oB/wBXsRzyKbGA9HK8R2PyNFQVB3Vt/Q0J0guJcDABzvijID59oH4UIERngLr4WxnyNTDg/C3yNMZW4lwQd/Kpl4+Lcrj3UxoVVjB9lvkafGEy3gbn5GlVWG3EvypUD8TeIc/KgZ7PobcXYK0wCAIyN/ea8r1jP1mTcYzXqXZcGbsHbZO4Vh+ZrzTW4sXL++qxmeMz9w+ASaB3j94xJrQyoMZ6UGvo1UnA51obAeRgDgUT0Ahr1OJeIYO2PShsqHj25UR7PnF/Fk43xUvoRqSq9ISR/lpiKnAMQn/SKnIJ3Eg+QqJOILtKOfkKyKGYTrEc+4VHIFJXEWwPkKJaZDbz3I+u3SxwqMtnA4vSrtzpVldTgaZd7E7Kd8GgaVgOKONpVWReBCdzgbVuOzumRW1uzj7QPyPTHpUWn6NY2kqGV++mAwQwyCfPFHpOKOHEEYYgbIDw1LZaVFVILWF2nJ3XzOeH3Utv2hgWKU2arMqDiZwdhXXDqIkMiMHxnuweVZ50n00Xk4SPupRxd0NgPPfzppeS2r2GrPUbvU9RV7R8LjdxjCj1qDWpJLXVLOPUL1JLaVsNk4ZfePL1rD6bql1pzyPZ3Dqre0oIxiiNjd3Gs3oQRLMTuw2yB55qrFyv9FjVLNpr1oXEbW6sSkyYOR0opb/YWywxAIijoM5p7Wv1YBAoAHLFIkYdwOLHr5VaS7OmMElYibbnc1HfwahPAsmnIpeM5HiGflVi4VQ5ROY60xVnWJpIXYY5lTuKUuhyVoGdl9Ph13VJF1mYwyqeRI3x0xW7+pXukXMZsYIX0rk0ce7e/OKD6RqiW4K3MKMjDxusYDP7zRWXtQqQJFaW6pHjBBPKsmmcE8ORyNRZyrPbo0fCv8Pl6U2+sYryIpNkAHOQ2K8+l7RQzSrAs0sEqOPvYx6461rrWC6eKHuL9Z4HOXeUcWfTHSpqjGUHB3ZftmVAFjnikjQ4Yk7inXNtFczI5ZGVNiM7n0rParo9w908yTr9XIxhds49BVrTL23lh7u5jAaLcEfe9/rQPg2uUS79cFtO8a26BCd8MM0TSdGhEgPh9KHy3lnKd1yRy22+VMt7lIpZOHAV+o2A+FITg2uiW6vSZFNu525jFSx3Ms7qI+FF5sedVZ0lkK8LFsjIPDiqxaWNShyAelA1FNB1biMvwAkuOYxTn4sEBsHzxnFUNMnZuJCBhRnI51bd3AyFz7qDJxp0Q3E/dlS5ZsHHhTJpsiIUZ0clsbA9PhTXfL8selIIlZ+J856YoNONIhjH1dO84wJTvgjeq9xcNM5LAfAUReImJg8u55dBQy7QW6g5498Z6UFQpsjruHOwyD5jnSBiealffvS5xuM59KDQtRu1mgWNnDtuc7j5UUUCaAcHArkcylBVnkEgbjPFy33o1C0q23Hs7EdKDHIqBsQOmyfbqzBj7SJmhPahruWVPqFw5QrxcCnBBrNdsO2V5FcTCxl4baDwuzIDxv6eQFYPUO2urzkSC4jV0GVKxjIrWEWnZUJqMuT7NXdxurkzEmQ+1xc6rmQ8BUKCPPFY2HtTqNzbNPdyrNMX4d1x+lVbvtPqES8ad2AdsYzXQsiO1ethW0boNgbbUjBScsATWPftHOY4yg8TIGJPnQu67U6pHMVSWPh9YwaPcQ/8bD6Pa/orF7L2M7IBisdoujWuw34j3KY3reGFyDwgeozWQ+i7I+jXsng//ii0/wDgpRPVJ57OUSiJniPNixx8q4+zjjFyqguSRsTy9aewXuiSiO58+dDdLe3vbcyTYABxwg4ApNWu5Le0doY3PAMIq7lqK2DjuijrN5dThreyt5sjnJ7IFYpie+YSqcg8/WtnYQalfWROqTPEG5RxgAketCpNAcTO7skFsDtk8RraElHR045qGhulRZ4EQ5ZugrYzW31LRJ1RstweLPnVLsxpEMb/AFrjMgGyFhj44q72mvIbXT5I2wJJRgKDz9aze5aOWcuc0kXdC/7Kt/8ALVmVVMisZCvD686w2n6tqCWyxWwZkXyXNXF/al3vLGwB/EcUnGhSwO22zWvcwqPHIuD60C16Wzubdogys2NgvMVTk0q6aMFHQt+DNPhMVpj6xYSiTq/MUkgjCMHaeyp2eikse9FvC0sj8mI2Ao9bxygM1w/GzdMbCpLbUbaSMKkyIfIjFPHiyVPEPShjc2220Mk9khSFbkM01I/BwuQW6mkMfAxZsn0O+KdFKjrmMggUg/ooajpts0fHK2T0AXFULCzZZOCDjYk9TnFaJWh27wnPXI2q3EsYUmEKoPlTsPelFUZvUNPZI/q0p4YpjxROv91JzA9xNVNLaNb3DxgC5BVlP3Zl5j4jeierzTBpLebheNhttWSvrm5hmYNJmRirB+XjX2W+PI0DjGVXZZ7fwPF2Yv38Krw7AH1ryHTwZ9SQKc92uxPQ+deodvdSa67FXMnh4ZFXHmN68r0+f6rYzTbd4+y++rj0LLfk0uhMt12hM0hzZadGXOeTMP8AnWz0OJpbRDIMSTt9Ym9AfZX5Vg7KCSz0S3tE/wBq1CZeLzxzr1K0iS2t1QHOB4mPU+dJlYFtgPtTKWWKx7whZyXlP4Y13P8ASrvZ0JHbtPIOCW5Ibhx7KDZV+X60GhRtb1iR8HuZDgnyhU//AJTfpWou4cJxquANthtSbNk+TtlscLDnmqrTSQSngYiqscjIcgmnM5dsmps0okMrNktuTSK5FMFOFFlWLnJ8q5iSN64ClbkPfQKxwFOArgKdigVnAU8CkAp+KBWcBSgVwFOUUBYS0YfbH3UdYccJB6jFBNF/2nHpR1ORHkak871H5kNg3FaoDzXKn4VNYk90VbmrEVXtPBLcR+TcQ+NTWxxM69CA1BhLyWa6urqZmdXV1dQB1MmcRxluvSn1Xf7W6VPux+I+/pQNA7WZzZaceE/aSHc+tYPVLmXuGKEllPGPeOorV9s5MBFzy3rE3Eucg026o97+PxJ47fkfa6iLuETZ3b2h5GnvcYG1ZZZTY6oyDaC43G/J/wDnRGa5CIWY7VFnqLD9BF7knrUPfUF/aWXxjarYkyM550marFRbeXaq7y1A0mOdRNITUlxgQzXRg1GJScJMOE+/pUWr+O3G5G/MdKp9oCwtklT2o2DVNcSrcWCypyYBhRZrxRpuxut/tC3eG4YfXbbCyebDo/x/WtPx14nNeXOmXEep2A4rm39qP/Fj+8h/l616joWt2mtaXBf2MnHDKOR5qeqn1FbQdnz/AK/0vsztdMMl6wXbPVm1G9XS7INMkRzKqfeboCegFFdW1mW4mey0w4ZdprjmI/QebfpVC0Fnp0RSIeLOWY7lj5k1rbWl2c2OFPkytYaVcmILdTmOM7mKE4z725mi1pZwWq4giVM8yBuagttSjubgQQAyzNuFTeikek6hOSZbq2so/JUMsn8gPzrGUox1Jm/GT8CLgDJ5edTRMCPCQR6UqaJaw5aeSa9bznPh+CjAopZ6RpMsYf6hCG6mPKEfFSKz99X0OeGo2Dw3rTg3rRGbs/EVJsr+eJuiTqJV+ex/Oqv7G1cDwQ2tx6xTcJ+TY/WrWRM57rsrk03PrVa/+u2RxeWs9uPxPGeH/UMiqi3LHk+c1aafRSV9BXiIpGVH9oVXgkZueTU9AqojeDG6HPpVU20fe94vFDN/iRHhb4+fxogKjkTi360wT8Mb9fvLRczp9chH34lxIPevI/D5Ul5r9hFpVxf9+hggUs++CD5EcwaVARsKq6l2a0jtJE1tq0OC+wmjPC4PTfr8aalW2rJ4xTtmN7K3st/aT6ncfvLuVpMeS8gPlVlb7N8Xz4VPDVnUtBvuydoIJ4zNp6eGK7jGwHTjH3T68qBwHCDfOd81g5N7fk+k9PPHlh/lvRr45cqCpyDUyybYO4rPabdYPcudjyNFQ1KypQLXZC5+rS3uku37hu+gHnG39D+tahZKwGozrp97ZaqNu5fu5vWNtj8udbUNkAqcg7g+daxZ4XrcPDJf2X45ijK6ndTkVd1GX+1rMvsXCB/jyNB1cirjv3mmKebQSf8ApamcDVOzVabcj6qWJ3MQPyzUXY6UzafIxOcyMfzrPNfm207jzjEbr/Oi30fPx6OT14v5UnpUTPFxxSl+zUkgc9qpy/2cvjaNwSPRqra9d/V40CnxE5plpcRavp0kXF9oBg+YPQ0GCxNQU/AQsU4LSIdeEGrFVdNm761QsMOvgceRHOrJpGT7ILnmvx/SmRnju89EjHzNPuDjg9+KjsPFG8n42/Taga6LNdXV1MRX1GBbmxnhf2XQisTZzx3WiR6QHZLkzcLHH3c86218xEBVfachR8ayPajS5P2rA2nRHvWQu3Ccbr199B0YWumay3tktoIIohhIsKKs1kdL7STvE0M9pcTzRn2o4+fv8jVjVu0VzYQq8tkkJf2VklBY/wDCP60xPFJujQXky29tJK5wFUmvPdRtuIvFOu7eIjyJ3o3x6hdWx1DVJLZLJB3kcWdj5E45+7NZa71HUL6Z7gWqAPuOm3xNI39PBps1XZ7vdL01IZlDWrqWSYDGD+Fv61kJW43ZjzLE/nWtsby6HZl/r1k6DuyA0eGBHmRnIrGQtkcGcgbg+lCNMS3JhTs3EZNathjk3EfhXo1YjsbHxaqzdEQ1t6TOf1DuVGB7dyceqKgPsR/rWXwQM5+NHu1Une61c4PIhfyoI+wxiqR14lUUU5gSpx161VMe4LdKuuDnflULjpQaou9mB/8AfFYnP3xWg7ZjCMQNxIp/Os/2c216yJxtIKP9usi1uCOjA/nQjGX/AFEDtWjCxEjFYO8H9pkx516BqLcVqTt7P8qwl5kzOeZ6VT6No9FArlgOeTXp7x/9TJnrCP0rzeFCzjjHWvUpU/6jhOOcI/Ss2ZZdUYS3UE8qLnhJPExGw5H0oVbjBIWjADjkB7I5mqLZD4ANnbHvoN2jcNbxQIzFppAMZ6UcYsM5A+ZoHIzXev44Rw20eefU00SX1CrGF4mAAxzrvDseN/malw3CNhjHmaaOPoFx7zTEyA8JkHibl5mhlkFuNUurhmbhT7JDv8av6jO1tA8vh8KnAzUejwyQ6dECFDN42znOTTRLGaiimFcEkZPOn6YM2OB0NP1Di7heLh5nlTNLJNucbjNAi1jigGehqWIeCmRA8Ljyp8XLBoEQyDauRfBUsg2pqkhKYgPrinuF2zvQRkIfatDri/2dTtzoK+7ZNAkUnTxbikdMjYYqdlGSRTSPASedANFF18eDyqeyXHejPTNRHmams8d4481pEM0umtmxi26Gq+urnT5cjPLaptKz9STHQmu1hSbCXB3xVAZnSgO+xwHG/SjXCg5Rn5UK0ri+sYyOvSjOCPvDJ9KSGRMUyMREbjfFSgL1iPypsgYKAWBGfKpFz1fb1FMCRQo5Rn5UqheJvsz06UicYOOMfKpAp42+0GdugoGex9hzx9howBjBcY+Neea+uLpx61v/AKPcnsWwJBIkcZ+VYXtEMXj79eVPGZY+2Zy4AxjGDQW/DA8xtRyfckjnQi9wVPFWpuAZj4snNX9Ewb2Hw58XKqdxgNmrWknF1EeLh8Q3pPoDXEYH7r8hUaDKfuhsT5VMxA/vv0qFT4T9rjfzFYjD/Z2xsu5a71FYeEHCq+Me+iFjcWMmrqunWyBFBZ5MYHwFZBgAc99v8KjcggYuCMkDmKVDuj05LizUsySRcWfFhhzpkmoQ7srFguxIoEl5pGl2KxmWKd+HxBcMWPqelB7LXI7dblDGDDKSygNulJItS+zR6nfRIjSHKjzJ3oVbapb645s3Zoip4d9uL41m76+a7mPHKQABgA7UT7I2VwmsThldRwLJk45HrVt6Kc70ujVW2mfs+17u2t4JZTtxMMD4+dUFtby3vuK2ijt4yPtJY4difQc6NwtNK6mOQNANi22W92KsuQqMWzgDpWYUD2nsie7kuYjKw3yeHPwqL6kxBZCGXoRUyWcAIeW3jfO4BXJHxNXURQD3e3TY8qrk10aKTj0CIEVpSswYdOWMVZSzK5Cy7Hyq9wHIJPF55A3pXJVPAnEfIbUObG8jfQMlheQrCFHdx8yNs00WDS7xJwKOrnc0U4sLl14Pecmq0EjS3TOsyFF5pnelbBSZXk0m2uYB9ahVJ13DrsdqtaY1xbI0ZZjGTnY1OxY7sqhfU09MEDFKyf7HB3MvH3jjrzp6lVYlUUMev9as/VkjkhZ3DxtgsV+7RB9Lt+Ev3rKvMeQFIxeSKBix8KCRsZ8+LnXMWBCqhJPLbnRDTY7dVl4nVxnHiG1XoYoxOZY2BJGBjoKCJZKM/HeSxTpHccQiJw2MgrRRbiwEvdZMmR+8O4q5cRQ8XFLF3rNtkistrF21pdYtLSSRScBF55o7Emsn6C5ubWKdmIKqNgc86upqNt3WVkB9wNAVhkuI0NxamObn3bnOPlRE2bLErFwiY39PSgJRjouQyCfLgYq0se1UtPQx4Db8VFkXagyySroH30DNFlFLN5ZrP3EF3JOI2ZYl6rtn51r5z3a7AE+XnQXWri2tLfvpZI4pByXGST7qB4sjQxrIwoAXLDHhwNyaryIYzhiM+hq1b6vELZHmY7+aFcfOpozGxMo4CX9kMMYpFpyXYOjZA32i8Q8gcUnaDURbaHO1qxSUrwgDpmmXU0cdz3buiu3IDrQjWp4rjTLlUbxocMpGCKaWypRtWef9owBpEgHofzrEScic1su0MsSac6SSKjOMKGOMmsNJNEcjvUz763Rz2MsGzbSjyfNMvxm3znrTLFlVZg0iYyCNxTrp0khYLInuzTJssoR3EPnwCht7nv8A4VbhnjEEas6AgY51WuSjSZEicvxUhWe3fRzrU8H0f9lgrRsqaXbLw48olFbTS7+TVe+jkCKuPZrAdhbdpuwfZb6tbuD+y7UMwGzHul3rY2emy2gE92RBCoyzB8bVLSo9BKPBfY3UEFuGiCmMr4iyttQvTe2JF73F4A1t7IkAwRQbtR2hW8kaCwHd2wOC2d5P+VZsNk866IYbj8jSMbXyPTrrtPZ211JbjieEjIlR8703Q9Vu9XuhCjcMEZy0mNyPKsBYQm5uEhT2mOPdWvW6ttDjEUEnH1IHNjUTxqOl2DgqpG9nuo7K0kkbAAHh3rCkXesamcsWJ5k8lFUpdUvdcu1RUIjHJRyUedbjSrVLKxXuhxMfabG5rFr2/wCzLj7W/LLtlFFaWscUSAFR4iOpqc7771Ahyo6mpFJrJmLQucHarEU4MbCXfA61AcnnUFwDjHEyjqwoE4qWmWTHZ3CgyQID6imSWcCgLC8kJHJkNRR94ZBnh7vG2OZrp7yCPwlwWzjhFMXDeiWOORU+0kEhH3gMZqtcwS7Na8IfqDyNWI+LjyW+zI5VIpI3XakO2gfIkkqm3uQ0bMMrIu4Bpy2tzYWy/VpXlf72dx8qvDc+Imnz3AtoDLIVWNebEgAfOgTkwHdzXFwUSaPxdNt6GatprT25WRSj/dY9DU17260hnaGwSbULleSwgAA/5jtQa4fWNa3up4tPtz/d2xDyH3vyHwqjWEm9UY3tTqRh0K50yccM5lHhPTz/AK/GstpthNeyohkCIgyDjOK2Xb7Q7Ky0NJ7dHEyyAM7Esz58yaz+hWyFFbikVjvlHIq0jPKmnsKPp11p6R6s2otK1owIR05gncCtl2g1P6vpCNDhvraDgbkQpG5HwoXoGjW9+12l88s4RC0aSOSoyNjjzoZ2ctbzVri1a6lR7fTH+rmEsdwCTxVLDE30j0TsjppstJ45oxHLOAxU80X7q/L8zV2dJblSjDghG2RVaOeSRVidvB78VeacSeCJwEA3yKlo24OIFubcRN9m5dRzOMCoRRto4WTM7ELnZV61SubVMloT4fInekaKRTFPUUijFPFBVnAUrDYe8UoFcenvoCx4FOxSCnYpCFApwFIBTxTCzgKeBXAU8Cglsv6MP7SfdRwbOfWgujD+0n3UaI8QPwpHBn/MgPgvgfxpj5VJss0Tefhpl3sYn/C/5GpJv3YYc1waRiyzXVwORmupmZ1dXV1ACOwRGY8gMmq9gCYjK3tSHi+HSmaixZI4F5ytg+7rVxQFUADYDFIrpGK7bvidR6ViZmyTWw7fHhnX1FYlzTmfT/x6/wAmIP1OLv4yoOG5qf4hyqjcXRmt4WH3hk++iNy2CD5HNB7od1PPD0V+NceTDNQepDsjjbilUeZqbWtTFl3cYOGbfzwKr2m9ymfOhuoHv76aRtx7I91TdbNuNs0ttcC4t0kHUU4saF6EcWzIeS8qtXc3AvCvtGpWwog1OdXjMIwfM1S0iciGWykOeEFoz6eXwpzgConhKuksf7xDkevmKdlUMYeI1W7G2Wq2PaK+h06QJpVwvHNn7jHqvk1XpI2llRbdS8kzBY082PSttp2ktap+z7ExyTwgGeVztxnnnz9BTTp90ef6/KuPt1bZTnC2VssMChVA50LtzJJfcItLi8BHhSFQRnrxE7CtxbaBAHWS9ka6kHRhwoPco/nmifFDbJhQiIOgwBSnmbXGKPPxw47fZR0W1u0iUzxW1muN0B72T8sKPzoq9tEw8M0xP+VRVFNUtnlEcTGVuvAMge81b+tQq2GYqfIg1itaHKMrsiOnysdrt8eXdrT10+7QfYXwU/xQgj9avwkMoK8j6VZQUdmU5tAGSy7QFvs9Sswv/wDLEH9aJWceoRIBcSQyN5qCKIAU7FVv7MXMfDeToOF8FfI7ig2uaBBqStNp0aQXg3MY2WT+hoqRSAlSCNiKtSaMnFdx0zBR8ceY5EZJEPCyMMEGrCkGtjq+kx65CJImWHUIxhXI2ceTf/O1YyVZLW4a2u4zDOvNG6jzB6j1reMkwjPlp9kopajU+Rp4Oaosayb5BpjcYG29S++kJApiHJq10kJglxLFjhKuM7eVZPVNGSJ3udOizCTl7Yc08yn/AO78q1DAMKaqcJyKUlfZeKbxS5Q0Yk2qvGHgfOdwau2s5dOCTaRdjVvW7Q2rteQL9kxzMijl/GP51RKq4Dqd+hHWsWqPf9PnWeF+SpdMZo7i3k3RwUINH+w+oNeaIIJzm5s27iTJ3OPZPxFAbxCkquPZcYPvqPRbj9mdpopicW96O4k8g/3T/KqTMvXYfcxWu0ehg1d09wZGib2ZVKfHpVDNSRsUZWHMHNaHzj2Uu0Mrx6KRyIk4G+IxWq+jacNZzx/hwfyrOdp4hJp1+FG3gmHzFWfo7uhC14WOFC5qZdo6eHuellX2GO1d8G1HulOyLg++hmh6kbHU0YnwMeFvcaFXV2bq9mmJ9piaiZ8ODRJ7OzH6ZLFwf0ephlttSDDHdXQ5/wAY/qKIms7o8x1LQBv9tD7J9Ryo5aTC4to5R94bjyPWn2j57LBwdPwMvjww8Z+6c11gvDZxDkcb0zUyDAqH77hfzqeDHdgDzP60E+B9dXUtBJWlw93En4AXP8qDdpje2dxBqNkveLEpWRPNTRm28c00vmeEe4VZIyN6C1LizHT9sImtW7izkMrL4skcIPv61T7OaNJq939e1Us6JjEb828tvKrvaXQniuUv9Mton4d3i4cgnzx1qlF2jv7q5SK1tFjumHA5GSMefD0xTOpU4/5egpeabFq2r/VY4VisbbBmKDh426LtQXWYHh1GZIZTwKcAOM7Y861Ucy2NiINPQ3d0V4sD7zHqx5CvOdaur576Y30yW0hbxRxnJB+H9aQ/T3KX6NjeXLQdlgsqcPFGFVhuDk/lWKdgbtFXBwpzRSa8tJuz8UFqkkkxIEkkpOx+J/Sh6EAAEjNNG2OPFM1fYePe6k9y1qzsKzXZGa2g09zJPEjM/JnANGLnULRbeUi5gJCnAEg/rUtHJlTlM841NxLf3D+ch/WqEvXFWHJJLHck5qvKcdcVR3RWiu/I5qJlNSsQc1XaUA4PKmXRd0LK6zZEf4orSduVLWd57s/nWT065ig1K3ldjwo4Y4UnajvabVlvbe67mFgjIcFjv8qVGUotzTG3gU2SkfgB/KsRcjMzYrUm8eSwjURAngA9r0rNSqRM/EMHNU+jWJHEoGSRXqEi57OWh84h+leaKM8q9Pcf/erZHH90KhmWfweexjhY0TPD4eLOeAcs0PiwST1zRJQ3CuMewOdMpkDlFUklsAb5zQbRVEiXd0+cyueHnyFX9cneDTZmGMkcI59a6whNvp0MeV2T151XgQ8cPAuQ3L1prBAduL86mXjKKRw4x60w8efuj50CYD1oCae1tU4syPlufsiing2AVscutDrbjutZnuARwxDul22z1oqe9/h+VUIpXwAtxwg+1191dooJt299P1AN3A48e1timaEfsnHrSJCSLufUUxFAJ61MvPlTSMMaCSOTcZpmPDtUkg23ph5DG1MAdri5tAfWgbE+H3Uf1kgWbHyoAGyB7qYkRMu/vqN9lNT86jZc5NIbKLbsRyqW0AMp/wAprnXB5U62AEvvBoIZotILGzHL2jvUupDNjOCM+E1Hoozakbe0anvlzZzKNvCd6YjKaaALgZjPPyowQqknuyfgKEaeSLlcuOfkKMHzEg+QpIoawHDnuj+VPZA23d/kKa5PAftP0qUHJ/ejb3UxDoVxkNFv05U+PJkI7sch5U0E52l3+FOXHeH7TBxz2oGev/Rsc9kpl4cYlbb4CsV2lGLyTHnWx+i48XZq6Xi4sSHf4VkO1AIvXxyzTx+TKH5MzNwDnYUGviMlc7+VGrn86D3pQk4G/WtjcCXAqXTWAuYuXtDamXHM4FLYr9uh5DiG9SwNscn+7UfEUxM4bMY5+Yp/h598ce8VEpUFvtSN/OsRj2Df4a499RTcQX92o+NScSdZW+dRTFDGftG+dMDiDv8AZr86mgsLuePiitwUPXixUJ4B/eMfjRvssZnvRHFcosY3YSbj4CkNdjdK7OXc1wJJ44hBjxDvN/0qHWLGWz1+OOx7+RXi3V2IyB0z1Fb0OCGdGDMDgnhO9BNVd01zR7h0MeZGiOfUVKZdFzSmvwiJPZ21vEByjfJ+VEyNuYNNZl4uA+0ao6pdQWMXGyksTgYpdlJFmS2jeTifJOMAZ2FSRxqi4jXA9KGw3dxcFeBOFRuSRkGr6+Ncsq56c6GqKaoeWwcZGfKqs0k3COBCZOLpyxVhVCrhceuBTDLwnCox8+W1CGgXqer3FjcQK1oe4kYKZc54T7vKrN3YcUMht3VZn5uRUV7cxXDLC8Jdc8mOAaWFZEveG2hjjj27xjk7elU0NonsLdbe1VZJWmPVnGPyq0WCAcCcRPTOK5YwHLcTHPQnamNDgkxNwMfPcVJIVh1CC0sGjmU8b9POiNjcyParxxcXQcR3NZx9o+Jl42HkKl+tzRx8SluPGMcyKVGcsSfQc1SWCKAhlQyEZAoBJqXeFV4zGqcxHtUTuzHDA8R86py2yLJxySGMnYeRNNI0x41FUzV2V3ZylZI52ZoxuH5++ikBSdRMvCQeRxvWHj8C8M0kUj9ANjWj0VRBBxSIyno2KGjDLiSVoI3VnHcoeJcN+IGq0cj2sDC5WMxr0Ub1buJDHb8aHdd8E4zVZry3dUNziN+gLA0jGKbRWikinvPrUIOFGOBsrk/Grb6zHCzLIVRgM44s1EJ42Qy3Nu2FbwcI4uIeeBQm+udNu5SZImEinhyynA+FNFqHN7Qsuu/XZZI4JAJANlJoW0dxKGb+zXEoPjWSPYfHnT3tYc8dqERxykC71Fp0U1tJIxhRg58Ugbc0HQoJKkXoV7oiW6aNnyCgIxw+lFU1my40EjJ3/I4FDkcSAngPDnGWxQ26ge1Ly26rufZ4OI/8qS2TwjLTNDdXFvKCxiwRuWwCayuuzTvZ3MzI6W0aEjC7t76NadJNc25eSLu2HrjPuqLVo++0q8XgzmJtj7qa0KlFNHjk+WaS6uozLK6MsSY4uA+nrjrWWlkaWQh7dmZeYKitVcu8MN2yLmVl58xGD0rJMk3eE5Q9M4rZHGxVysvE1oeHhxgqDURlgJI+rkn0SpXM/DtwZqJUuQ5bhTf1pkjY3RAwaBjk5yY+lO44CMiHPuSno0z5XhQEcya5YJlGAYvzoEfRv0aFYPos7Jzyskca6PaEsTjH2KVi+2PaiXVp2gtmZbNDgYPt+prN6d2luL/sF2XsI/s7e20u1iIH3isSgk1TMnQVtgwcVyZ3Yo0k2TcedqlVtqrISzYG1XdPsbi/uBDaRNI5ONhXQ2l2b2ENP1OS2tpIbWNe8k2L8OWx6eVF9C0Ce+nDXb92p3JY1oez/ZO30qHvtTuFEzDkOS/GptTS2t8PaXQlGd0POuSWW3UQU70gxp2l6fYqBFKvEBz4hVq3vYXnaAOpK9RyNY2ScOmAuDTY5GRgykgiseF9i9m+2G9Ummsr89zM2G33OaJdn5pZ7d2kfO/xrORR3WoS+BWkbz6VLBNcaXdYYFSOa52NDjaocoJx4rs1txcLbhe82LHAxTuINnfORQNNbS4lVZ4VVM5znNFra8tp9o2GeQrNxaOeUHHtEoJ4MA79M1ThtFW4LTsGJ3xV5vDk9KjlOU2XLUhJkxYZABHpTiTwbYAFDLa6jDlGXhOeY3FXi4KE52xzooTjRYg7t/71S3UZofrlpb6lbfs+/g47aQgkq2M43qvp6K07ybEDoedQ6jPIHKq7Y/DToFitgmbQ9Ft2Kw2FrInIK6ZK1XXRtICNjT4Qx6rkY+Rq8XOCDypM5FOjoUEkYjt/YW1noytbiRS0qjhMjEfImhGhKDGnSif0mSM628I9hCGb3nlQjR54oWhSWTDOcKPM1a6OXK96NReXbaXpU11EV7yRTAMn8XI/ChfZWT9j9p5dOaXjjnRTxZ5tjOf1q9ZWzatNfysM2ljA/AMbPIR/KgGr2yWk+i31mixCWNc8O3iFSLFrZ6iSvFjPzqzBEe8UkNwZySBQ/Sr1bq0in4QxZdweh60UhvZCOGVhgcsLzpM7HbWiS5eCe4BDsq43ytNeW3iU4LMANyRT4poe7ZpFDOfuhagWQGTjYAAeQqWSkBbvVraOcqXhX0MgU/I0wavbnlJAf/erUevdmdLvGuL86ct1eMMhXkIBP6V4dqVk9vezRTRrG6scou4HpVRimN6VnvS6nEeTRH/3gpRqKlgF7snPIODXzz3RB2JFaLsChTtVp5z9+qeOieR7WLw/hX504Xh/Cvzq0AOoFPVR5D5VkVZVF234U+dPW6byX51aUDoB8qkHKgTZUW5fHJakW5bySrS/D5VIpPp8qCWyzoEhknbOOXSjzez7t6FaVvKT1xRbpSOHM/kRXK8du4HPGRTk8duM9V/lThumD7qjtCe5IPNSRQZeCaA5iXPPGKkqKDYuvk2aloIfZ1dXUkjBEZjyAzQIqR4m1F2+7EvCPeedPnuRGSAd6bYDhtTI3OQlz8azuo3hEjYPWmvs6sOL3JV9A3tw3fxxyDmNqxLnw861GrT9/bsCaybHmKmTs+k9FHjDiQzb86G6sAs9uxP72Ip/xKdvyoi53rOdrZ2igt3X2om4xUnopdCxyiJy56A1SG4z570ySdZbTvEOVYAiuYngCruzeEe+s2bL7C2jZW1lkPItt8K5uKRyd96sJF3VrHCnQYqeKMKMAb9aF0BRaEgZKmmYxRbhqtNaszqIhlmIAHqaBOSStnaXKumQXGtTLxCD7K1QDJeVvIelabstFqQtjLHZzo0viklu/suNjzIU5b8qK6LZQ2N1DBsZLePCnHJz7RHrRtiWJLEknqaiTb0eHLI5Sc/v/wBA4W15JjvrlUHURr/M1J9Qgb96pl/3hzVp2RBl2VR5scVVk1Kxj9q7gz5BwT+VTxbFzfgnRI4ABGqoPJRipFnVmyx391UY72K5INsksoP3uEhfmavCJSoJxmkvpA68lqJg3I1aU7VQiATYVYV8CqRzzj9FsGlquJKeHBqrMXFklIaaDmnCgVUPiYxsGXnTtW06z160Ed1mOdP3cybMh/p6UylUlTkGqToznDlvyef3ltd6PqK2epDBb91Mo+zmHp5N6VODjetxfw22p2T2eoRLNA43B6HzB6H1rFXulXmjM3fM1zp33Ln7yDykH/5XzraM0+y4yvUiGRjUDMc1KxB3ByKjYeVaGpH3jLuDipEuCeeKhcVExIoJaL8oDxkbEEdayhhNjeG3b9y+WhPkOq/CtPbNxx70N1m1FxF3ecSA8UbeTDlUyVo19NmeGd+AbcR95Cy7Z5j30Huou/gaPOG5qfJhyNFraXvIgxGG5MPIjmKrXkfA/GvI/rWJ9EmpL9M1mh337Q0yCckd5jhkA6ONjRAGsn2VmEN1Nbk4WbxgfxDn+VapTvWsXaPmvVYfayOJY1hS2jlxye3dD7xuKyGj6o0ME6oSDKoGa3bxd/2anYbtbvx49CMGvK9JOYVHqR8jiiWkmdX8ZUlKLNPbuSuT1qWaTxKKrRHCgU2eTEijyFQmek4m++jy7+1mgY8xkVqrI/V764tT7J+1T3HmPnXm/Y657jWod8Btq9K1EcD29yP7tsMf4Tzqo/R83/I4+OZ/sW9y86qOSKW+PKrEPsH3moI/tGuZOYJ4R8KmtzlW9/8AKmee+iXFMnfu4XbyFSVXufG8UX4myfcKZKH2yd3Ai9cb++pcV1LQI7FD9SaO3QS+CJnYI02BlQfWiFR3EKXELxSqGRhggjINA06YHt7aZkaTTnWKAk/Zt/eebZ5jNY/UtDaK/lL2x7yV/CAS4yfI43rU21pe6ee6N3ci2U+DgiWQAeXLIplzMh1K3eNJ7m4ztxIV6HzAApHVjm4vTMXJCsDGORjGQeHhKEYPlUZRDylPwU1Yve8k1a9eXAkEhBCnKjbpUW+cZ3qjtUtE8Wj3U8ayRxTujbhgh3p02jTwQmWdJY0HNivKvQNOj7uxgTyQUK7YyBNIK9XcClZzLPJyowrpCAc3T/I1Wljtydp3PvU06Tk9ROMHlVHWmRtHDg/aP8FqtNFCx2cn3oc/pVhlIJxyqNhtuKYyGOMSSLHErEseEYXHOj2s6QbS3lQys7CM5AAAzihNiuL6An8Y/Wtt2jTjMq+aH9KVmcpNSSMhbWobTIZFkkVuAHkCKAcWbl++VW8W5CnlWo0w50OEHGQhH51nG2nk881Xg0RCo391eooA3ZCyJ/wxXmnDv6V6bbDi7G2f+Ss2YZ30edr+8YctzV4AcKZyfD0z51VC4lb3n9atqG4U4SPZ6j1qjRgXWgtxe2VovFhm42G/IUSdI+Ejhbb0NULUNc63dTjBEIEanHXrRMhyDkr8jTEV0VBGoCsdvI1X1CWO3s5ZeFsqp5g86txhu7G6j4UK1sPNJa2nEv2j5bA6CmhM7SYBDYw8aMXcl2ODzNXsId+Bvkac6sO7AKgZ8q4h/wASj4UCKeoY+reFSPEOYqDRnAdx0qzfBhbHJB8Q5CqWmECSTJFBIfXpSNz5VXEyDbjX508XEeN3X50yRZeQqFt6dLPGfvr86hM0efaX50AVtVANo3vrNAnpWhv5FktXAIJ51nkhmK5EZxQIUtikLKQRXdxMPuH5iu+rTEY4R/qFAWV3z0p1sD361I1u52wP9QpUhZCGJUAeTA0yWHNC3gf0ard4M28o6cJqh2fbMMmcjxeVEphmJx0waAMbYDFwuY87+lHSo5iL9KB2h4boDvAPF6Ud2wcyD8qEBHJngOIwB8KlA3H2Qz8KY+OE4m/Sn7bfa5+IpgPGekYz8KehPFug5eYqMYDZMv5inKQJP3hwR5igZ6z9FRzoV8CMYk/lWW7W4W9ffrWk+iZgdM1FQ3F4wfyrN9tOIXkgXGc86Idsyj+TMlcEnIDCgd4rRuTnNE7iJ85LZNDbonckHNbM3BczcR9afZkpIp9RtUNw2GJ5UlrxNIh8jvUis3xZ+fAMe+mRliX8I5+dIpTgH2jch1pqcGXHeMBnzrIokPGOSr86ZL3nASQoHvpfs+Yd/maWKE3LGOAyM3lk0B2NBcnBC5PrT4Zri1lEkJCOORDV01sYphHIJA/Tc0v1SXvu6KyhvjQUkzSWGs/WZIhMJnZBndsD51F2kv2MNtLwAdzOjiiWn3uk2NtHbyW85bh8Tsud/fUfaS6s7rs9coIz3qjMbcO+3nQv6NVddE/7SYRbAmQnO/IVQlia9uld8NJ0qO3IkhibPNQfyrT6PYBox3c0UjHkAOXxodRNG1FWCre4lsz3Uqh09NyKKq6OgKnbHyqzPYyRxCRkUxnmccjQe8uktyEiRSOtR+RCan0EPZBJ5VXLuY2MccZzy8WKET3bXLjicovLhA2FXktYpI0EUoYLuQvM06orjXZBHDMl2GQrI33vIfGijglDgeLoc1GHiJURgMF/D92kMyZZmc8K8z0pPYO2V53uokDcaKORYih2oa8lnPBE0hJkP7wrhc+VR9oGi1KPuOJuAbqysQc1mbnSb7uWjiu1niP3Jh/OtIx+y1HWzeD6zcW5cMF4jsAeQqxEiLFwFiTzOTgmsLod1qlk0VrNbyMoO0gfwgetbOCSO6BkhKmQDhZl3GfLNRJUSxVu4mkOEbhXbi6ZpZlWVGFxLhM5AHMUsNnGsXC44upGdqmghSFcRrgc9zSFa8ACcLFOREzEDkTzohZa9d2yMqsJCeTOSSKff2o4XkijUseZPSq1rpvHb8bkhjyWqtNbLbi1snudXvNRKxO3iJ2C7CpUiignia7PeDqvFigs6SQSkKHiYcj1qrNpOryXK3Jl7zh3UswyPhQ9Ckklro9MVbNmjkMrhGXCx8eB7qE3VnZoXaKcszbhCwUD09azky6q1ssl0k0e3gYJgZpkdrrerW4t2tSe7If6023w9ak5klHaYX77u1BhYr0IqxHeIy8crYYemQarRWhhtismO9A3YZIoalyDKOJTnOMg7U0rOhJSQa/acCxk8LDfljFNuJZLiAiGVUJHLINUrqLu0Bc+E/eHIVWsYOORpCglUdA2D8qKXY1BdhGydu67tLqZWHMZwRTSL61S47uTvIZEbi4987UiSrcs8cXHA45nAzXJMlskkE1w7lgdmFImStHlmoj+yXNtHsSC8kh93L31kG7lHUs5ZTzHeYrcXSJ3U0UYYonEWbnxeg86xtyI3nYNbMp/D3eMVqjzZETR27+xIUH+9zXQxxB2Ek5KAeHEmN6YXiyMW7Y/yVKpgZsdzv5FMUyBhhiySJ2Uf56jXl+//wDVU6RiJ5C1u/C3Lw8qZ/ZSd4Tn/LQIIdlW/wDvX0cf/wAHD/8AsCi8SNISE6daG9h7fvuzOlM+eAWcPx8ArbaZpX1yeNeLu4B7bY2Arr9xRijshPpIXsz2el1WbbwW6bySY/IV6bYaTp0Rjt9PP1a5QZBX2iPM+dU4bE2lmkdpfQwWyjYKBv6k+dXezNtNEZr1+KZCOASMc7DyFcWXI5bKnaV2N7QLc/VCBJHNADhiBuDSXWj2v7JDRjhkVeLjJ50yewnuDIdNU/V3JLFjwgn0qvJfXMSrYX0YVOTOBvioRUW2lTAWcc67PLetPcaFbXNt3unyLxAbeLIaglhEgv0juUyOLDLWqkmdEciktF6x1s2doIooF4h949aoXl5LeTGSUji5bUU1vRktoTPbMeAc1PSqdjot3dIHCiNDyLbZpJx7JjKCXIoBuVFtHu+GZImEQQn2mG4q3eaHObSNITEzrzwME1UbQb5VyFVj5A0covsbyQkqbNKtxC7CNJlZj0B51DdXPcTCN8xqRnjIyKH6TDaWZH1sNHdA7cWw+FFLyKO9EaE5TOTgc6yaSZzNJP8AQGju7p5pBDh0J58NWYWuySviOeZI5VpLW2jSNe6XgA6AVHcQ4JZIwvmQedJysj303VA2JY5vsWDGTn4RjNVpbSWZlRLd4gObOdsVorZQUDcKj161LJGrqQwyCMEUrMveaZjrollESRJ4PvIeIn41LYWUqzKZYo+HPsyNj8q08FtDCMRRhRz2GKra4wh0y5nCr3ixnhON80cinndUjyv6S0DaAt4VHFc3p4cdEUEAfrWNtZe7tlwoMzHhjyMnJrd/S5AbTs1o1uWJw3LHXh3/ADrEdnI+/uu9fJWLwp7+prSPRnejfaJD9T7L3yJzWBiT5k8zWVu4/rPYqKQbyWcpx7ga3GkoDpF4CvEGiIx57Vley6rc6dqVlMMrnIX3jH8qXk1w+UGux08TTPF3bSJKguI1X15j51rI5rQRMv1Zg+eXlXmfZy7lt9OidS3eafMUbGx4DW7jl4grqQc7g+dDR0KNlowuihyrKp9KljiGM7lT0NQy3ksrAs22McI5fKkMkxGTsp5YqGVvyRzW63EytcJLDjZRHN+oFB9d7EafqkKJE/1UhuN3VQzOfUmtFbo3tMMHzxSTvMXdCRDHjImG/wCVK2noTvo8J7SaPBp2pPb2nftGnhMky8PEfT0qfsTBjtLZHyevSG7LW2p6g89xqUl9GD4kZh4T8KG/9G49I7TWL2oc27Md2OcGtuWqCkbRRUgpijanisCbHCniminigVjlqRBTAKkUUEsI6SPtD7qLUJ0n963uoojhxldxQceX8hV5kVFF4ZpV8/EKl+976jfw3CHzBFBmPXwzn+IVNULbMh8jipqCGdVXUmPcCNfakYJVqqMp73VY06RIXPvOwoHHsbq90tlYnGxI4QKwV3d8RajXbG74rtIF5KMmslcPsab0qPc9BgSgpPtkdxcggjNBnOJG+ddqMrIvGp5GoVfjIYciKzZ7eKHE5qzva1QbaIkbcWD8a0DHJoB2tOLBT5MDQjoiZLQ7sG3nsJG+1ikwo/hJrS6dEZb1T92IZ+NZWCzKdpluB7BQn41u9Kh7uDP3mOTWctvRotIvgb1IopqinigljsUV7MQibWY2cAx26mZs+nL86FUe7NqIdE1C8cYadxCh81Xmfn+lVFW0jh9fk4Yml29CRagZoYrlAXmkdhGucZPEevlRtdKF7Esmpajdh/8ABsnMSD3tzPvrO6FZvb2rSzbu5bul/BGTn5mtLa3aC3DOQAo3J2xWFtyOSeO4pIg/6M6IH4jpySt+OeR5WP8AqNXbewtLYYt7WCIfwIBVd9c01E4mu4sdOE8X6VEvaGwc4i+syH+C2kP8qTivJmlKqVhY+tRd6ePAQn1qqupd7+4srxz/ABR8A/8AURVm2+suwaZBGPwhs499O14DrssoTjcYricU5qYaCOxwenq9QilGRQDSLaPUqtmqaNUqvTTMpRLQNOquJDT1fNVZk4kwqe2mCEh1DIdiD1quppaaM5RT0wRrfZeKTNxoTJG53a1Y4Rv8v4T+VZNxJFK0U0bxSrs0bjBH/wA+deiA4qtqenwapCEuMrKv7uVfaX+o9K0jkoINw09owD71Ew8BPlV3ULGewujb3SgPzVh7LjzH9OlU7nwRGtk7NbT6JLJt6j1UYUEV2nbinar+6FNC8mfcd3eEgHgnHF6BhzqSRA8bKetLcoWt8r7SHiX4U0NxIGXqM1jNU7Pb9Dk5Q4vwCnne0PfoDxxHiwPSt3YXcV9Zw3UBzFKodaxV/GCeIey4pPo31Lu7jUdEnbx2797Dnqjcx8DTgzH+TxXFZF4PX+zCC5hvrR+UsRFeR6VHwXVxB1huJEPwNeq9jpeHWFXOzKRWF1XTzp/bDXoyuFecTJ7mX+opy6Zw/wAZPjnlH7QqnhyTyFUnk4pCakvJAkfCOZqlG2WHqajpHupGj0tzDf2r/wAQr2YqJ7PhP30rxRDwiM/hINezaTJ3mm27+aCnF7Pn/wCYjXGQmnqVsFVjlwCGPrUtp974H8qrW8ypdvFnwTZZPeOYqza9R6D+daHjSLFV4vHcyP0XwD+dSyuI42Y8gKZarwQrn2jufeaCSaurq6gR1dXV1AHUKvDnWLYeQY/lRWg1yc9oIh5QsaRcOzCzePUr9/OY0kEfHcRrjmwFJE4ee6bzmb9av6PGJNUtxj72ao9JukbtRwqB5DFZjtzJiC2jHMsWrU1i+2z8V9Cn4Uz+dSuzjw7mZSQ5Rj602Tf0rm/dEnq1SRxmaVIxjLHG9WeiVDmmHz3J8qLSabGpw13EPeppjadFzN7Dj/KaLFYNtDm5iJxkOP1rea0MzYPUVk47KBZkIvoThhsFNa7VwDMvXYUGWR/JGS0kg6QV58Duv50CC/2iTIoxoe0WooTss7Y9Ko29tDLNM0lysJHLiUnNN9Gy1ZWwueVei2Hi7G23+X+dYk2Ftz/aEef92f61sdPnROzcVuEnkRc/bLH4Tv76yMc20jCr+/lG/tGpbh1itu8dSeGMmrH1a3E0p+uZJY7d3uPzoZ2kPBaRQQvx98eAHGDzq0XdkehR8OniWRG45WLnbzq6wX/Db5VJHEYoUjDDCqByriH/ABj5VQFdVXgHgPyoRbhbrVrmUISkIEa7detFLuVoLKSUMDwqTyqvo1pJDp8fEfG/jbbqaaEyV1XwfZnY+VSxIrvju9huciumhlyviwM+VO7z6pbXE0niCITy50Eslktbd1w0Ix6E1B+zrTkIBjn7RoP/ANJ//wCDOf8Aef8AKmt2oG+LQ/8Amf8AKlyRNMMHT7ReUC/M1xsLXrCvzNBf+lGR/sn/AOs/5Uw9qN/9k/8A1n/KnyQqYZisrZlYmBMhivWuNja74gT86Ar2mKhh9U5sW/ef8q5u1DY/2MY/3n/Ki0Kg2bK2Az3Ef5036la5x3EePdQL/pO+T/Y1/wDM/wCVIe0rdLRf/M/5U7Qg19Vt+/Zfq8XDwZ5etONnbDlbxf6aAHtFJ3nGLRPZ4f3h/pSf9JpMf7Io/wDeH+lFoQf+qW/P6vF/ppGtoAPDBF/pFZ49ppf+6J/5h/pTH7SzY2tU/wBZ/pT0BpUjRR9nGiZ58IApzjwN7qyy9pZ+EZto8/5zSntPcHwi2i3/AIjRYrKsAP1sjgGz+lHRkkfZ/mKz8UgNzxFyMtnY0eVkxtK3+qhDFfOD9mAMedOHEQPAM++on4OEjvmzj8VOQoB+9blz4qYEw4i3sD50uW4/ZGccs1CHTO0jfOlDKZARIx286APUfojcmHUkYAY4Tzz50G7bDF7Jt1on9D5BfUgGJ8K86H9udr5z604dszX5Mwt45UZA3oNdTMxIIFGroEgigt3GQD1FbM2sGXCjnmm2sg4wMdabd4zjypltgEHrUiPQY2k7pNl9kdfSmqzlnGF5+ZqK2ZDBGeJ91HnTlKB23bHxrEolzJyAX50qXF1bsXiZUONyKjJjPV/zopoWnfX5t42aFThizcIHzoGiaKG5vLeOSaaLiG6gDf40chsbuZA6wM4xzq7aWmkWl2qWcym7A3UeJT8OVS6tqirKkcbFODHFwtj4YpWaxk/Ax7S1FkVeOWO4UZy6nnTdQ02A6RNFFbyyyvGfGBgZxReO7muLdGtrc8LdZTgYqtquo/Uo0hK8Usm3LAUUrZPJvQP7M2lpJ2dsmljDMyYY53yDin30b2UipZrnj38IPEPjUfYySP8AYEq3JUpDPIpJ5YzmtFaopXiTZTyJ54oumCk0BbrUdSh09o3hZIG8PE+7ZrOOc9TW5aZJpvq96oQE4VG3D+uf5VR7Q6Sj2Uk1rHGlwoyq54Vb0qoyovHkUXVdmSC9RyrlkaN8oxB9KGRai6S91fQ9yxPhYHKn41dMqrjJ286s6bJizDJDEE896aXbg4CzcPPGarTu0sbiFsN0YVUtL2Qym2u1CTDdT0ceYoC0WnhLyxspI4OtE9MtjNNksmBzU8zVSAGZuCMZb0opaadIrgtLwr1Cnc1LYm6QVSNEBARR7hTJLdXdWBZeHopwDT44whO5I8qUkDnWRiV5bfvWH2jKB0U86mijMa8KsMe6moQAR1rPaldatpV21wE+uaefaRfbT1FNJsrYekuRwuIsSMpwV9aY0lwCvDDGeI778qxGl9oM6veLbPmO4IkXj9oHqK09nqMrsEuEyW9lhtVOFFKOrLlzYvPIjPISQc+g91T3M720HHEnekcwTioJrgB4kEymQnBwafOYzIIeTnl5GppiphW012a4twk1tG8RGCCaJz38Lafi2uO7ZRjgPP3VlGMlqyjjQxHYY2INPMwjcM+SD1pUZezF7LEHdLdq84leHOSoPOiOm6Tp9/czTtDwxA+GLP5mhx4nAZCRnpXW01xayl43dfPhP8qY5xbWnsg7QzWEfHbWMcwZThsnw/I0AWQqcqSD5ij+pXxVhMQshkPiyNzWc1/ULcIq2iH62+wQD86uJrj+KokS8K3PEsuZhz3yatLqA+tGZ0zlcEUE0nTzG3WS5k9pjRG5tZ4I+8eMhc4ON8VTot15M1O/eu8qKeFWwi45nNYjURP9ck/dZ4jnBO3pW1PH3hKgmTiKrvsB1JrE6n3a3kipM2QxBLPnPrQjyJ6bIkM3GA/doDyOSaV0mD8Q7pj6ZFRiNGx/aGz/AJqQgK2BcEgjmWFMgf3s5JAVCffTOG4GcRR/6q6OJRk/WT67ilDMuQJlIz1IoEbP6NNPl1Hs9oVvaodrCFmbGw+zFbjTLa/lKWn1Z1gDHicLjPqaofRhezaZ2O7NSR2pFv8As23Lsq7tmJcnNaqPtEqvMGVmycxjr7jSblLo78WJxVoKQadax2giMKyFercyas6RJe2qPFOIxb81APs0y0lM8KSPCUc7gGryFMbnB65rFthLemCtTvLi4vI4tOlZio8apyAqW51q2gYRyRSFwMEOoq9BAj3AeAiOTqyjAI9amu47bP8AaIlmbHluadr6I5K6ooyXFnwK8cyRMw9lMbms5qjNFcBwYeNTnwNkk+taq3e3ETKbKKJjsMCh8ehWcbd5PxuefCKcWkXCSi9kVjqovXSG8jRFxnf7xo1O792UhHC5HhJGwrNrYzvqQlt07qGNvCs2+PhWkRi5zK4z5gUpV4HNK7Q2whe0teFn72UniJPnU/fFmHFgHyqJu8WZQkvg65GavrAqglyHJHuqTGUktsE39mlzIjycWByHSrdrDJImyKqrsMGpWUB8sCB0U9at24AQ8KFc880WTLI0tCJG0KeAsx8qmDYC8ZwTTCWyVRcj8Waq3MxbhAjJZTtSMUnItkFW2IC1zy8G7FB7zQjvLpr9i0rRxKuR4c5PlVaTUp+87uW3jdgcB8ZxTotY2zQOzOg7o4z1NBu10pj0bD5HFLGpPvYVNM8tnAZ5me4JGQqLhVFUNYtLjXdFliimWFyA8RYZ3G4zQTx0Y/6dJA1vpaA7mRj+VZHs/GqxxqtX/pHh1QLpp1m4SaffCxjCqB6eZ86r6EvgQ7VpFaHVI9D7PQCTT51YhcjGW5CshoEDWnaa+gUhkbj3HXhOf51tOz0Yk0ydCxUEAZrJalGLXtovdF44zIgJfyYEZ+eKnyaYnWwZa4se2F3aSbQ3qkemTyrV9n3kNu1rIrNLbsYzxDp0PyrPdv7FrG/06+SRHPFwkqeWDWiguBHfWl6CBFdp3cm+wccqGzdS2GRCAuW51DISuSMkDy3qWSRW26k4G+N6YVZMlWDDkcGkaJjgzK64PF150P7Qq+pWT28MhTfLbbH41bvRJbW5mdMLjO550CvNTgmVfsHePG/iximkNV2ZiF59PeRIZ3Vgd+A7E0Y0nUru91K0juX4lQ7bb8qpX3cSTZto2RMciau9nrZ/2hFKFPADjOKt9EtmyFPWkiQucCnAViZjhT1pq08UhDhUgpgp4IoEEdK/eP7qXRJzIbuNjnu5iB7jXaV+8f3UP0KXh1u+iPJyT8RTSOeavkaM9PfUdx7Kt+Eg1IR4TSSDiiYeYpHOjpd4z86lU5APnUUR4ol9RToTmMem1AmSUNsX47m9nPINwA+gFEWPCpPkKB953GhzyjnIzH5mjvReOPLX2Y/Vbg3GoTSZ2JOKDXLbmrjt4nNDbttzSk7Z9TgjSSBl6OOJ1oTpk+WaFvaU7UWlbmKzd4xtdQDjYE71DPRgtBx6zvaxs2RHoTR8OHjDDkRWY7USEwuAMkIdqEWgbYr3t8jHkseT8a19l/s6nz3rIaDMtxphuU5MRGD7hvWvtD/Z4/8ALUeSk7RbWniolNScVFCYkhwh8zsPeaPX0htNJS1QZEKhPLLHn+eaGaFp8moX73knhsLA8R/8WXovuHOr2pKktnN34yrcz5HzrWC7Z4vq8yyZFFdIuyXEcUcak8UjKCsa7sR/Sqi2U93I76g57n7tsh8P/Eev6Vc0Wwjt4WUObic7yTHcv5fCl1HVLHTm7u5mVZTyjUFnPwFcvFy0jX3FHsLaPMoiEQ4U4dlVVAGKJl2PNj8687l7QXX1hfqOlyshPtSyCMn3DnV9u0V8ij61pM4H/hzqx/PFNY6MJqLdo2nxpVbHI4rFHtTbxjx6fqq+eIQ36NTB2y0tSO9TUYh5yWr4/LNU4P8A/mRSf3/wbfiHnSGs/Ya1p9/j6newyN+Hi4W+RwaIieVOY29RUtNdlKKfTLwpQaoreea/KpFukPPI+FIfBlwU8HaqguU/FTjcIRjioIcGWg486erb0JNwVbnkVNHcA9aLB4mGYztUlULebNXVbIq0zknFpjqXlSZrs7UyB1xaW2qWptbsY6pIPaRvMV532ksLnSrkW14vtH7OZR4ZR6eR9K9CBIIIq1Pb2us2T2WoRiRGG2eYPmD0NXCdaMm3jfJdHlunrhabqp+zorq+j3Wgz8FwTLascRXGMZ/hbyPryNBNRfK4reLN4yUtooA+HB5VUgHArIfuMRv5UaudInt9It9RZ4jDMcBQ3iHvFBmPDdkdHXPxFTPcbO/0ORLJX2VJ2xJJCeo40/mKxmtag/Z/tbpmrRfu3+zl9Vzv+VafXJzDdwMh8agmsT21Z7vSSXxmBw23kaiPdHrZoc8bR9EdlrhTq1nLG2Ucgg+YNN+ky17ntHBc4ws8HCT6qf8AnWQ+ibVDd6VphdsyQFUY+Y6V6L9LsTHQ7a5jXLRygE+QYYqlvR8zgft+qj/weV3M3HKTnbpTLZ8zoPNqq5PWprIZu4vfWbZ9TRpPumvW+yUwm0C3bO4XFeRjka9F+jq5L6LJGx9hzTj2jxP5aF4k/pk1jM17FqCISJrWYvGfWjmmTi4jSRdg6cWPLesx2HnMur6up5d4f1rQaQO6lnh/w3YAeh3rX7PG9THjJx/ou3R4jHH+Nt/dVgVXj+0upH6IOEfzqxQcrOrq6lxQISurq6kIXFA5/wDt6U49m3NHKz9w/Dq2ov8AgthQjXF2zDWS5ErZ5yMfzo92Yj49UDY9lSaB2AP1ZSepJrT9kY/tp5PIAVTO7K6izTVge1Tl9Xm/hAFb48q831mQyX905/EaUTH06+VgU7xLnq386J6ZH9u0vD4UB36Zodg9zD7xR20j4dJRj9+Rj8hVM7JMHXsLzz5jAYYxVc6fcnI7vb3iicciA4LjPlmrHeAjYN8qB3Rnf2fNDIrMi4Ug7NWnv9Zs5nXglIIUDxKRvQ26fKt4WHwoHcyKrbgj4GmlYuKltlnSmlF1qK/ZcPFxEA55/wAqoJC09xIVIUDqal0qUnUL8xEHKrS2RJu5uE42zyzTa0aUMaxf/FQD/Ka0+nazBaaEli6Su4z4lXagrh+E+MfKo8OVHjHLyrOkZyipdjDGomlk42w7ZxwUOnIudbt4gCyW6lzt1NESjE/vOXpTuzGkS3E0922cyuVBx0FUtA6RIkBkOBCflV+20d5f7oge6tRp+kLGAW3PuovHbpGNhQYuf0Yp+y63ESRMmFLZbbpRZOz8CgDuxgelaLwiopZkUbmgSbYAl0ODHsD5UK1TQUltpI0UDi51pbi9iXmwodPqUIz4x86aNo/s801TsxNBkxrms1NZTxyFSg29a9Y1G+ilQgMu/rWJv7TvZ24ZgB8KOISrwZZ7aXlwj51GbeUDZR860Laecbzj8qY+n4BzOPyo4megB9Wl2OBv60htpc7qB/xUb+opwj+0jly2rl08MMif9KfEQDMEoYDhH+qu7iQc1X/VRuTThxr9v+lIdNjz/tBz7xRxFQDMUo+6PnTO7c7hV/1UebTUx4rgn4iol0+LGO/bY+dOiQN3Lnkqj/ipjwSgZwuPfR46fD1nb5017CDh2mbPvopioAm3fPsr781LDCYyWYAnpvyo0bGDf7V8e+kNjb4/ev8A6qdBQMi4u95AnI61oEL8IHAOXnVKGztxOAHcnbGCd6JS2zxLxOJEHm7Y/WmkBC5YqfCPnXAtwDYcvOonmhGR3pJ/zGujKkL43O3madASgyZ9lfiaegdXXiVc753qxahVSFlOT34BJ58qXtbcSjWQGcsMKN+Y+NOhWb/6Ii31vUFYAfZg7H1qn2+T+2ud+fSpvofZf2rfKpbeEc8+dN+kLa6alD8mZr8mefXI2NCrzcYNFJjsc0LvOVbmwCudmwedMibyqW6UZOTvUEGVfeoA3OnvIbGEnGOEY51OrPxt7PIedVNPKGxhOGPh8jU68JkPhbGPI1kUTKZADuv505mnEbAOuCNwM71F4MAcLfI0e7Ow6YkUlxewyXEoOEgCnHvNJgWNO0aN9JS5XUoo7zh4lRWG3pzzmtbbWTw6dGkVtHNIygyPMcFjUGmSafc2PevY20LjOIggyKG2/aSPT1nN53zyEkRwqvhUe+o2w2ayEsIwvdcGBgDIxSSwxyhlljVgRjOKw1723kmaOOGFrdDtI+OJgPSp7jtagght9KS4k/HJKuWA/maKY0mE+zwitLrWbZ8LFHOH8W+xFWLjVCSTZK728ZzI4XbHpWdse0EEOv3rosmJoU2n8J4geZrXWblbTiuDboZfEAowN/1p1Wy0q2dJqFv+zDd3sRFuBnxDOB51V0630/WZO/hF0LfHstkKx8wTQzXJbsMsFwFEWNgnI1JoeuXEuoR2SlOFB4mKYAX30+OrRTxtRtFpuz2lPBcPqVzGICWEYMgAHx868+uIJLJmEbfW7IE8myyj+Yo72t02z1DWC0Mpa0AyUXYF+u9UjplljHcKBjG21XEuEXVtlnS+6msxNZyxyxY8QHNfQg1WvrE6ipFvtNGONG65qO10VDMUtVmhLnAKORmpP2LqNnerE11dxuTsGAGfjQacktMn0OVRADMjJJnDkHBB9aOHULRWINwnEBnh6mrFl2ZmfTZWmkK3TNxDIB4h8OtCrjRrf9oGG042mVftJJRwpnyB5VLaZn7sW6CMV9b3Cju5OFvJtq6C5Dh+IqQDgEHnQNLORrsQQASOTgBDkGrepaXdaaENyFBblh80JLo0XG6Zcvb61tome4l7oAZ4sVR/aHGyyQSCWFhncUG12Utpc3GAQq8qTSWH7Otzj7gqlGikkgR2gt20vUbfV7SNBGJPHGo299bJQ+pW8N2eBImGfDucUH1G3W9spYX+8NvfWf7K69NYvLpFy/Ayk8BPX0oaE9MNXBjPadFtpWCrASeI9c0SmnkmILtkgYBrIae9xfatPNCpLMeBfcK0rxzxqI51KSdaP0EHboMaV3EeZZnBk5Kp3NX724jhif68phQrxKzjYis5biRGDcXI7GiOvaqNZ0qLTrlVWZWDK68yBUuOxTTT0DzrV3LdwiNCbNsAMu2PWtRq9q0GmQ3hIeNmAOD08zQXSoLZIJO+ZEVVwOI4x60691IXOmCxjl47Fd8svte4+VFbE07VBSXu3gUs6pEQNwM4zVbUey1vaQfXbC4S4dyOLz+FZh9T4FjtrXiljBC4B8KijsV5bJBw8LRuBsQc5NFNdBTb+LIra1lW9MXGIpVGQ3MUNu4Ndl1E20l2ixuQcpjdfdzrT6LpVzqd0t1cAiLHtowBHwqxc6DqMerfXbQnhQcCiTBIHnUt7IyTTdWYK9tBa3U9q0vG3ETxhcbc+VYTVnCXUnFBiPiwrGIbj316L2nhddbumleQOpBfjxltvSvO9aEsl7LIFiUMchS2DjptirR58+wVNJC7DEZ2O+EpV+qkfujn1U0oeZMAxr8Gp/2zEN3af6qozIgIQ+RG3D5cBpxa1BxwEe9TUhlmU7xj/VUbiV24jAuf89AHsP0b681r2E7NW4zOn7MtgVIAA+yXatImnWWoTM8SzRMdyAuAD6Vhfo4ltoux+gPeWzTJ+zrcAKcb90tbZNXuXlhbT7QxxJtws2QwpV9HqqPxVBu1gltk4ZLh5EGw4hyq8jq8YVx7jQKXXo5bWaC9jNvKy4BXcUL0fVJLUGN0EkZ9ku2APjUcG0Twb7NX3rxyAKDg82HKq9/ewyR8D3McbDcEHehq3F69vNetOkar7EfRh/OhVxqjXCsrQwrxc2C701AI47Cc2ryRN3UbJcDo686kXXp7WJVeJHlPUty+FZ6RO7kxFIHHMMtN4ySCx4t9yedXxRrwizYo1zfxxyTtFB1ATnj1ogrclUZA61iDdpxKVhC4O+GPiokvaQxkKtuOADAHFUODfRDxvwbOOGQhSCFHU1KrK0qpx8b9cVg27SXTMBkohPiCnmPKjMfai2g7tLeCWTPPjYbemal45HPPBNGt4DyPDj3b1WiEsbOqMuM5AJzVGLUZrmIvLF3akbKTvTOPvI/syMnbJqKMlifkKreIWZOJDKvNVOcVVmmZrhWYDux0qhpdrHBdScDlmO5zRSaIEZFOkHGMXQssyyR4GM+RFUW8DEFSeuQNqlJMaNlgq9SaozYLARzENno2wpFxilpFk3yWpVZ8iBubEbCkl1yyW3bgk5cuAU2SU2+FncSk8lxgfOgGsX2Lgn6vJBKo8OMY99UlYKCk+jJ/SvLG8+muisC8ZYktknehmhtmMbYqHt80pvLNp5OMsmR6b1LoJJjWtKpGc1Wj0rs7H3umzJxEcWBkdKz3b+yNteWk6EsGjI4s78SkMK0/ZrwadIcZ3Gwqj23jDabDccG0Mylh6HY/rWT7FC6KPazT4tS7ITXESPxIqzKx/OqXZxYdT7OCFmYSGPvosDOGXYj54+dans93d92UityvJGhb3jIrHdiZZLCS6iLkCxuMsv8A4beFv5Ggrk7s2WmRwarpcUksQww8WNtxzFXldLe1aG2tImjU8geHb1qnpSrYaze2Eh+xmH1mHB8/aH86uznu4iAcnNSNPmBLyGUCeTv2EJGRFw8f61kHmkaMxMBwg7eHBFau4upZZmhjhljcDPEpFM07S5Bdd/eIrueoP6iqTo38GVijUuOPIHpWh0jS7jwXMHD9Xzhwr+I/A1rrWw0+Y/bWyFyMZ4at6fCsdyySQleH2GPWhyswllq0Q2mmKFJEjNGwzhufuoPe2rKwUWzxknYludbHwgcPAcDeqUtlHNP3rOQB0FSYwzO9gW1tOCHhkhMZYe0TnNRXNoIlAiV2J6k1ppVUw+EcbAYBxk0IlhLMQWPF5HpSNYZOQJWF/wAH5ipFik/D+dXjC4fgAyfSmgb4NOzTlZc0NSrScQwcUHtnaDXTIQQpkIzRzTSAZDjpVaVe9R0aFhhsj586EzH/AFMOcYOcHlXIwKjeqveHi9OVKm7bY+NIw4E9vsGXyanxbO6/GoVbgnbi2BGakVvt1I6jFBLQ66PDbSnyU0C1gd12diB2yAaMaoxFk4HNvCPjQjtd4NKjUcgQKa7NfTK5xX7PP5JPGwqhcnnT7iTgmJqvO3WokfV4olCVsNQXXY+KHjHNaI6g/AOIedV5sT2xHmKg7Y6K2kXQktu7J8S0I7QNvJnoh/SmQStbXJ9Dg1BrkneRzkdYzTRTIdFUW/Z3TI8YLo0p95P/ACrW6e4e2THQVl7te4FpB/hQRp+WaM6LMDblSdwajoI/iGhSsWbgihXinlYJGvmx5VXEm3OtJ2PtMST6vOMx2o4IQRzkPX4Cn+kc3q83s4nLyGri3TTtPtdJtiD3I4pmH3nPM0OvmWKNY9iz8/dV2PiILOcux4ifWhGprO139nBI7YwMDb510JKKo+egQpEkRJiBTP4WIFdDG9xIVtYwzfefoPeetWbbS5psG8YKvPu0P6mjCqkEQSJQoA2AFLvo05UDY7VLMFie8nPNj/LyqFo2lbLmiDwtxZdSCd96QxbU0CZSjiTIyoNMvrJo/tYcmM8wOlWXjKmrMEm3CaB8qM64SRcSIrj+IZpghKf7NcXVv/uZmUfLlWhn02CUlhlCfw8qpyaW67xyBvQjFKilNMpRXOqR7R6kX9LiFX/MYNWYdT1ND9vFYzr5xs8Z/PIpptJ1+4T7jTe6lH923ypcUPkEY9aUfvdOuB6xzI364pJtdjUfZaffN7zH/wDvVSEEhG/hqOYBFwSTS9qP0Cm/sfN2nMani0m9PuaM/wD5VWdH1631GUwok1vdDfuZgFYjzHQ/A0HKFzy2plxaJNEFbIZTxI6nDIfMHoaiWFPo0WR+Te29wykcVFoJwVG9YPQ9ZeWRbLUCBd8o5QMLOP5N6delaS0n+6elc7Tg6ZUorIrRoVkBqQGhsUtWkkqkzknjosinRsUYMNiKhD08NTsyaDQEOoWjRXEayRsMOjDINebdsOzE2lE3NkGlsRv5tF7/ADHrW3tJzDID0POjSlJo+QZWG4NbQlZxvlgla6PAZZXlJLtkE5wOXyoVrV39TEEgGSSUHvIr0btt2RksDJqGkRmW09qW3QZaPzKjqPSvI+3F0qaVbTxsGXv1II6itV8tHpelyxlKMkDp5XmlaSUksaH6rGJLaRW9mRCh9/Sr/MZHI8qiuE7yB1HPG3vrnT3Z9M9qgj9Dt93VvbBiRlzGfeDkV9F9uIPrvYm74dyIRIPeN6+WOwMph+uqNjHccYx0zvX1hYyLqfY5XXdZrY/pWsez5L1i9vMpfTPn4HPLlVvTADeJ6ZNU0BUYPMbH4Vf0YBrl28lxWb0fUp3Gw2lbj6Pn4LO8XoPFWGLqm7ECtX2HuVFvf4P92TTS2jzfXx5YWi39HD8eq6mfNifzrVSMLXW5WOyyw8QHqP8A61jvovJOoXx8xn862mrxL9Zspm5LJwt7jWke2eH63Wdr9F+1QpCoPtHxH3mpa7pS0WefYldXV1Ajq6urqAFrLak/Cdck6iNV/I1qaxeuPw2WtN+KRV/KhG2BXIztiMWkfurYdk4+G0lf8TYrJWwxax/5a2/ZxODSo/4iTVM687+IQmbgidvIE15heuWErnrk16Pqz8Gm3LeSGvM7xsW748sURJ9Mu2QYx3A+P5VpryLutF04MOYYn41nQha4hUCtj2mQRWNgm2BhcHYcqbN5v5RQBgwBsMe6iNuPsj76rGNEAKE4J5H+tSJKY0I4c/GkOW0UdV6e6s5dHBzR+/kMnMYIoBd7HlVRNIrRJpaJ+1ZzgZaAGoFmjhup3lxwAfzqBLqSHVI+CHvC0JUDiAzUSWrXd431llTG4Qbj41XgpIv28rTo8hh4Yz7IwM++po04wuIv0ptsuCYVkwAPZ2OPd6Uf0jTywQsc/CoJeiKw0rvgSYsZ9BWu0yxitLdI1UDhFNgjSFQNtqZc38cS+0PnQYyVhIyKo51SvtUitomd2AC1n77V+YWQfMVkO0Goy3E1tapL+9fLb8lFCQlBG1n7QfZ5Az8aD3WtytnAPzFBAxbizLjfbcUhxn94T8RVUVSRNdajMwOx5+YqBp5D93f3ioZivCT3nwyKRip5SH5iqEPZ3PNQT76gBbvXBjHIdRTiVzvMfmKjBXvWzIeXPNAhx2xmMfOoJ+LDeAAY86mJXn3px76jfgKnMhPpmgRWt0YrngGMc81PggYEa/OkQrwKO8IGOWa4lP8AEPzpiI5ePjTwKPjXNxYyFXb1pJCvGv2h+dNYx52kb50COZnxuq/6qiBbxAKOfnTn7s7GRvgaYpQFhxtz8zTEL9oQcBfnTZOPg5L86492Tgu3zNRScAQgOx+JoAnJfoF+dSiNIbVrq/k7q3Gy8O7OfJRTbGGO4nCF24B4mOTso50G1G9Gp6j9oSlsgKxIp9kDl8TVJWJsdc67cyApYL9UhO2V3kb3t/Shv2srqCzNI5xlz195pyG3YDxTI3uBH8qcQCww3Fg+6roQ6+s57KOKZ5I5I5CQChJGRz6U+zv2iAViGXyPT3Vd1hi3Z6zBI4UZ9vLes8WAPhPzoA2kMnFZxyAqftVII5cqg7VOX1SOQHmFoVo12qW8qOTwBlYYGcmrGvT9/ewqCqAhd22ApUI9J+iR2Gv3CtjDQnl76sfSLgXLeded6vPb6Y8X1HUFlnHtNbSkgbeYoU+r6hdnhM88uPNi/wCtKMd2HHdhGc5zgUHv5OAYP50s0V5MSW4h/mf+QobdWrr+8KE+7NaMoheReI5Iz76jQ5fJrm/3cRx1K0xeFn9hQfNTioCz0yJtOm7P2ElmzRXarwyxsuzfxA1CtvclTKEJj5cYXatR2P0u2vexemSvbxpcK5Tvzhts8yB/OtdZFYtLnt2083IUkcSIOB/UVg2NdHk3ixsRn3VtOxVrwvm4CFTy9ar9oOzC2kNte28TSrO4DwgeyTyANaC10ObSrDvw0cfCvEYeLcemaLTKXF+TQJpsKOXRFGfIVi+2mkEPxwAcR6Yolp/aYocXn2a9CetDe0uqLqHB9R+0dWzkchSSdjjF3TMdb6bJJMBcSCLH3SNzRWCyS3cNGSSOpp5PeTqZ4QhUZV85qcb/ANa0SOuMEgTfIra7aiRQyyRsu/pRq1fuZIyRxqhyFJoNrB7q906UnlNwk+8UXXOM0FJbZYvbuS7mLyfBegFQFGUBmDAHkcc6QA58619qe8061g1SzeONCCkv3fj5Um6InPglRlRayqA0imNGGVZxgH3VXVXc7Dc9BXo+pad+0o41Ey9wpzwAbH40E/ZQsNVjmWCaS3Q9cZJ9KlTMo501vsk7LC4trdu+tJDEeTHG3uHOjMmlWN6wuJYCzHfxE1dtZO9Ti4GQeTEH9KW473hzEAxHTOM1m3s5JTblfQPg4bWZ47a2VYhzycEfOo57rTrmGWBRDI5OTGPOluNOmu5A8pSIEYYJvkVMljaQosMUCpjkwXn7zRZVx78kGj6ZFahpTbCK4PInfA9MVgu3sWq22rm4jlhmVl/c+Qr0KG0l+1Fzctg/djyoA99ALjs4gupprp+ON/3YHE7D31cXTs0xySlbZ5JrGry3MaW8kLWwZgJGflWhiZFgRFYcAUAEcqua9o8dwJrcxO0QGxIwR61h7K7k0HU0sdWLvp5bKuNyB6Vrdo6m62b5rVDHEbWUTMw3XrWN7aaE00ZvrXIuYvbUdRW20rVNOmvGFpGkcSrkTE44vcKrSS/tCeYpC3ATwnA5jzqYsE1JUzLdhr+GW3WEcUdymTkHnWskLSNmRix9aqWPYi9tL19QtoQtqqce7cx5AedbHQOzgurcz3p4YnXwBW399NyS2SssYrZljhfQUQ7LaUL+Wa6fc+yvuqftFpCWdt9WtxLPeythSBhUX8Roz2aVdOtltTJE8qjxGM5FJy1oUsnP8TIa3o0iXpN02Yh7MY5fGpoL4QWvcmGN0xjB61sdYtP2qwjtgveAbk7AVjtW0+XTbowTlCxGRwHIxQmnorHJS+L7A+kaxNDOLKK1t1Esn3geVEdQhgguVS3cOTuwDZwasRR/tBo1Ijh7kZDgb1M1grTBX4c8zIgxxe+l0yorizQ9mIriK0aQr9UiIyCQCX+daG1kdIi13LEWJypG21YIW84JMdxJ4D4RxGjemQanNKrXXGW6NIu2KiSMMsE9tmK7fsw7UzCVQEIQkLvxbbCvNtbjf69MzysJGOeEAYHpXqPbkOvaSUvwM5jTCpyzvXlmuCOLUplm+0lJyxK5x7quPRxyBxjkOPth/pFNcyxEASg58xTJGtg22VPoDSBLSTYklvUmqMyVUkcAmc59wpkhlVsCUt64qLht42HASB151Lw2Z3x+Zpgej9irmX/oF2ehDAR/s+3yAB/hLWh069+ov3ixiRuXiOwrP9ih3XYns7h1bi022JA6fZLsaMSyKzAogVT90HNUuj2YbigpLrckz729sAfNM1TnkaRjhwyc8AcIHwqtwOOQJzvgb03JFFLwUkvBaN1K8SxNIxjXkp3xVmxs/rYbilSIKNi5wCaG5zipQ4RlIOTRQNfRae0uY8sIpOEfeA2NVpMpzGPfWwtNct7jSDGHFtPGNgRkNWa1G5kvpARCAR0UUot3szhKTe0UVk33rs786jOx2pyg881oakgNPQkEEVywMFDMpwetXbPTZr2J2t8MU5rnBpOSQnJLsP6HqvewMl0wDIMhj1FFFvLd1UrMuG5HPOsNJBMk6wkN3nLhO1aTRdNmjlb67AndMu2cbGsZRXZjOMVsu9+0UjNaJGDnduLY0Z03Uo7iDEzoJl2YA7UCi0y3gllJadkbfgHsn0qtaaTJczSth7aAbKo5mopGMoQktmtZ41dTs6seXOqlzcQJckTTGJCNlZRwt8az1jHe2V6EKs4JwCRkUUuIr25ZR3UeBzA3zSaSIeNJ9gtZzqepdxFKYrdT05/CiE0tjpkyW8qCaOT2mY5Ye+qr2qd79VsoTBLnxyqxOKJ2Npa2gxJEbiQ+07DJJptoqTVHln0tRQQ69Yi1ThRos8/Wqeh3dsJltu+Tv/wZ3q39L8rTdqLUcHAqwgAA9M0N0fR7drqK6YuGVuLGds1S6OeXWz13s/4dKfHmKk162F1o93CMlmjOPeN6q6dKkGgvJIpZQw2BxVUa2eJwIAVOw8W9TxbNMUHJOhewNx3ljcIfxLJ8xv8AmKBx91Z/SBcwcQMN4pQ77eIf1FVOzN/LaarcQKwiViybrxbZyB+dWe2MSRXunXlrGUZR42HUg5zSqhONKy9qupdzYWdy3CbmylMb78wNiPiMGtPbSQ6ho/exgFSM8IO9B7NLJ9TeO7tWa2vo9iU4vGBz9Nj+VWew8RsLm9srpMLbviNmO/D0291IhyrovaPpEQmMsVxKbZhnu35hvLNWW0+YyjhdY1zjxc6NIsZiIhVAOe3LNRafFIIj3wVSTnCkke/epM/dkhLC2nt4irS8TdARtSSRE3MVw54ZVGCBuCKu8SrgZJNVpfE/FxbdAaCE23bGG4aViF4kI8x+lKM4wSSfM0lcDnlQaUl0PV2Xl+dQyxLLzVRnqBvUgpaBdDFXhTDHPTNVDBmUcKYHoaukKd2GQKUAD2SMUFJ0RpDw+x4SedQdyIpThuJTv7jVxnA25DzpnegOMAYFAk2OxxR8WRmpCCsYKjfrUSvHxnG/pTjIh5591BLTI92O2SasxcYQgALjmTSRqAhMTb0zjGCJeLJ86BP5HXAMj2yZJ8fEc+lDe2YJ0vIHI5olat31wzj2Yxwj31V7UBTpM/HjZciiPZWF8csTyK/Piz51VEnEmOoq3c+NWFB1kxIRmoZ9hjWiLVBm2kx0GaE6bc5PdsfdRi68cDjzFZNHMUwI5g1B0rok1VOC7J6NvVRI+/dYzvxEL+dXNScSorjmKq2TcN3EfJhSYPodrLA6ncY5BuEfAYqOyumgk51HeP3l1M56uT+dV5AeYpN7KS0auylN3JHHB4pHIUD1Nem6hCNOsbLS49hGoaTHVjzrBfQ5ppvu0L3cgzDZpx78uI8q3F/L9a1OWUnI4sD3VeJW3L6PA/kc3PKsa6RJCNqmxgVHENq6eThTY71scQ2WXB4V50gBPPnUEPick1YFMuqLJkR7bgaMmUHaQt08sUwx4VSceLyNMUU7lSFVDXiVuYqu8HC2RVripjHNA0MHKkOK5mxUEj460ASOwqvJKBUUkpqpK5JphRJNNnlVNzk5NK5OKjzTGhQa7PnTHkVRuRXJHPP7ClU/EaQ7Kt4izKV+RHMHz99GdF1h5XW2vtrwDwSdJgP/AMrzHWhrwiLbPEetU7oLIOHJVgcqwOCpHIionBTVGsJ07R6La3PEBvRCKXbnWG0HVXmzDc4W6QZOOUi/iH8xWotp8gb1xO4umdEoqatBhZKkWSh6S561IJPWnZzvGEFlojp94UYBj4TQFZD51JHMQapSoxyYFJUzZKyuuQcg14x9NXYK1uYILrTpGtmubpFlt1GUdiccQHQ/ka9Gtr9kGzUL7Qy/tHUtNhc5WFzOw9wwPzNbqSaOTDhniyJro8L1js9fdnnW3vk4o/ZinX2ZB09x9KG19EahY22pWclrexLLBIMMrf8Azsa8c7Y9lLns9MZo+OfTGPhlxkx+j/1pOFH0PpfXKfwn2YXsqDFrWsQnYcasPca+j/oe1YXeiz6bK2ZLZsgH8Df86+cNFbh7XagvR4FPyNepfRnqf7N7Y2gY4iuwbdt+p3H51pWjzP5HHycgVrcRtdZ1KAjBjuHGPQnI/Wp9BXCySHlyol9KNstp2yvAv9+iTfHkf0FCml+q2EcabO4yaia+R7PpZ+5gi/tEl5P3kpwdhyo72VuzBFeDOxhNZNHOd6LafIY7W5YcymKL2VlhyjxN19FbE3tznqg/WvQ9Ri72zkXGSBke8VgPotj4bm4J6IBXpBGRg8qcWfK/yTr1DI7aQTQRyD7yg1JVHSW4UmgJ8UUhHwO4q9Vs4JKmdXV1dSEdXV1KKAOPKsDr740m8J/vLoj5VvWOFJrzrX3zpSLn253b86EdPpl8irEMQRj+EVvdLTu9PgX+EVhoVz3agc8CvQYl4YkXyAFUzX1D6QM7SycGkS+bYWvPr391jzIFbftfIFsYk6s9Ym5BeSJV6tQjT06+JPpkXfa3ap6/zrVdrx4LYdOI/pQPspF3mvqxBxGmd6M9p7mCdIkhlR5EchgpyRtQ+xy3kQDjFSsMimJUpG1BqwddLsaBXq7mtDdjwnzoBeZzirRcQc7d3qVkwXJwRjzzVi34v2my8PECD5UyYcF3p8h6MVq/aIX1MKfDkHen4KvQSsrAyTQyd3gg4PLcVqou7toRsNqoQtHbQglt6C6vq3DBI/eYCgnGRUGfZdu9b455ViGQnh59aFTXckqglfv+fpQfTixslkllIeQlyMjrV2NlMQxIfb55pg0dJxls93+YoRYhrnVrq54AUj+yTcc+tENTuFtrOWUSnKrsM8zVbSI1h0+INJh2HG2/U00IsoWyw4Bz8xStxAHwD500MmW+0PPzpGdD/eHHvoJZFNxcB8A9d65uLog+dJLwFD9oceWaQsg/vD86oQgLA+yvzqNuLvThRy86flMfvD86iJTi9t+XnQIdlseyuffTSW8l+dISg242+ZqN+HozZ95piOVmCDwr86ceMfdX51BGV4Rl2+ZpxZPxv8zQISUvxJkLz86RhJ04D8abJweHd+frXDgxsX/OmAh7wHGF+dMUOS3s8/M0rcAO5c/OmDg4mPj5+tBI494Pw/nVa+Mncn2d+e5qc92ej/nUUqxshBD8vWmBzSyxaPeOxAJQIMeprM7gbHHqK0moIv7HuOAHHEnPPnWcxg1pHokaEOchj8aky45EGlxk7VJwDh3OD6U6At6g4GhxDmeNtqDcfg4pAQnl1NX71glsMqXCtyG+dqGAlm43Iz0A5CkIs6fKXlIbwqRsoHLeiV+y3Vync5TYJ4qCo7K3hOK0nYbTF1ztLaWd3cNHGxLEqNzjfFJukBqu0f0f2eiaFBdyXM11cvIobiHCgBHQD+dAEiCLhAAPIV6h2/iuv2EROycCyqFRd8DpXnQjGN+lGJ2gWkULhcDIoVeABSSMnFH54wQcUHvoTgmtB2ZmcYY8wKbE2DVm8jxmqsYwwGdqgaPdPoqs7V9Bgee0uQ0hb7RXJV8eg5Vv9McumIHjNqh4RseMH1zWN+ie+K9j4YbeN5Jlkb2gQo+OK1N0s1tcm7WaGNZsKbdjw8Z9/Q1yy7aJp3RTk1mSx1KaK/QtGT4MAYA88UM7T3NjfGGW1YtKpIbYjaqGrWlxa3J+sxmPjJK5bi299C5mZXXhz6jzrRRXZ2wxx1JGgivNITSzDPYmaUqeIkcz7+lYC8nCMUhaSNQTlCdh8aKX2oC3xgcZ6r1FCp7GaeXvUhUo++QRiiiZQV/HsIWcU0tqjxXRUfhKg0RQEIA3OqsXfxwokcUahRjhJqzGWMeXwG8hVI6IoG9pAPqAkH93IrfnRq1hluWCwoXYjOBzodrKLNpF0rZ4uAlcelafsjZXVzbWV3FHEsZiU8bHO+PSpboic+NsY+i3UFqtw/Cpz7DbN8uta3SJWvbFGmmjbbDxhPyNXoGeQ/axjiX72Nj7q6SHG8LCIk5OAN6ycr7OKeVz0xwhRUURAKQML6CnSNGifasMHbfrTZphEoOGfO2FGa4uGQNwb8wr7VJlTFjCgeEbHcU4EnaqE+oGKQLNGFBPNXzVhrqOKN3JyiDLEdBRRTiyxkYwCajPOlinilQPE6spGQQagN6n1gQ93IG6krtSoSTB+qWF3d38EkVwYoVHC/DzxQfW9DuorqCTSr2eJiOEjOSa11RXLrHC7NkADmOYpqTLjN9Hmd3Z67pkkrXLtKk3tSSDOP6UE1XTo9SsnhnAZiPC3LBr0KVdbeGRouGa1YHwS4JI9Kz1zZRiJZk4lX7ynpW0WdmJqqZhOz2j3VveLbTsFAOUYt4SK9a0HTZ7O4WaFGfbfiPCCKBfUBC8cyYlUEHDCt7ZSCa3iZclQBtmlN/RGV8V8S6uJUYFMAjBzVZYpLO1WG0jQ8Pshm2qwZHHlUUrtGnGAGPlWRxnQyrI/BcRxLPw7jOdqG6dpRj1O4nmijWNtkCEYHwog0azEGZMAjGeoprWP26Ok8ioNsL/ADNNMpOuipHNJbXtxEllLIWwQUAGR6k1me1tvLNOsxshbnHiPFktW3ETI7d1wkHdixJYms0dNa91K6GrXE5gjXKF8RgZ8vSnF07NMc0pcmY+1lWCTjaMP5Cr9tcI8rOxEa49kVbg7MXlyzvCUEGSEZzjiHnikGgS2t/CmoSxQwsd34+YrVtM7Hlg/I7ijaMujbjzqWDU5o1A72URn2gG5ijqaDpM6N3LcWRsVl4sUNv9EISK2tlZpeLDytyUfCotGPuwlpmR7aSJcatE9k0gPcgZffG9eb64v9rcRcIH3mJILN16V6Z2w0ubS5oFlmRxIh4mUEcIBrzvtPEwu0KMEi4PAAM5FXH9HJkq9GfPeR7CIN68VRSPJJj+znY9DU4WZ+UiqPVc011nRciVT6cFUZDRM6hVeIgdN801ndjn6ufnTik7DiMiDHmtNzcDYSpj/LQI9T7Liy/+5/2W7kfb/sq14uAjGe6XOfWplBJxg5qx2csoYfow7KTK0Ku+lWjYRTxkmFeZpbe3muD4AMjoTgmiD0evhknBEcUsttIWidlYjBxXAcWWc8Wdzg0Uurayj4FkIikIGeB+PHvqnLYsIpJbYmWJBkuFI/WmnZfJDZLQxwJMHQo3kwyPeKh7sgZG4qAOWwOXnUqMSdhy61VUMViy7DbNSxXLQxMqggvsT6VA7MTk/rU1vLIA0aAYfnsD+dMC3DYT3FsphhJGccQXc1BcWVzb7TROhBwQRyovo1xPHOkcl0YSPx52rT3veTW2ZStzBzLHmPXasnNxZlKbi/0Z3QGjiSNizBycEv7I9K1LRq8RMLCMMPaQCgVvDpSI0ss8UqHYLjBBq7a2snfxvC8Ys+sasTUS3siW3YJ1HSeKTvLe4aV+bs7b/CjWlWq21sHkmmKt0kO1TmSNbgRRplifZA/nU9siG4likPEQOLhzkUuTaomUnVEhHeqFUlMciMVKCV5naqT3tjEJPrE3c92ccJ5/CpdMLX9tJcJn6ryRn2Zh1NSYyddlklWwWziqV5qRtwfq0cpA64yDXSObGFpCTLGR4cDkaZpNykvEbju04j4VB3NCGo6scl3JNA8lrG6Sjcoy4DGmtcXk/wBmyxIx2JVtxVuNoYJGSWVFTOQOoqO3uI7m9kigEYRdxIxxn4UCut0Yrt9pVsYPrU7cU6gKpbnis7oo4o1BXC0n0o3069qTZ99xQqinA5b1JoZ+zWrXRE5Xs9I0mGGXRSlztExGSaErCIL8MAHiBwHZdqPaIAdLQHcEir/AmMEKBUcqHinxTMLqCCz7UxvKsZjfgkwq4B34T+tFO22mrcaX3sDLGsTDiAG+DtUPbuED6jcpjwsYiR5EbfnRzibUezRUnIlg3264/wCVIl34BuhQtd9j4p4Z5DdWjcQAOfEp5fKr7wBdTs77IMV6nds3XzUn16UF+j+8Zbi8s84SQCZQfkfzzWht4O8sb/Sw2JLdu9gP8J3HyORQYytbDcUBiiAVFJHzqUNICCQODG+edM0u4F5YwzfeI8Q8iOdTXGe7IHM+tIz5WylNc5cLw8JPIEc/jS55ZqvcrLDbs4xI49kZxmmWcs0satInMbgA7UG6SrRcqNnCclJ91SOhjXJ5edN8TDwkUAq7GrMpHI/KpAwPI1G7SRxELggdSN6gjEsuX4sAdeVA6vZayx2GA1MMPAhZmOaiinKbNv61NNMrpsck+lAU09EaFjyyRT8KMEnJ6gVwkAQd2WB600K7HODmkBM0fEQVjC+tNeNk35j0pwWUjBYClDtGQJBkenWgm66HccnANgAKh1GXubZpCRsNh5mn96rHLnAHIUO1dw89kBkxd6C3l6UxwjbCtkFs7BDOwDY4nJ8zWN7Y64l0n1a2bMefEfOu17VpLiVlDYQbYrI3Vwqk5G9H4rR6fo/RVL3J9leU4FAdRYw3IPRhkUXaZZM8J3oZq8feWrFRl08QrM97Giv32VO/MVmrj963vojHcZQjNDZzlyfWpZshyeKIg1WVuCeLp9oBU8J3xVW88E0Lf+Kv60IGNc5kb3mkrm5n31Jawm4uIoU9qRwg+JrNutjlLim2eu9grYaN2HM2AJ75y2evDyFWLXxOasawqW0NpYxexbRKmPcKq2J8Zrpxx4wSPk3Jzk5vyEV5VTu+LvN+XSri704xq4wwzVji6KEJ4dqnQ1L9TU7qSK76q45P86RdoQE+dIW9aUxTD8Jppjm/w/kaBnFqhkkxTysvWJqiaCVjtGR76AohaQmoZHOauizkxyUfGnfUgfbf5UC0CmJNMK0XFpAvPLe80jd0nsqKNhYJEEkmyKTXfs4neWQKPIVeluMbLtVKaZjnnToVsekNrb7qoZvNt6hubzOy4A9KrSlz51XfbnR/QV9nSuW99QCPiNSjenAYoKToYYj4WRikiHiVhzU0d0jUTMhD4SZNnX+Y9DQcGmSBlZZYW4JU9k/yPpWWTGpo3xZOLNxDMGHOrAes1pWoLcRcQBV1PC6fhP8ASjUUwIrh2nTOxxTVovB6eJKqB/WpA9VZm4FxJarWsyzXk8/r3a+4c/zqlqt59Vsndcd43gQeZNeev2nktdVCwOTBD4AfxHqfnW+Natjx+meW6PZY2yKfIqyRsjqGRhgqRkEVnOzuvQajEOFgHxutaJWyM9K6E7R5+bFLHKmeV9pvo2S11Z9a7PqfEhWWzz080/pWWMrRcM8RIkhcOOhBU8q96ubiO3haSQgADNeXdpdMt9T1u6mif6pO0aMXUZV859pevv50fjs1x8sumEfpQdL+XQdXi3W6tSDjz2P9ax0kplfJ+Faq/wBG1M9idNtlVL17S4Yq9ueL7IjyO+3lWQGVkaNgVkXmjDBHwrOTuj0f45qOLg3tNkyHejNiubcL0dgKDxqSQK0FghAQEeyKR2ZOjffRwwW7uE6lQa9CryfsveCx1SKVjhD4W91eqxusiBkIKkZBFVFHyf8AJway8vspbw6xn7k6Y/4h/wAqv1T1ND3STL7ULB/h1q2CCoI5GrZ572kxa6urqRJ1KKSlFADJzwwufJTXmuuEtZ2aj1PzJr0TUW4bGc+SH9K861kfaWqeSr+lNHZ6VbstabHx3luvmwreGsd2eUSajFtyGa2JoYs7+Rle2bZkt0HQE1k5HZbyArzGT+VaPtW/FqZH4UArOHe826JVI6sKqKNB2Ph+t3d68hZQoVAUYqafrWjQacqywvKxkfcOQcVd7DxYsLiY85JSPlU/a0f2SEn8dT5Meb92jOxbAVN0qKAZqwVwKo6GULtfCaAXoGa0d2NjWcvt3NUi4lG62htG/DNRC0mKaopK52OKH3f7q3BHKTO9WnZEvFdmIIBPOn4LL95qEkt93KKCETibfqeVBdXZ3to4AAHmcLz6Z3qbSyskc1y7kNM5PPoOVQLwz6sPF4IF55+8aknovcJVQoUYAxzp6EiP2BnjHWmOyKMd41PjKmEnjOOIb5pCYN1fiubq1swAAzcbjP3RRLxDbgGPfQ2w4J9Ru7p2PCp7pN/LnRFmTnxt86olkQL5bwrz86Ri/LhHzpOJOJvG3zNIzJ1ZvmaZLGScZjIwB8aa3HjOF+dLIU4G8TfnUYKcOeJ/zpknDj8lHxpjcfej2eXnSsE83/Oo2CcY9rl60AxzcZz7PzNQsJMdPmakPB5v+dMbu8c3/OmSRRh+D7v507DjnwimxhMb8fM+dKwjJ5Pn40wGSBxw+zz9aXhkx9386ZIFAGz8/WlKpnk/50CYnjz9386YvFl8Fc59acQnRX+RqIBBI+UfG22DTEOcSnkU+INMkD8JyV5dBTiE/A/yNMkVOE5RuXkaAG3Cs2nXKEg5QEY9DWeC5rdHRkHZwaihJYnhZfSsOjCC5AkUMobcE4BHwq4OxNUNG23KnkZU+6u76J3P9nAP8LnH86U4IJUkeh3qyR91aI2ms4zxBueT5UHAwBWpCZ0eXkRxj9KzDAjoPnUsDlGTnG9an6PI5pO1VmLdGkcZbhVuEkAVlVY8+H869A+hqF5e1qSrGWWKJicY2ztUy6FZ7fc2kF9FBDeRB42I4kb3Vie1/Zi1sD3lnxKp+6ela0ash1qOwaCdZAwYOQOEioO3KZtQaxxNqVGatSPILiILkGg9/GADitHcgZY0G1BQY28q6zVGOvweM+VU4yA2aI6inPHKhSnD1LKR7p9EuupadmGt2XxLKxDM2BvWn1G6t9SiVblo+9B8DJsa83+jJEuNOmR5FThkyAeu1a1bOWWZw8gCIccRrFxVnRDHHvyV9QjljnCNKzhRsSc7VXwTsAT7hVyOxeWZ0V1KrzfpSTyTaOveSEGInBIGQPf5U78HQpJaBV1FA2frSgep2p1vGkMQSI+DmM0YS9tLybhnRACuG4sYNDrlEjmdIyCoO2KaHHvYzOTzrgDvjemEjNKOVBZ0qh4nRhsykY+Faj6OL2z/AOilsGwksYZJSFPQ9TWcheMSJ3qFkz4gDual7D6zDa295ZSpwW8N07AEcROdwKias588HKqPTco0PGrcKEZyPKsrNqFmzTd3I00sWeEsxUA+6qeqa/Je2rRW6tEufDwDegei2iiSeW6lVg75wxx86mMKWyMeGlcjTdnbu7u5w13KGTOSS2PgBWg1KNnwc4QDq21Bba0BiHcKhVt8K3OpY5ZlAiVmxnYeVQ9kSSbtDlkVGOU4jjYkcqbNI720i+MhtiAdqmW6mkmMJtz4PayQMjzya641K1ljeGALkbEg4+VFMN30JZOtvCHcgKBsvUe+u0nXo5u+W5dtnPC2NseVRTPC8aRrG2254jnNQTWErjjijUE78YGwFGvINRf5FifWZvGo4ChyAcYIrjrDPaGGSMOSMcXFWfvJvqko4u8lT7zlMDPpVK61OIOPqzl/xAD2ffV8UarHGkGZdW1C1XETkxKMYyNqoG8+tpJx4jB5sxqrcairqrQrwyDmSM1Unue9KGfCqDuyjerUTVQS2amxsRJaLmRmPQ1obGQQxLEMADlWR0u4SYqbW+dkBxvyPvoxFdNHOY59snZs1k0c84uQciuApKyMT61M0yqnEd1oNcMe7LJuRUcOpCRRG64PmKniZe3ewjHdCS7MaKQmPvedX0LDYjahCXKRsjJ4z1HlRIThoeNRkn7pNJkyiV5YZl1BJo2ADeF/d7qlubUTzq86xzRKNkZeR8/Wh97LK8qtwGJl9edPhmaZleaVhGvltvQNwdWEMvx5t4TxjY8fhXFJd2EF6p+tQIWIxnmfnTO9ecFEjPD0YnaulhuXiC/WMHO/CMAjyoTM6plDDabIkNs9ssYGPGQKJQXqy4AXLkc1BK599K1pBIuJY1bpuKfawx28Qjj4uAcsnNDY3JNGG+kaOQrZNdGNRlgeA5yK8m7VJGkkLTsGLKcKTjA+Fey/SYqixtHwWPeEADqSK8f7UK0YhVUMsxzxsP8A55VrDozZk5Pq4Oz8I9HNMVYWXxTHPo9PYNG7GSB9/MCkYq8bFYGI8wvKtCSKdIlXCTHI6F6RIoSuWnOf89OWRAOF4G26lad3sY5W5I8wtAj2rsD2ht4/o57NW91CJBHpVqquEydoVGKdqt4s8Akhu+IZ/dFMEfKsd9Ht1G3Zzs8tyneRjTrdVRGxuI150fmilWVgsZQHlnoKUKPVwceOiCOdkmWTmwOcGjt92ie/t1g+rwRoBg8I3zQRsleELxEHmN6t29j4RJKG3G2OlaSce2btJ7ZU4WSQE8s9K0rXuk/s9VMTyz43JXhwfeKgsLe34W4oxxHqap3RhScxLxKM78W4qOXJ0S/kzoW4oDEe5VGOeIrlvnRHT7JormKUjjQHOFGapLPHBIgSLjA38YOPfitfp2rJdxiOztBIyjxMQFGaU78EZG0tBC4s7a8UGe3TJHlg1b0i0trSBoUBwxzhjVeeZ4IUd4uIswUhW5ZqZiQhYDOByzWBySVqijqeiQm9jubYIkinO4yGHupLqFw0QhPdKDl5AAABVWTXY42IW3b4t1pLHURepcJcyJGCPCCNgKqmaKMktjp4pnlElhPI0Z8LM24HqKoyLaRMzW1/ILlN+JhsxqNNaurZe4jMbqnhV8dKoSzvdXHeTvlidyBiqSNFB+TneSaUs7cTsdyetHLbWrq3SCKSMC2jGCqfe99QXX1DgRbObjYc+IUwDw450mwaU1tEmqXdvMqyWbNGSfFFuB78Ve02a1NqBcACQHJyKCtAqtlDk5zirgjZYw3CQh5HpSbQnFVQXuLB7sd+jwRpjKgnxN76WwsrCeNIjNI1y3PA2FBwetErWWEiFLZDHcg7yk1JjKEq0zyH6Q4Bb9ubiFW4wgXf4Ua0RAI0zvQPtyxk7d3nG3E3hBYDGdq0GigcKitV0YSutnpeijg02P30QJQqPAA3mKp6IypYRFhxLk7fCrbMrNlBgeVZMUNg7tZYPd9nrhgF4kAkA9xzVTsjP3mlNCxz3TkAeh3FHe9DRtFIx4GUqRisj2UlMOpz2zbZUqAfNT/SgEmnsEQE6P2sXIPDHOYz/kfcfnmtxeyrb6jZ3qpgZ7mbp4TyPwOKxnbmJ49UjlweGZOAf5lPEv8AStfp93FrWgxArvNFw7cwwoYTiW7GUW2pXNoFYJL9tGOXvFXJHYnhJOPI0Imumk0m11Flxc2jcMoz5bN/WiUt7FJCsq8PARnizSM4J/RKpOAvFge+uSQo3Qj0FQ94gRW4hwt1pJp440HiBb0oNONkk8kExIkDBhyA61Slk4DhA6H1NI14SBwHhPU4p00cjIJGcSKN9vKg0jHj2SRXKCEB2LN5VbMgFuV4FORsDQyS5SRAkcYA86swrKiZBQ53waBSgQZwdxT0PiGBmpJ4pXPHhSfIVJA5UcBiYEDOcc6ActE8a4IYnBxyHKplIByd6iU8SgkEehpRzoMWrHSXEHe92JEEv4eIZ+VPC52OKEy2VncajFcI6/WEbJ4TnOPOiwYAcqBNV0JIAMjAPwqlcWzdyxIVSPEAKsCcmbu2GDXXjrFGXZQdsUDVpnmmsvwXco6Zz86z9y3ETmtL2ntnWC1vAPs5V4SfUE1lZjmpbPp/SNTgmgXdSNby8S8jU0Vyk6cxnkRUOooXjNBIp2ikBB5GpZ6EVoZfRm3uHQcgcj3GqDknJNHNYUS2iXKb8Htf5etAnG/OpZZytg5FR6jvCG8iD+dW4oXhRnlVVOAQkgILA9RVG+JNpIB0WkibsQ+0ffR3sREsvamx7zdI2Mp/4Rms+h4lUg8wDWg7GvwanO/VYSM+81KVujD1kuOGR6HeXXf3LuTzNPtWw2aDwScTbmiURwoNdjPnUtUGkOQKlU1Qt7jCgNU31gdKVCLgbFO4x12qj35PKk4i3M0UMutMgFM+sL0Jqod6TFA6LZnz1ppmJqAUtFjHtKaieSlNRNtQAx3NROcinMajY7UARsKhcACpJHAofdXQXYZLdAKdALNIBtQu5u41bhXikf8ACgyadJHJcH7ViqfhU8/ealjiSJeGNQo9KV/Q0igZr07pCiL/ABtk/lUY1C5RwkyR4P3lyPmKJuKp3cIeMkDcUbKSRJFcFt6sd8OGhEUpU4NWlkBHOgqh7SyW9wLm3wZFGGU8nXyP9a02mahHdW6TQsTG22DzU9QfUVk5HGKFvrQ7P3izysfq0zBZU/8Ayh6isM2LmrXZ1YJuLpnq0U3EKsBwBknAFALe/h+qrc98ncMvEHJ2IrOdou2cXcvbWGXzsz8hXLCDfZ2LE5uokvbLX1LFIG8WCsYHQdW99YVWqN5XuJGlkYlidzTgK2bvSPRxY1ijSCuk6nNYTrJGxGDXp2k9tLZrENcHEgHIda8gU1J3zAYzVxlRln9PDN+R6nLrv7WnVVOEzsvnWP8A2nJP9IerxcebfgWNV8igGf1NN7K3PcSS3ExxHEhkJ9wrP9n0mj7Sxzztl7guzehbeqc7i2cywKMml4R6t2a1N7C9RS2baQ8Lr5etbLVtD03WIil9axyZGzgYce5hvXmcL74r0ns1fC802PiP2kfgb4U1vTPN9ZBxayRPOtY0Fuz2qxRSyNNZXBIt5n5hvwN6+Rqe2wd+Wa9B7TaTHrWjXFm/hdl4o36o43Uj4149b399pkTLrNhK4jYo81t4gpB34l5jz286pxSOn0mZ54U+0aj6wqSBR4mPQVreymq39t9nIrSQE7KQTj3Gsh2b1bT5biGaOKaWAHJ7uMHPv3r0iLtNCQBDZzAdOPhX+dTu9M5fXcq4KFmijnjuYsbgsOTDFdZPmHgJ8UZ4SPdQIdpTn/ZSfQNU0eqQuVv4GPdZ7q4QjBQ9CRVo8KWCce0H66kBBAI5GlpHOdXV1dQBS1tuHSrk/wABFYPXQBqcKeSrn5Ctv2h/7MdfxFV/Ohd4gftXaIQCEgY8vSmjpwT47KnZFQ87OPupWqNQWagRIQAPD0HrUznCk+QpPsicubsweuyd5qk5HRsUFjwbmdvIAUSvG725lfzYn86Fxk8M7cssatHowVRPQOycfd6Hb5GC2W+ZpnasE2UeB98UQ0qPutNtU/DGv6VR7TjNiv8AnFSuzii7yWZqAb1ZPs1WSSND4nUfGnyXMQX2sj0BqjtZDdeyazl/zo3dXkXAfEfkaA3U8bvgOvuqkVEp3JCrbMSdpganuZElvlhQePPiPLaoLzxW2FxxB1wfI5pe4+r3duGYnxeJs7kmqNEEzmKPCoiqo5A7D8qoaSjmGSfhGZnLZJ6dKl1aRUsnCFuN8INz1p8CJFCiBmAXbrWZI9+88l+dV7ydrfT55CBkYxg9aklKcwXPzode4uLu2tlLGPi7yTnyFNCZd0yB7awij4VyRxHJ3yanbvSeS4HrTmEfQt+dRngC58e/vpkjB3nG2y/M0h4+oX5mkHAZG9rGB51zd2c+1+dMljZOMofZHzqMcfCPZ5etcwTB9vl60xVjKg4bOPWmSxxEh/D+dRScfGvIHfzqQhMbq351DIqcakBse40xC5kHLh/OmEPnJK/nSME6q/yNJiPHsN8jTEIvFg7rz8q5uMDmvyNRDgwfA2c+RpCFx7DfI0AdNxlQcrzHSuPGOq/Ko5QpUeBuflTiE/wzn3UxDsOeq491Q4cO/iXO3SnYTP7o/KowF71vsiRjypiHYfmWX5Uxw+D4l5eVOITl3R/00xlUKT3R+VAE6XdyLH6t3+ICQ3DjrQHVLTBMyYYfeAH50VHDwKe6PLypp4M/ufyFNaEZdUVt8AfCnkBVIGfnRO8ssycUCEA/d/pQqXiDFSCpHQ1ommSwut3BHokqGRe8LAgA1n92OQfypzOcEGmdc5NIB4B5bfKvYfof7ONDZDWprowF2KohAwyjqc15bYWMk5V2RhF5+fura6bo+pX8SxWkLrEBsXkCqB8TUT2qCmz0JdXtR2wWBJY52kZVV0I8O/I0f7YL3tr3aKzyYzwqMkCsJoFnpOnataQXSXA1RXUhlZWjzn0r0m/bvbGY45MR8qx6kqMZakjyG60u+d24IVA/icCqFxoF9LGQO4U+rH+lbm4HjbNU2ZSxAYZ8s1sps0tnm172O1WT2GtGB/8AEI/lQubsPrUfiWO3k9El3/MCvWdj1pp391HJjTZnfo1ha0sL621G3aORJA3BIm+McxWxt1gKO4iKxnc94MflVawdEuZAxwzKMVdmijuouB+IKfLY1Lezqg9bFtZI5FIgTEYOxAwD7qZcRvOjQuVCt1Hl7q6ytBaqyq7MDyyeVKCLVWeeUsCfaPT0qfOi/OiGPTbWOIrwBj5nnVGHSyrs84Ijz4VBorJxyxq0LFGO4yMj40ye67jhEkblm28PLNFspNgHULJ7eQzRyHujtwHoaQxKkSuZUJI9lTvmr2qNCoPfFnc+zHnlQm3lWGZWaMEZ38xVraNo7RO0FwI+Pujw86CabIkeqapDg8blJFPltvWolnlneM2jO0bbNwr7NZbWbO6t+2CNYgyyyQcbKwwHweVTf2RKVVZrtOtHW0V0n9rc4GQKgNtbvduQXZEOG25mrljJOEi+tROrMOSgALVkXEMYkbhCAHckYzUW7Fydlq0ikitwzkQjksYYE48zirpvLLTLaSWaRXnxsvLPwrN2TKTPJDO4LHJ8HKobqxNx9orMT1kl2z7hSpXsh4038mQa1qzX95x8RUYwqk0mlXbW10kiwrPj7jDNSWnZSbUZ1dplhMfLrmj+i9mu4Mkl/KUZTgBCMEeeatyilSKlkhFcR1v2isSks7RG3uUHsdG9KY/aAT2zTW7lFKnjUPkD3eVCNR0wz3bOkcptVJzKinDY8jVOS2tJbZ4rKJXkG+C5XPxpUvBKhB7RT1PVoZrXwT3b4OQrsWUU3QbqaSOWJGtoFByzPu5+FUrjTbqLu41WO3Vzli7EgfGrOm/U4Znhul4pj/eLyb3U6KrwXri2hifvfrAl38SjGavqtvd2x+xKp0yMUImsykryxo5ToxHSuRbiSLwiRox8qqjWtFmG6+rgQ2/AkeeZFEYXmdgZHRx5r0qnYaVdSXUZkhKR44+JxhcVbkklEsbKEEDHhBzu3uFJ14JbT0ixd3rQ2bd1x8fmOVR6ZcyTEFoyrfxDGaj1Nmtrcl0YZ5bUy31bvEVCJFztkLnFTWgStaDqseZGD6GpBM3dMnEVB6jnmqwkWOMcbbY5+dODcS5UcxtWVGTQ6O6WUd27O0y8yQRTwSNgapyGZGUhveOHOfjU6yEnBRgadBxoKWV00MZB8eeS8XKnQXVxLcbt/wAI5UJnlMceVUsxOAMfrRrT7JDbiQrEZGGQwycVJjNKOy1Z3H1gyA+0jYNWd87cqHJp3dzd9HM3eHmSKfc6jCisiMDKNuEdDRX0Y8begD9IhKaXblAXcS7A+6vIO1BZ7SDhwCCS5x1Ir0/td30unLxOQ6uPa868z7SxobIMz5jR8DxYya1h0KceLMeomYScLJlT1HOonFxGhx3eOe1SuIznhk4Pc5/magRFbIedhvsQ9aGRymaWIkcHqDzpVFyowBFimtCiqeGdvMDipVjDDLTsD6PQI3n0c28S9j9FuJwocWEBQE4z9mtFrbW5VkK3f2sRyMAbj40A7EafcXPZPs+UWRYmsLcd44PCPs16+VbC17J6mLqWFoomjVeIyk+HHmDWWjtjLSHWV3ALjgaF1Vt1ajqYZAQNiOtZ62tzb5QNxKDtRW2uEiTLBuL30SVnWk6NTp+mJFp5uLiMlsZCqwAIqk1lp+pGYOogJHgAPI+dBfrdxIQqyScPRS2QKJJBKYFkKMA2wYjmalqjLhx22QyaOlqIm+srLIuxwc7eXuqaICAN3I7sMcnh2opa6DcunFKyRk74JzULWRtr5IroZUn7m+aHJsSyRerspxRzXTiFJGOTnc/nTbgS20jxd8W8yCa0JtgbrvRCbdFXHChwze+htzHBf3AgsYDHKCeN3ahCWS/GgDJzp1nDHPdRxzSiGNj4nPSrOo2E9o6q4DcXIqc5pumG3S5U3SEqD15fEVd6NXK46Lj6AzvIbK6iuI0HMc8+VR22lpLjhkIkU4dHFaFb8pwpBEO4ce3GuMe+ukKRkyiNmY7ZUZNTyZhGc0qkAb7TFjY92Gx+LG1IumXEEIld14SPZ61oJY1lj7sDY75z7NShfAF54GPfStj9xmYGM4JANFo0WTTwqyu3mAuRmpRYwtIwlh4mO4I2xVm1t1t1YIW4Sc4bpSFKdkVxbpJbLDHtgfdA/M0HuIXtHHegDy3yKPheEFEDLxb8QFD5LJu6kSZjLNI+FcDcD1FBKlR4f2nvXm7WX0yqM8eNhnkBWgt76a3s45IAXkOMqYz/ACoLrUSw9rr6NPZSTFa7Rj4UOTWvgxmbDslq8t/aJFJCInAzlSf0NGrWOTLNISBnAXz9abYYFlbHh3OdwN6tlgOZrIIdFaW4kjnWJYSVJ5nkazN+ose1STHZS6v8G8J/lWolkJB4CMjpWZ7WCRPq0zkBnBjI/MfmKZbVoMdp9N+u6VP3PiuI8Sxkj7y70I+j69VGuLYEBmPfR+48wB6HPyrR6ddx3VjBMGHjQE++sFfsOz3a+NypMBbvEx+FuY+B/Wgho2vcRpq1xDKoMV4hdc/iGzflv8KdoaLGktu4He27cGT1Xoafqql7RLiHJeEiVMdR1HxFRTSrDqNreIfsLhRGx9+6mkII3CKwAeThX8PnVRUgeXPEUQdG5mrcr4ZQsYdj0PSql3c97J9Xjh7x8bEHkaC42R3sduw+xchvIbiqqPMq8HESnlnapDYXagscHzwajQEdafRtGqpMv2QMMbP3QKN61JLGixcQJDc9jVNZXCcAbw+VcGOMZNSS47ssRzuAOFzirIvlRR3gOOpociOSe7AJ8qkRDOn2bjjzhgaCZKPkK286ziRkIKqMigdl2ge51SO0e3VQxwG4uRoraRC1SZdyCM5rO6faEajDcFDlGOWB2xTRlGKdmmsbeG3ixFwscksw881bVk4Tx4KnbNBdFuDHbNFMioFYkFd870olbxAMQhPKig9tvsJtFH3nGj8RTpVS+kM8ThBjhGOdJb5IY4JyMZFLAjNdwxjYE5b3Ck9BXHf0M1zSVn7NG1A+0jTK+8V4/MCrEHYjYivZO1dw9nbRzRtjfhNeTayUe7eWMABzkjyNJqker/EuXF30wRKAcg1ntQj7qc+R5VoJTvtQ/UIO+i29ocqzZ70Svp06sDBJ7LjGDQe5iNvO8Dc09k+a9DTyzRvnkVNXNTAvbJbqIZmh9oea9RSKKuoajdah3H1uTvO5QRJsBhR0qlMAyMD5UikEBlOQdwaVvZosSSSpFSzbjtY2Hlj+VaHsqMSXjDyVazGlvxWzAfckZfzrTdmD/tX+Zf0ogvmjk9e/8k1lpzFF09kUGsiMii6HYV0s8EmWpFao41LGrSoAKQHI461KrComj6rzpqEg4OxpjLOa6mLvUgAFIEcK40pOKjLZpDFZqifIAJxg1zGoncCmBzEYqrPMFB3AFV7u9SMFQct5ChE8zzNliceVOiqstXN2WJVD8agRd8nnTbKKS6uhbWcUlzcn+7iGSPf0HxrYaf2InOH1i8W2TmYLY8T+4udh8BWcsiWgbUdGSmmihx3rqpPJeZPuA3NEbLRdZv047fTZI4TykuXEIPuB8X5Vv9M0zS9I302yjSXrM/jkP/Ed6syzPIcsxNZPKwVvwefHsrrWcFtNj98zv+i05Ox+os2J9SskXr3du7H82FbrrTSKjnNdNmlIwSdk9FiuO61DtHcd5/hxwpDn4tmi8XY/s6qbpqFyOhkuiB/6cVoZ4Ip04Zo0kXyYAiqJ0az/ALpHg/3MjJ+QNS52XxT7bAd92I0SeErbQzWknNZopm4lPxJB9xryf6Ruz2p2SRR3695bo3gu4lwknow+635GvcG0u5T/AGfUrhf4ZQsg/Pf86rXcGqdw8UtvY6hC44XjbMfEPLByKUZOPTN4SSaPneyHdW6xo8jKOQdicfDpU3ESdzWi7baJbaZOk9pZXemBm4ZIZ/FF6FXGQB6Vm2DK5VwVddiD0q00z18OVSVdBCIeAU/pUFtICmM7ip8ig6BVNOB3phIG9KsscUbTSHwLvTolugihcQdyrYV/FL/kH9TtTLNidXs5P4z+YpQWTTw0o4Zrg8RH4V6Co7U4vLdvJqDJK02a5JcNmtH2Y1MWt4AzfZyeFh6+dY0S786s28/Cwwa0Ry5MSnGme4QsGQHPOsv2o0oRzNfQDZ9plA69GpdF1UzaIkgbxxHhatFbSxX9pxDDKw4WFado8JKXp52eYfsy1e571Yu6n/xIiUb8ufxr0jszpU0Vqk08aSjGQHHiNZW/sH03UQrDihc5jb+Xvr0vRZ1udNgdfw4PvFRx2afyHqJPGnHpkqCG6tjwKuCMYxyPlWXubYW928qDZx3cqdHX+taK7D2c/wBaiUtC20yjp/EPdVHUUDTF1wVYZBHWqr6PLwSp14Za7OTM9h3TkloWMeT1HT8qKUK0PANwMdQfyorQYZV82dXV2K6gzBmv7wQJ+OZB+dDo/tO2Fwf8ODFEdX8d1p6ec2fkKHaUe87S6q/RVC5pm8NRf9Bey3t1Pp/M116/d2szHopNN03ezQ+ef1NQa6/Bpc/qMUiYraRhZDsSffVSzTjjjXmXf9TVi6PDDIfIGpdEhEl/YxnlxAn4b1oej1E3N5diyjRVQscbb7Cs5qd3LdrwzsO7zkKNhVvtdLLD3TIMIwI4vI1j5XZ2yzcR9TmlFGWCCa5BaN4U9kxj3YpZLqHG0goExwedRM3wFVxOjigldXUbKcPQK6lWRyCyk+tTk5NRSxq+OJQRTSoa0U2jDoVGVzgkrtyp9zKUuLeZycAgmrEVtxZEAPF6VV1ZCkaq25HPFUhp7OvNQimvLfPEY4yXPhPPpUo1aEA+1zz7JoGgyzueZOBTJCPLepoGGpNZhBHtf6TUeizC6u72fG5AC56DNAJjtnrWj0CARWTlh4mGT86KJYWbjP4fzphVwPu/nSsEPRvkajITor/I0kSRkt3hGVzimsZAR7PyNcQgc+FuXkaaRGfuN8jVCObjI+6NvI1GvFwLy5eVOZUI9hvkajRU4F8DfI0EjiHI5j5VFIG4k3Hyp5C/4TfKoZAuVxG2M+VMk4iQHYr8qYVfPNflT+FcfumPwqMqp/unx7qYEYDb7rz8qawY7Flx7qUIpLDuW5/hpGQbgQt/poAilB4NnB+FOw+d3X5UkieAgQN/pp3d+cL/AOmmIRuL8S/Ko8Nxnxjl5VJ3Zx+4b/TTe7YOfsGwR+GmIawJ/vF+VRsG3y6/KpTGesDZ/wAtMMbH/wBnb/TTERKpKAcYxjyp3Cy/3g+Qq/ojQQX0L39m8kC+0AvOrfaS5tLy7V9O09oo1GCQmM0r2IAsDxLmQZ9wqKeBJhiQo3vAzU0qkMvFCVGeoG9d691+lMAedJtjvxsPTIp9vp1tGxOxIO3Fg1eOf8Lb4Uxc+L7Pr6UwJraRYp43kYOqnPDsM1c1bVp787yiOFdliQjAofkj+7/SlYkRn7ID4ilQWE+zr8Ou2Ld7n7ZfLzr22/futNuiBnEhrw7RSRq1meAD7Veo86901Iqljecfs8X8qyn+SMcn5IwzSd5xksD0oHbP3VzMwUvk4wPfR4kMTtlfOhUWBeyDYbGtUWitZgfW5Bk75OM1ZngWVQGd13yMHrQ62GdRuCBkAE03VJQWg7okE7jFOh1sOWcpgdtjI/ByBxnern16OODvLh4xk7KpyayfaEWiWyTahNwMiHhwSCx8hiszpuji9la4nW4htyfBE7HJHmaagmrZ14lcT1uNxJGH5AjaqE2nRXlwJJ5nkCeyucYPwrIW+nxW7o0MlwvCcgd82PlmtFb6tLhEMaEk4zyzUuFdG3Botgx6bbuXd2dsgY391O01Z3RZbidjnkhAoX2nvbmJE+o2zXK5xMEGcD09ar2l66shmaQxjcpnBpcbQJWgvf3kFpcSSSQO8qr4cDn7jWb+vx6hI88SlATuh5qav6lfG9ZfAFReXnWduh+z7sXKD7GQ4kA6HzqoxLiuOzUaKJu+zEAAebMDiota72DtTodw5QozPCSPUVY0O8crwRqZUIyNwAPWqvbGVhb2Nz3ZUW95GcnqCcGsZdmeTsPyXtsrFZJkXFRiSykgPjWRDuC7ZzVPWJEhkRookz0J3/Kspqssw1GK8eRu69lgo2UegpxhZXHVm6s2gS3AjMaKf4qjvb9YEPD4ivUL4T6ZqlZDTtSgT6pOJQm5UHBz61bub21jRQQjhDjgHMVNbFVsQ6kIou+PGjN1UYpkU0jXMdzfmS+gxjg4twP51nrntBZXmoy2UcLGVR7bNsPQCrdrfG3tWiC5PQ5q+JSimjbavrIsdLhk01oQPZ7pxuo91YSW7meeSbj4XkOW4RikmuZpogkh4lG4ON6dbWb3CMykYXp504xUUGPGsaGCKa/VoSzsh9rfYVMtiLF4VtY5JiPNMgfGmiN8EWrSH8S8iKv2RvjBmRomyNlIOaGVIqTz6vLIkMVq54zjCLk4o/c6NfwwQCKNpF4QXjVeHHoTVLSrC9uLna8EQU5OTnHwNbGyujHL/a74NGBwjvAFLHzrOUqejmyTlF6KdpfQrClnc203s4CRxsVA9/Om3x0ud4RGgV43ALBM4x0ozdQtcqoQ+BjueW1BJIGtr1lVIwiDK8IyAaizKLTd+SDVFTWnb6nMbhoTw92icKg/xE1aGivbQGS34nYptEeQbzqSCdIu8YAI5GAEGBnzqOG9mhlZ3umKEbIE6+pp2X8qpFeeza0aBLg5lmPCWYAgn08hVXW7qPTXWGBlml24t8Ko99E0lnv5wy91J3W/iAIBpJNJku9PlGomKBic8MS4A9WPWhV5DlTXIyN3eNe3SizuGYjZgDhRVxBdlld7jvGXko2BqDVrDT7SNo7W5jeVN2bJyx8hjaqelSSrJ9lAZWz58hWuqOpO42jWQM5Ud4uG8s0WgHdIBLIS7bKqtyoJDMW4RIhjkP3Sc1NWDOeUbDFzerBF3UZLOBjPPFB3PFKZcDvOecUhIG5pCfLejoIwUegb2jSSbRJ5J3UMhB65xmvNteKrph4k4vECihc7Zr07XUZtFum4gFUAkZ578q831zjl024IC8eR/wAI2rSBz5uzDMFExZoXA8ilNxA7HEBZh0EealZpVcqAhPxAqHjnSQnu1+DVoc7IY1gXIkRic7ZQ7U/+yHfux/pqVZJJScIuR5timKkqDAiXHo9Aj3b6G9AcfR3oEl7K7QTadbyLCWyuDEpB9DW1nltNPtViFyqvjA4vEW94oH9GEbr9GXZN5bmQRnR7PAUABR3KfGtMlrZyMHMSyMu/E671zm8XrZk10q51LUu8aC3a2TqimPiopqPZmKQK9se6OMd2q5399aOMh0B4eHPSmvDxSq/G4I5AHai2V7skzLR9mJe9WE3A4ccTsF5eg86N6baPBaG3SRJUjbGJIyDRUUtFtkSyylplCO1a3kZogxJ6liabInDP3zxr32MA4qQ3JklaJSAw5jyriiPGXjlD42ON6RW/JQkjlDvK8hlXHsluGqBt/ra99bwCDHXiOW9KNoyKjAjLHqaWBYh7RHoo5UzTm0CmN+/dtHDDGq9HbJqvbWdybySWXEJb8ABU/Ci07qC23CKpWcjd6V+sd4Ad1Yfzp2Wm6EW3uJC0c7KU6Mhx8xVwAlO7MhDgc0GKe2QMqMnyzTqRLdiAYAB3Pn50uK6uoJOAAOetLXV2aAO612PFnG/LNNaWNWCs4DHoad0oA8F1nftfftjYzGtVo42XpWT1BuLtPfE8u+b9a1+kA+DNa+DKZ6RY7WUHuNOnIHWmQHhs7XfAOelSOcdOfXFZFY+hgjjHC7H40H7S8N3pk6QMzOg4xgdRVyc8E4Qy8LHcA7g1DPM8L7qkisMHhHSmbUU+xGG090LKeB/kDuKi7b6bFqVrHJHKBPahnVMZDDHKhHZa7ht9Xns5mMWSVUE43ByPyNaa+NtPHJG8ZyylSUbpQSly7LXZnUI9T0eGVCWAHdtnzApi25lsbuwPtRNmI+h3X88isx2KkNjcXemRNwrHISOIdPOtbOBbXdvcKRwN9i+Dtg8j86RDjRY0q4+t2COcceOFwfMc6mcxJA3GAjAHAzj86DWs62es3FvIWRJvtEx+IcxRWVklXvBwSKo9k7EUBQJEkhJzI5+Jp6706doWIMKsvmp5UQgnQcCvH3bHYbbUGzlS6B68s1LblC47zl+VXLqEsPs+ED3c6ZbW0iMS2B+YNBPNNDHhja4Tg4jEefDV4CKMlgu+MbUirJywAB0HI1z/AGaHhBHXK86DJuxEYy8XDxAcsE0+KJIUCcWw3ANQWUxZmB4yM7ZFTzFQQzYDDkTQJrdAOJ2S/eBY4hGQXQrnNXAwIORjpUkjoWLiNA+McQ51XkYcJGdvSg2W+whYs+EEYBC7HfNXLBeO9nkx4U+zU/maDafMIIpuJjg7jHnWg0+L6vZoG9ojiYnzNS+6OXN8TOfSHOqafFHnxFs15Ne3cSMQ7ZbyFa/t5qRvtSaG3OQg4B/M1lo9DidWEzl3Pryom60fQ/x+P2sK5AWa+hJ9vHvpqzpIPCwNM1XRXtCWVA0fmByoOeJDlDgis7s9WNNWizqVuDmVBt1qpY3P1ecE+wdmHpVm3vVkZopBwyY3U9R5iqN3DwMRjY8qRQzUYPqd2VX9xL4oz5eYqszjFTxT/XdKe2n/AHkTYVuoI5GhzO3dtxe0o3FMTZR0WUfW76E8w4ce41rezp4Tc+9f0rEaY3BrTn8a8P8AOtloLfa3K+imnH/qHF6zeD/c1ti2TR+2TKgms3prbjNaW0bwiuhnhltAAKkqLipc5qQJc12A3MVHnFPBzyoAeNtqcDTM+dNMgFFDQ9jULuKq6lqVrYQtJeXEUEY3JkbFDLnW7JbeOf61EY5RmMq2eP3AbmnWrKSCk06oCSaEXl68mVTIWiml9nta1tRLDam2tjuJbrwAj0X2j+VaG17BabDg6rdTX7dYh9nH8hufiaz91f6di5xTryecQu93c/V7CGa9uT/d268RHvPIfE1rNH7B3lyyy69cizg5m2tm4pGHkz8h8PnW+thBY24gsYIreEbBIlCimvKWrGU5S7f/AAFyl1oSxhtNJsxa6TbR2sI58A3b1J5k1GzFjkmuJzTSdqj9FQgo9CHnTetLmkO9I0OpKU02kUhK6lzSUhi0ldSmgCK4giuIWinjWSNhgqwyD8KxGvfRtpOoZksmfT7gDwtF4oz6FD092K27q5PgcD0NUhctxDL5WivJrjcl+LPDO0HZDWtBDSXNv31sP/aLcl0A9RzX40DSdwuxyK+lxJncVldf7BaNq7PNEhsLttzJAPCx/iTl8sGqUmjtx+sa1kR4gZGc5dsKNyfKruk2/wC1LtXYEWcByqn77eZq72h7J6jo+pQ2t8qGCVsRTRnKPj9D6GiJWPTrIJFjPIep86q+WjrU1NXEp38vHcnHsrtTbf8AfIfI1XG5351Ytv3ops2qlQVVt6sRtVFTViJqpGVGq7N33dGaBz4Jkx7j0ohp+r3Gnz8cT5QnxL0NZK3lKsCDg1eExI51aZyzwJt35PUbO8tO0Fo8DAB8Zx1B8xVnQrqTSbo2l2fA3Juh9a8102+ltbhJoW4WU5r0vTp4O0GngnC3Cc8dD5+6qPI9Xg9pf/5f/g16lXTIIIIoNdKLKUJKP7JIcI/+Gx+6fQ+dDLO6utPkMLk7fdO4+FG0vbe8haK4UAOMMrcjTPJeKWN2tohsQYdUKH2ZI9veDRistcSNobxPdOZbBG+znPOMcuF/TyPzrTROsiK6MGVhkEciKDPKrfIfXV1dmkZAu/OdXsV8uJvyod2aHFcatMespGfnV65OdbU9I4GaqXZX/sq6l/HK5pm6/BhTSx/YIvcf1NUO1L8OnhfxOKv6Z/sEP+X+dB+1sm0EfvNC7FjVzRkb4/YMOhIFGOy8XHq6Eco0J/lQe93aFB1fNaXsdHm5upegULVPo7MjqBqHVXUq4BXqCMisB2ugT9pBbGIBQni7oYGaP9odQEE3clmJxnhX+dZi7vpH2CIgPmc0o2Z4INfICTGWLAYb+tQGWQnOVA8uGrVwOJsu5+Aqs8YOcEn3mtDssjZ5CobYA9SKN6Pp/f2LXUq8SqxXJ5E0IjZUDRSn7N+v4T51rtDH/wB7DRtjiSZgRn3UMjI6Wge6pGh7tQvoBis3r/hhJ2yfzNaWZeIKOp64oLr8Ymlt7ZeEMTxE+gppjizNYwqqcbCltrWS7nMUIBPPfkKOv2auSTiWPHuNWNL0mXTpnkmdGUrjapchOS8GWu7Ca3vkt5wvFs2xztWlsVIjcKOS0LbjudQe9f2JCRHnyG1FbUZ488ipp+A8Foh/NflUbB8blflTuFMew3ypjKhP7s/KgkhKv3nNcY8q4o4PtD5UrBQ/7s8vKmsq9Iz8qYhrq/4h/pqOMOeEcQAPpT2RAP3Z+VRKFGG7vOPSmJhKR1RiodQBt7QqFpgP7wf6qx17fmC7lRre2Zi5JMi5O/xqO4uriOQj6hZsPMRnf86Vk8TZmYdJF/1CmNMv+Kv+oVi/rtzy/ZtoT/uz/WkN7df/AKNtP9B/rTFRszMuM96v+umGZeky/wCsVjhfXOP+zLT/AEH+tMN7cf8A6NtP9B/rQI2RnGf3q/6xSd+n+Mn+sVjTe3J//Ftnj/If601725SQr+zrP4IadiNkZ1/xl/1im9+n+Mv+sVj/AK9cH/8AF1p/5Z/rTTfXP/6Otf8Ay/8AnTsRr2nQf3yf6x/Wm/WE6zp/rH9axxvbog/9X2uP93/zppvrnP8A2fa/+X/zosDZG5j2+3T/AFiujlVw3BKrY6Bs1k7O5nluoo5LC2VGYAnu+lamG3hiZu6jRDjfhGKa2IqatIFWJpH4Rxc81WjdJBxCXI94pe0gP1SMhQfGKr6ZxG2wI/zFPyMs7EgCU+m4rVDsXN+yjepdgeDjZSKyw4h9wZ99a237WcXZ2ewmRhcBeBWB2IpSvwMyGQCftfzFIxHAcyH50oD53UH40khbhYcA5edUIu6UyDUbU94ciVevrXv9zvbz+uD+VfP2nsy3dueAbOu/F6179c5a0n4SQeBSMe6scnaMcnaMRfBwH4ccW+MUGW34A09z7WOXlRdyS7cQHvBzVSdFbZ+XPFaIoGWSiGKS4m8PGevlQ5eGK9WS4R1jJyuelHn7rvBxFS3QE8qr36wPAe/YBfPqKpDTK14lvLeWkkyxso4irsvFw+6l1O9jm4UjXwr949aivIo44rcwAFMnce6qzBXADkhevDzppeTuwfiOVgxwu5pTlThgVI6GpdFa3kvClraSYj3MjyZx8Kn16QfW4kXHGVyfOly3Rssliwag0EIjWNff50Pu4xds3GDlj9zINGrGWKaAQxREsF3JG1NsBFbM6yMDNnGAM0rodmWaxvIs/Vb1/wDJMOIfPnUclxdLGyX9lxxnYvCeIfKtJOqG8Y3CvEp3wBzpt0lsQotSxYnkapSGZjSu0MtlciwYolmdo3KcLfE0e7XSzP2elUoODhDqVbOMHOadPoEepRPDeKYyBlGHMGhknfaZpc+k6j4oCrLFMDnB8j5UpVLozetGkit4ntkuVKs7IGw5yOVRRfVr4FZoPENsIu1VuxunvqWkRzuF7qOMKzM+BkVd0pbnimS3t5LiJTu0YzioKTVdmM1m0vOzt19dsuJYHOCoPT1q5ca1YDTVu47gSMy5aPPjVvI1o2sYrxJncOFyQ0RFeTdrLSLTtVMdqzdw++GG49K0TvsTuO0Fux6G6vru+fqcD3mtgvDnxEgelC9BtY7TTYkiPEGHET55q+wJ5UmaQVIPWJtpYWSJADjfiG9OjtzbwMsJw53zQvS2kWcLFw5YbkjNWLrUpUYxiMI6nnnOait6Fxd6HWQeMSStOgkJ3RutOt/7ZdB2kMboMcMZx8/OodLhS7uy8zMr54sAbGj0tnFNIGk3AGAFOKmToUmkXLSQR4ZcFgMEgb1NIlmxR+5DSjm551BGxRAnAnAPMnNOdgT4VCjy51iYNWyRbiRTlZH25b8qsRXLPkTFnLbbn+lUacCQQQcHPnQDimFGtUbASJlXq/P8qqMkSvxLO4HLu+Dc/GrttcoQS/EqH2goJz7zVySwtpEDcPDtnIpGPLi6YInSGNVERJc7nB2qK/47qWN1a4YqvDwA4Hr76VntopHXiaUjZQNt6ZawT3l4P7U0arvgNg1S0aJUrHalbiW1SGwsWEoGe8aMBR6kmswdQvLWXuZ+6XfHecAOB8K3cdnLJM4vpWaHksYY4PqaF6pBpEDyXE7oJU2WNxkD3L1qoy8BjyVqrKNvJDIiuJI5nX76rvUwZiwwF4Mc87/Kg4u1e9U2l08ikEsO64APSiNrJNI7GRcR48JGN6JRo2aos/GmFPETxMPdvTsjfcbUx+MsCjhR1BGc1BBU1sE6TcAbngrzzWFJ064CsvsFnPrXo+pASadcgZGUNebXfAthcIRlOHJ2zxHFaQOfMYeVFY5SUqf82ajVCcgysfXIpZ+6EgJiZR5d2QP0phFqTnhb4Ka0OZjhC65KT/MUivIRu4z7qYhhV24lJQ8gyHalxZnfl86CT6D+jS7nb6MuyzGaOCGPSrRAccRJEKc/KiF5qDzzFkdk8PCSp3asv9G0r/8A3OOzsQZQh0u2JB5n7JaMA1znpY4JKw/oN20ZEbFCjHmzeLNFJNSijuhC4Kg/ebYVjt0AOCM8jScRJGSTigUsKk7NrdajHBFxqOMdCDt86ry30Nzp5nDSJwnfg5g0MW8V7OELJEJV24HXY0nHJbyGK6Uxwyj2YwCp+NBksSRBeags4VuErLjhLDqKs6RP3alDIAg3CtsT61YtbKJiGsGRmX2hKM4qn2ijlWdGl4PZx4Tz+FBakm+CJn1RRclWxwfiG9TSXK91xqSM8s0ABjVASGLZ3GcVPbq163AJSi+XMimW4JCzajKZsfc5E4qxBZXHfpIroYzuWRt6r6fDNa6kbZp1x7QyM8Qo6WWIMXlAXyO2KLE39HOJw6cDqy/ezsacysz+GYhh06fGqa3UssuIeB1PLYjHrU724WFgjtETuzKdz86RFFncc8VHcTx28fHM3CvnVaziijtzK+xG/EWLE++rOYp4eJuFoyM7jamKhkF5bz57qVWx8KsZztn5UBTVrWGFoRbs8aEjIAwfjUdhrcMSFJI3CZ8O+cCnxZXtt9Bq6mit1DTXMcSjmz4JNRwHgy0cnewOCwfIwKzNza2V/qnezSOLcHOB19KI3GIbYGzfurcKQsWNj6ik0Li1o8hlbj7Q3Zz/AHzfrW00geJAc15/ZsZNXuGJ3MrfrXoOkHDx5rRnPM3OoXhstNtWUA8W1U4tbEhcBMNjCZP61JrjLHp1oWGR5VnZZkbHApVh1qYqzpwRTgXLmaUyh5Cx33aobq4miQGA8SnnURuHZeEkVaW0WSPPFh/KnVG0oqjFao8kWsRXJ4uF8cR9R/yrc6eCLVSDkHlmgvaTTX/ZpdkZXiPGNuY61oeyw+saTbSKvHG68DZ5gjrUsxXxYA1CR7DtHDcLss6428xWmV1licMMrIu29U+3FjGdKikiULJA/FnHQ896TswWvrPHEoK9OpH/ANc0gTT7Ld1ePdafHcR8C3Fq3ESOZI2aif2bmO5aUSxuAxG2aGQWUi6i0LgpHOpYZ8xz/KrfZ9Ftjc6dIqloGypI3ZDyoIdLoKKLeVQ+FIA2Hl8KWNImTIBx5HpSxxcD5ATHoN6kWJVctuSfM0iLInnQMEQksdthU0Qf77g/CnFQSNhkU730CZ0jcCEgEnyFV3iZpE4y+/SrIPyqsHiWUyPMS52wDsBQJFjHAh4AKrzq8i7uAR0ONqbGskkvF3jd0eRpl/nbCYUfeoKS2VGGCQelNiVTnoa6kAAORTNi3Ywi4v448eFfG3w5Vf7U6iNN0mWT7xHCvvpez0R7qS4bm5wvuFYv6QdTE2pLbBvsodyPNqmPbkZYcfv+oUfCMnPKYkeWQ5lkOal0mJxGZpSctyzTbO1a8mM04xEOQ8/Sn6vqMVgnCuGk6L5VH5M+jX/ai3IUYYYA++gl/olpcZZB3bn8PKhF52mkjUlhGnqTQC77crbnMt0B7oyRRwTNownHZZ1nQri3Uuv3d1cdKEw3bXCNHKOGWM4ZT09R6Ub0XtPLrmY9NU3knIosZGPeTsKTXOxuuyxi8tjZR3SbiIEjI/CW5Gs7SdWac/szIbutTZOkq5+IrruIurBW4WI2NUL59Rt7tDqenXFrLGfwFkPuYbVO+oQvHxKTxfh4Tzp2vBVmfse+S9uWm4e9jkGOHltW27NTrLqjAcpIc/I1lrGwvp57gxWF5IXfKlYWOdvdWu7LdmNdj1KK5awMEYBBM7Bdj6Dej3Ip9nNnjyxuKNNb/Zv6VodKWS6U9wOILzPT51NY9nLZMS3ztOw3KnwoPh/WotW7SwWQ+raaqMV2JAwq+6tXNva0jzsfpHJ12W30/UuEslzaKfwtGxHzzVG5u9S09Ge70x54V5yWbd4f9Bwf1qHR765vLgvJKxUc960vfqkfESBipU2+maz9NGOmjCr9ImgNcfV+9uxP1i+qycQ9MYo1a6xLeKGsdK1GVT96SLuh/wCoih3ZRhf9ttYvnALIe7VscgAMCt4WzQ8km2lWiJ+mxw1v/kCQx6hNgyQQwKehk4z+Qq59Q4wBLK5Hknh/51aZgDQvVtftNNjPeSBpeiDnR8n5KjhTfxRaGm2KAqbaIh9mLLxE/E1V+iPQNN061uZ4bSIT/WpUDlclQG2AJ5CsTqPay8uZfsiIkBzhedegfRvc5sbxT7a3BkPuYA/1rHKosv1OGePFt9noFzctjGc1QZyTuaZJLxNTS4xQ3Z5sMfFDyajZqYz+VMJqbNVEcWpM0zNcWAGTSLofXA0xZFPWngigGjjXV2aQ0COrs0hNNZwKRVD84ppIO2aheUnlULkkHfHuostQJ5CVOzUK1GxkmkM9pcGCfqCOJH/zD+Ypi3EBnZBMO8B3UnBq/HIpGM4PrS2a8eO0Zy41yfSWUatZSwoTgTQnvIz/ADHxovZavbXYzDIreg2Pyq9IiSRskiq6MMFWGQazd72Tj4zLpM5tJBuI2BaMn9V+Hyotlpwf5BfWGs7vS7iK7QSRFCcEbgjkR5EV4hdXJmcZzt50c7U6r2m06U2OqxpbwSgqrx+ISj0f+XOswp4iK1TSjSO70mJRTkmTocmrMB+0FV0GKmjOHBoOpl0GpkaqoNSI1UmZ0EI2351ajehsb1cibPKqTE0EYXxWj7M6q2nX0cgPgJww8xWWiOasxsQQc1ZzZsayRcWe7tBDqECOMbjKsOlUZLdoH4XHxrNdgO0S8P1C7ccS/uyeo8q3s8azxfmDTPlc0J+mnwl0D4l44mRwGjYYKncEeoqppQbRr9LFcnT58mAH+5bmU/ynp5cqJRJg4pbmJe54mH7tg4PkRQjKUvAQpK4biuNBzAS8fF9qD/4dsBTezi932dj/AIgTVXVHKwa1IDuQsY+VErBBBoUC+UWfypm7/Es6dtYwf5azfal+K9RfwpWmsxw2cI/gH6Vkdefj1Ob0wKa7Hh/IByjN5GOfCpNbLsjHw6e8nV3P5VjVObqdseyAK3+hQ9zpNsp5leI/HemzfO/jQmqaZb3o45QVkA2dedefXO0jgDIBIzXpOoSd1Yzv5ITXmjnO9ECfTt0ylKD1B+VQ9cYJ+FXGHrUTnetDqspyKeXCT61asb6exTLZMT+EjzA/nTRG0snBGCzHpRue2ituy4GoQuJRIeHhxyNF1oHLwNSTv4leI5B3BrPamS8lzOT7JEaHyxzpbPUmsY5Bjjj3IBOMGq8l6W03uTGOI5YtnmTvVcSlFooveXIXa4l/1Guiv5wksbzSO0i8CAnO5NRPy38qn0K3W41dOI+GFS/xqWhMM6jALWCyiXkkeKS0z48fhNWdfG9ufQ1XtB4iDy4TtUx6Ij0WMNgeMcvKmsD+MfKlwpUfZH5CmkL/AIX5CmBEwbjHiHLypGDD74+Vc4BkX7PoegpCAQfsf0pkjGLHk4+QqJSeH94PkKewAG0X6VEg2/ddfIUwGPGCclkJ9VFBr8Zdx1Bo4QCf3Q/Kg2oD7STbrTED7iN3lwGcYH3TimfV5fxTfOjekxK8kxYbgCiKIuOQoFZkTbynOGl+dNMEpPOb51rVRe9xgfKpCqhiABTCzG9zKB7Uvzp16h7xcFgfQ+lau4iXuyQooNbQrJfMrjbFFEgTum6PJ86b3Tg+3J/qrYCwR2CrHknoBTr7SntY1aaAxg8iRzoAxhibHtSY/wA1MMbZ9uT/AFVrTaRnB4cinNZQnHhFOhMzGnRlbhCzOcMOZ9a1re3zofeW0cKK6Lg8Q/WiDDLZpkgrtH/sIJ2w43FXexs9kmmagLl1LmPCZPX0qr2gBOntjoRQ/Si/dNgKN/Ok1bGi3xLn94fnTAVDt9oce+pWL/hUH301eISNgKeXWqAQMhH7wj41zlSh8Z5edS+M9F29aRuIqdl+dMB9o0ayxHjb2h19a+hAOO0bnhol/Svn2Dj4k2XYjrX0BA4GnI7bD6upJ+FY5O0Y5O0Yi4hKTyZAGT08qpyKM8qu3MsbTusZJ3zvVWQVaKAV+Aupoduhq/mKYHHA46iq96im6U48W29deWfFIJ4iyuOfD1qxj5bOKXu4svGrN9z3UOmtBbSGMSFwOtEJpLtYIntkR7jOwbYGpILG6uYxLqUyhyNkjXAX3mpTpnXgdFCymaz4hEBwsckHrRK41CzjtBJed2rOPYHiY0PuIljlKI4dR1qq0EbSByoLedU4pnS430HLi2aaxQ2B4CRkb4yPKqHZx2ea476JxJGcEkbVXieaGTKTyKh+7xbD4UZsJICjCN2HVi3M1DTSE4tBCxtLLVeMzSHEW5CnBqWPs/YXAPcXB4xyZDyHr51FocsNvqjJBG8jyrhuHkPWtIsIilaRCEDYyOED86zbroxnJp6KFroqRtG0k7yMhycADer1xp9pOHMltA7spHEUBNWlwRtXd4gPDxDNTtmTbZhex1sr6E8DlisM8sLRrsD4uZo/bRG0tnhsYeEkYBxy+Jod2Yke21PXraEAot13g9zCjcwmlUyOowKs2i7VMzt12fZI2K3LLIwyzBsk++vIfpB0yeyuYZZJFlRsgMD+te+yurWvdIgBPNj1rz/t72XN7pU72a8LIe8w5Az54NVF72XtrZn9AuEl0q3ww4uHBFEWYjBG9ZLs/BO1iO7XLI4AYHl8K3UUkl1JHa3MUStjIlI4T8BVN0aRk0tlSKRkPHGxVvMVJDG93ccJfxt1arN5prwAtGeNBz8xUllcWyKiLbs79SR1ob1ou9aLmjaVLau0t44LKcqBuMUZV0YAgjf0xXK3gUsCNuQ3p5Gdm3rmbb7MHs6lBqC4l7tMqjseWFG9UrS8Zp3EqmGMcu83ZvjyFFBQU5GnIUDKZOLh6gdajLoE42ZQv4jTlfiUcJyp5YO1IQSj1GJAqMoSFfu44iTUU2qtdIVjwig9DvVPAbI4gKhSLusmM4zz4t6eiVCPZMFCsWCgE8z51G0yox4mKsPKui77Ld8UIz4eHypl1jgxwFs+VCKLf1xprbuWl4kznOd6F6xYxXS986lrgDhRix2+FPJMahQihz5DcUsKTlgSzAetUlWxpJO0Q6fDFZ2o2Kynm2N6sxzuisblQiDcODsaVJLl52HCvd/iYVI0fFnveCQeRTak/wBg39jo3WRA6DwtuDjGaGapeXFoFMaBiT7PCTtVi9v7exiUMRxdFUcqyus6xdTygW8sqxem1XCDbsaT7NCmoi7tZkkt5Yn4DsynB26GsPIRLBIAmyrwqvn60Qub++uLYxTXUrJjGAcZofboTBxADjZeHHkKvjxOf1MHGrMLO8kcnC6KSfJ81EzS8QPc/JhU9xDJ3rcUoyCfuf8AOo2EqnaRT/wf86DiZH37luEwtxeXEKjMcnET3B3OfbFSGGXj4lkTPqn/ADri86kg8B+FAj2D6O9uwXZjOQP2Za5x/ulrT3KRIwEJLAgHJ86zn0bIn/QPswZ2Ij/ZlrnHP90tah57TvgEgbuhgAhsN765z1I9IhuZGljQlMcIxsf5VXGScCr9pcpFeNxo5ibbh+9UupaV3Sme2Zo0O5jkbJHuoDnxdA04AIYeL9K7vGOBxNwjoTyqPBBwefpS4oNC+uqXcV1G68CoFwcDmKj1K+e/dGYAFRiqjA43zSA9KCFCN2OCSMDwgn3DNXNLt8q5MHHw+TcLCqkd1FAxzxGXmoDYHxojHrO44o8YXp1PvphK30QXj3VxH/YIRFNGd+JcuR76ojU7qLiS5RJm/wDEG61fvdYb6sq2/Esre0eePdQRVeZmyfFzOetUl9hGP2HdF1aBYeCcJExbpROVopC7q4lQDdAc1j1t27wK2wPWnBJLfLK4x1FDSBwQV1C7Tuu5tC5XiyQRgVH9YxbdwWcxtuQDiqsL8acRBHvpHTvB128qXQV4C2k3KqjQyTpHbcgJFBNWX7P2c8HfWU8xUnYsNiaxt5cXEBYpC0iINyByohp13qcsafWC8VsvJCTmgxlp2mEJLCW3cqV4sDJK70ydHFpJJwkqFO/wq3Y34hSURoxJ6tVDUbjNpcY2YqxOPdQaJto8g0yTN7O3PxE4FbfsffS3kpEsSpwEYKnOff61iOzozdv6sa9J0OIB0CjG/TrVs4pmq7TuyWVmF6jes0uc1sdXuo7W2gEqBwy4wRmgK3Mf1GRhAmeI/CiPR1YG1ApQSxxk94uQetXLa4jFyioShJ2YnaqEAM8oUxhsnHDnGa0VlZ2cbccmI5I9uEuGokaydF26i+t2TQXJiVSNiDnNZvsPf/VGvdMkzxxSZQ42xy/pWoe1tnuElA4WQZPC2Bj1FZC/vksO2sFzbbR3K8DZGxNZmDRqbuI3Ylt7icFZEI4fZ51n+ys31LUe4ccIY8BHlvj9R+dH45JL+Ve/dkA9lgu3zrN61a/s3WC3EzI+JCeWx2PyODQRI2OpRMYRNGMywsHX4cx8qo6o/wBWu7LUo/3ZxHL/AJW5H4UTsZvrNnHIeZGGHryNVFt1mtbrT5eQzw5/CeXyNIkKA55cqWhXZ26aaw7qb9/bsYn+HI/KizuznJx8KBHCuO9Ru+I2ZSMiuhdnjDMnCT0oAlGAMV23QLn3UmQFLMQAPOojcRAZ4xj0oCrOImWM8UsaH0G1QrNFw8PAZX67U+0dDnHCzkk557Uk7mBy6LHk899/lQNLdFSfd8933Y8qjZHZMIN2IUe81ZW8LBxKOLI2HSprBo5L62iTOFBkb30paRTk4qwu3Bp+mn8MSfpXkEkEup6jLNJkKzFiT0FemdrZyLLuI88chxgVl5bH6nZl324RljSelxRv/Hv24uT7ZntXvI9OtcIACBhR5etefXZmu5GklkZVJzwjmfeaO6zM13dM7eznYUOEDzMEjXiJ6VMnSo+jwwUFbAc1pbjLOnF6sc0Q0vsZ+1WR7mP6vbZyRjxOPd0FanSOzkcbLcXvjkG6p0Wid/draQs5YKBWVOf9FSy3qA+2i0vs1pwitIY4UUbJGACxrP6prdzfZRMQxHoOfzofc3Ml1IZJCcdAajqk1FVEIYUvlLbGInDuHcH0Y1ZivZYiMhHA/EoqsTvUTSgvwLu3pUmjSfZorftDKQF7lc+hNEYtROO8nIVQM48qzcDJaxccxANDL/UXujwr4Y/Lzqk/sx9mL6QX1/tFJdgwWzFIeRIO7UDjHLNVxzqxFzFTKTZtGCiqQf0y6W3hA5dafqOrMbchSaD8VVrqXLcI5ChOiVjTdh/sDiG91Isd3YGtlNdKi5LAAc6wGlXH1XUJQDjvI1au17V3dO5ibA+8aqPmzCeHnOy72i7TnxQWTY6Fx/KsVNK8shZ2JJ6k05znc1GRSlJs7MeOONUhVr0/6OLgd9IpO81urfFCQf1FeYxqa2vYW6EFzbEn2ZTEf8rj+oFZsx9bHljPVC9NaUAbmqs0/DmqplZzUOR5UcV7L5n8qa0rGqyU9mCKWdgqruWY4AHqaE2+gcYx7HiZgdxmlN5Gvt7VmNS7aaTa8SWhl1GYbYtl8APq52+Wazf/AEw1eWck2FgICf3ZZ2bHq3L8q09uXkSqXg9Ga6iLeE86sI5IyDtWb0XtJp12FiukNhMdsS7xk+jD+eK1CxBEBGCpGQwOQfcalwkuyXkh0cJCOYpe9HWmNTDSsaSZIz1GxptcaVlKJxqObOMinlgoyTVaS7IyqKCD1IoLin4Kl7p1rqKYuoVkxybkw9xG9CJdL1WwbOl3vfwjlb3fix7n5/OjkcpBO1Sd+OoNKjW2gDB2hltX7vV7WaxOcd43jiP/ABDl8aPw3qTRB42V1O4ZTkGkZ45FIYAqdiCMg15l9KTRdl9Pgv8AQ2a0uppeDgRjwHbJPDyBq4RcnQmk/BoPpSuYn7KSLPwhhKhh8+PPT4V5bEwyDQGPX9R1zUUOtXUk+3CjMMKhPoNqJxziJjFMOF1ODWs1VJHb6VcE0wuu4zSg71BBMrLzqYb7ipOksq21SK1VAxFSK1AqLsb1cgahqNVy3fcVSJaCsLcqtIaHxNvzq3G+a0MJIuR5V1eMlXU5BFemdjO1C3SrZ3rATjZSfvV5hG29ThnUrJExWRDkEU0zj9T6eOePGR75wK245025i47aRPNSKzvYbtAusWISUgXMQww8/WtT0qkfKZscsM3CXgqaa5ewhLe1wgH3jarFVbBO6WWLOeGQ49x3/rVljhSaT7M32ZLVnzpV83WW64R8MUdufs9M4fww4/Ks9e+OysI+st0WPzrR6oP7NIvmAv502bz6RYhHDBGPJR+lYjUH7y8nbzY1t5SEhY9AKwF2+Fkc+pporAtlO0TvS2OckmPzxXpcaiONEHJQBWB7PwiS9sY8fe4z8N69AokP1Dt0Cu00pj0iXHNsLWBatj2ykxZwx/ibJrHOPWqgjTAqiQyVCw5edSyb1E1Wb9CRyNDIHUAkdDRu3EusaTItx4Io2GSvMn0oCwzWq7N76DcDyl/lSZE3StGc1LT7aM2tvEg45nAJbJPCOdRavp0KRM6IFx5bUQtz9a1i4m27u3HdL7zzp+pjit3yKpMtNpmKcYTJ5Yq92TQfXJG6spqhdk8AXqxxRzsxGFveED7hFJ9Dm9F7Xhtb+maqWh8fPfBq92gGO595qjaZ7wbdDSj0RHosAkoPtBy8hTcf+J+QpVzwKO7HL0pD/u/0pjIXH2i/aeflTX5fvf0p7HxL9n+lI2f8P8xQSyEjp3n6VEo2P2vX0qZif8MfMVEnEcnuxz8xVCGEYO8p/KhV+PG4Bz60XPFn2APjQy9Hil2waYmTaRtJOOvCKvLzqnpYxJJ5lav8PhpCZCRiUU/kxpWA2NIfapiOkHhPuoNaY/aTZ8qMv7NB7Zf+ss++mI3PZa40+0Ekt64Eo9nIzVbtbrMepcEdup7pDnJ60FbluahmyV+NLirsDgN+VcSPKlIIUedMzmrEVNV3g9MirTZIWq1+Mw4PLNWlzgY8qBA/Wx/1ZKSeWKE6ZwmNvtGHxozq/wD2fNjnirGl9m7k6Qt3HJG7MOLu/T30vJSVgs8I+8/xJpqsiyHLMdvM1stRsvrWh2RtVUyghRj86zN/ay2d68MjRs6gZKkkU07G40V8ofvN8zRTTdDm1C1eWCRdtgpfc0NAYnI4fzqe2kmSQd3IIiduLJGKYkSw6dcEyhY5Mw+2MnavdLId9osAzjitV3+ArzTSLS470XH7QhuCV4XCjPEPWvT9Px+zoAOXc1hkfRlmVUzDyIFn2JPPOQKgl61ZuWX6yeAY5+tUZ5Tx8KDxetaoARqjst6gXqBnFFRgAVEk3EGYhRg4qvHeM80yBARGMgg86rsfZcAYzQBBkmQCry2puLqSBrWVpYsEljhCPL30PsHa7aHCsj94Ng3CfgaPPDqBZns4RFMPC5lbJYdDnlUM3xPVA7WdIt7a0TukZJM8XLiJ9PSqp0GZLJbriQgbsjZXArQ2Nk4uEuLiJe9Iw4yTg+dEpVZtg3hbb1HqKnm1o29xrSA1npEMMXHOITEcOqMchT7zVeLRonu2eMNwsc8RAI+GKt3GkXPBJ3d0JgRsk6Bhn+VEbGOSKyijmChgNwgwBSbFyrpgR1vbFu7iaPvHOBgY2/rVtzJeRrG86K0ftLwnPvJqWabiu3dfrUUyqY0IQNGM/epkLT29iFuyk0+ctLHkBvXegFbe0TLGIUwkjFfM53NMaQBsMwBPn1qKS6RSFyWH8NMjkFwCrR7edNG6VAeyHcdsdQUZAnt0k+IOK0izusZRSOE+lZq++w7YabIDhZoXiPw3FaWVIRArpIS/VTTYtdMoXNu0hLRysjH5VWNqZPs7wxSrjYHnV0SBj4SCPfTGWPveI+2BnJ8qRoVLbTbe2kZoYIlU7kBcUP7Qhla3aG3MyK/2ihN8eYNELy7jWFiytxruAORqhb6jJfKeAOsibnuxnan2FWgdqsrpFEltE/dMM8Yzt6GnaO08CMwZBEeakZNXRO00joqnbZi3Sq9ykkKnuELseZBxij9CX0xBr6xhu8jcuDgcOymqUuuXV06okYUA5wmcmhty8vFwy5554TUcM8sLlonKE7bVSgvBooo2KXF34FaONmOC3CccI+NJqt9HapwjgMzDIDfzrKLqNxGkgR/E/NyMt86qjjmkwSzP1PU1Ht72Z+3s0+na7HeSi2vIFiYjwtzUmiC6raRu0UkwDIcZxgVilChhxZGOo50ud8gmq9pFe2jem8h4VKMH4+XBuTTkkZ1LNGYwDycZzWPs5gs8fcQKXHUnnWqF6yGNJouGRjjAbOKylGuiJRroUTMZMEHB5AbVaQcSgYwPLOaRlDnDAb1WuYjaXQS4EkfEOJWGwxU9kFgQjiLZ8R5HyqGJmFyY1lB8/Wh97qMsDgRsgj/j3Y11ndRwos1xBGnE3hkX2vlVKLSKqkHu6fjQcDZc4HTNT/VZIbkIULwSDBbqhqfgF3acHeIyMAQ43PvxT7WdXdoCT3sQHFkcx50JGNsF63piS2JjgEPfY3aQeI+6spZaLc3acfAqQIcNJjJHw616HEj4bv2VyScYGMCuggigH2MapnyGM1SlRUcjiqMnJ2OaFFmiuRNHjLKyYzWKdGilkRQMeIf5RmvWtWluI7NzbhWwN1wSWryiQl7idWVkYuS45Y9KE2+zDM5NW2ed6iYVuXCOQQ5BJY+dQqsDffPF/nNEdTldLuZTEwjDnHliqEoPhdbdwOYIA3qjlZC3Bx8KzHhP8dL3UR/vm/11MbkPtIjn3rUD8BORE4/4aCT3HsDHazdhOxtpZMZLyTSrUyHPhQdyuc1qrnTrWzCmW9jDDmrjasH9El1c23YPQHhujw/UYPARsPs15+dabWNUhumUXPcBsYIHM++uejvhGVLeiaK4e2uTLEyluhxkEUl7eTXcgeYgsBgYGKp28vesRGv2QGzefuqfFBukuxmSafHIEdWwrEHODvT5oTGELFTxDOAc499Vn4IgzswVRzY0BaLl1ePcfvCoHkBjFUy6gZJG1VEvopuMRSJIy9OVUppkMwDYUt0Jq1GxJovvdQmQYIY45Y3qO4ve7jLJEXC9M71VVczxoc94GyAoySKIzwCRsOjRk+Y500kh34Kdhci+DSKpjwcYJq9xcODkmhF5Klk3chBHJnZ8ZBolBGZk4jMXQjmBikyU/BbQh1OCCPQ1BeicrH9WRSc+LJ6UlnaRWrMsRc8W54jkVHc30S3H1cq7ZGGZeS0h3rZ015HayIk5UcXI5q3b3SnLROoHnQb9iGeU+KSRRsvp76swaEbeVTLMe6UeznrQTbCBQOwYnbnt1qDUr2+W4i7t3kjA3XGxqwoCqAvLpS9KBuKY4XMlxGrOvAfwnpVTU2K2M+2xRv0qfhAGB1odrdqsti7l3HdqSADsdqED0tHnHZhP7ST5sa9L0QfbIMda887OR/bZ5HJr0jRFHfR+dWzgmHu1RUNZB/YCkkedArmSB1+yQp6ZyDRntecS2YaNmTg3YdKzjY4vCAB76cNo68H4k1owWTLPwr54zV2IzzXHd2oEvqoobnepIJ5YJeKJ2U+hxVNGzvwH7q2ubSLjk5NsQpyazfaROKxjuuE8Vu4cVZluZJZeJ3ZvRmzU0lpeahZyJHbu8bqRlVqHGiJL402a3Te0llf6ZGXjCqyA8HrQPtcY7yyE0MS/YnDkbeA7H+tD/o9jhmsri0uhIbi2kKlTtgVqTp8SLMijjWVSpUnkDWejmUYrpAnsXPI0DQTD7VSRseo2P8jRjU1khkjuYwMjwPn8J/51jdMmfTNYEcmxB4GHmy/1U/lW8dVmhK80dfyNAgDGZ9O15JZx9lffZsByDjka0mT8aDX8D32jSRL/ALVAcqeoZdwfjU9leve6VFcwEK5XxDGcMOYoH2y2USOVpBKEB3ZfOpTMywmSLhY4yM8qoWEDSytcXSAqOQbYGpbm3juWLQsI18l5E0DaV0Nmeae2aV1QA9AcGoLCJZnJbcDpnnT/AKq5KLNcx90OZDezU4gt1YfVJMuu/Fnb40DulSJpbhYCqGIhT15Cq91bwuC0cjK3MDc5q2IjOVZpQ0ancAbVaYLgcBIx0xSM+VPRmQJUbLI/xFFNEx+1hvuYSceW4q4Y3kVlZuIHbA2qnEjWeowswXPdONqJO0OU+UWi5LGLrU2dt1iGPjWb7fzi30zu19uU4rXWsRjtgze0/iasTrtlPr2uiCH9zFsW6DzNK0rkzT0kl7icnpGAs9Nn1C4EUQJJ5kdB51pbDQoNLTC5eT7zuckmtmmm2+mWogtUA/E55saBapKkQYuwAFZ8W9s9aHqpZ38egZcycKnyrC6xem+vTGh+xjPzNXO0eu8fFBbHY7EigluvDHvzO5ok60j1MOPirZPmkNNzUVxMIkznfpWZsJcykEIntGmJJHaLn2pDVPvW3Odz1pnM55miwoknuJJ2y5+HlTBTetLSHRIp3qxFVVTg1Nx4FAMneThQnrVTJ60rPxHflTffQNE17MyTWkqn2oeE+8H/AJ1SkcuxJNLqD/YQH8EmPgw/rUfPemKCo7GaUR70o5VIhpFicGBv0opoNx3N0V/xFwP8w3H50PrlYxsGBwQcg0iZrlHiz2W3f63bxTpusihhUrBIYy8rKiKMlmOAK8m0P6RpNMaXQUsjPfBy8Du3DGqHffqcHOwqZ5tQ1m4D6pdPcb5EajhjX3KP1OaccKe2zw8k5Rbj9Gzve1MYDJpcXfsNu9fZB/M0CuBNqzA6vO9wgOVgHhiH/COfxzUsFiVQDZasRWgH3ia6IwS6MHPyMSC3ACpGoA5DFR3EbgYgTc+lEkhVemTTzgVVV0RzBFtpTO/HdNn+EUbtpJrCPhsZmhU7mPHEh96n+WKizimM1CiS5cuwlF2k7rbUrZ0Uc5oAZE+K+0Pzo1a3MF5CJbSeOeI/ejYN8/L41kC2BtVKZYFl77geKb/FiJR/mN6zliTKjJro35rqwkOv3tuw4L5bhR9y5QZ/1DBq/B2zhXIvLWRWA2MThgfnisngl4Nlk1s1TqpG4oRdadBdM3emXiGwZZGGPkaz2o/SHpdoFN8lxbRMcBiA2fgN6msO2fZ2/wAC31e2DHpI3dn86TwTRvjlasgu9H12zuO807U5poP8ORgWHz2P5UF17tlrmhQd7PYW1zGpCv3iNGy55HY4x61vYLuOYZguIpV80cMPyNDe1F9YWekXL6ssTwvGyd2/OTI5CphCakkbe5GSpqzCQ/SrcyRZOhwB+hNywX5Yz+dZLtVrl52nnik1ARLHFnu4ogQq5677k0MUAoOlKm21W5vaR2w9Pjh8ktlYxBFwAAKlW+KEfWYRPGBjIOHA/nUlyPACBVcDakipxUgzY/V7pOPT5845xtzFXo3aPwuMVjLi3dJBPbMY5l3BG1anStRTU7Tx4W4TaReufOqaXaMYznjdS2i/x+tKGqmSVbBqZX2qTrRejbNWImwaoQvvzq0hpoTCkMmcVcifehcTZxVuMkYq0zOSCkbVajah0Lbc6txtyqjCSDHZjUG0rXYpAfs3OGFe3wyLLEkiHKsMivnyXJVXX2lOa9i7B6h9e0KLibLp4TT8nhfy+G4rKg9gC4Y53YDam3bcFtK3kpP5VBJMRrUcXQwM35iu1huHTLk/wGqaPES2jOIveXuhwnoDIf1rQanuYV/FIo/Og1ovH2ltlA2hthn5UbvBxXlov8Rb5Cg1n2kJqj8FhO38JrAaicWxHViFrb9oX4dNYfiIFYi7w88CdOLiPwqom3p1oNdk4eLUnfpFFj4mtcaz3Y6L+zXM345MD3CtCaTMsruTMl2ykzcwx/hUmsy1GO0sveatNvsuFoM5q49HVjVRSInzn0qFsdKlZscxUbHFWaEZrQaTdLadl9RmY+w23qcbVnpGCrkkBRzJpv1+OeBLFXzC0vfSld/Co5UmrJcXIM6NbNDpyd4PtJcyMfU0uoD+zuCd8GqT67Gu0UDkdMnH6VVutaR4XDwldvOmospRd2AgveXf8MY/OtB2ZGdTVQOan9KEWUB+r8ZPikPEaPdl48avCDzwf0qZNBPpk3aNMd0D5mh1rtIoFGO1S8LoP4qD2hxMuPOiPREPxJQQEH2nT0phO/739KlBIA8H5imNxfgHzFMZDIRxL9rnf0ppxy70/MU9ycqeAA586aS2/gHzpgRHhP8Ae/mKiXByDIefmKm3AwEHzqJeIFvCOfnTRIhKnbvW+dDbzZpcHIxzomWf8I+dDNQ2Z8gZ4aYmWNN3lb/JREDwUL0g5mOPwUVwcGkSMAyM4pjbNUkY8POmEePeqAR91NB4QRqYGKLvuDk0HXbU4sHY00IJyHBFMk5DNOmIyM1G2+KBD2OF9aijI6nJpxILHB3xTYwcb0wIL1WMJCqWboAKMW+k3jRI5j4dgcE70Omnlto2mgPDIBsccqL2GrzyIhup/AVBbA3balsca8lt9NtNR0h0kVIpCCpYHGDVHsnDLpKSwzyGSNjsFJIFEkit7+1dY7F+6O3HxYJNUdIju4Ze5kVonVsLxb5WkjogkSaii2jG4012jds5Xcj5UIGgX7sLp4+84vFwl9z8K2zoe78SrIflQe8a4ilK986g/dDbCmneh8FIgOk2Go2ZaGIwXCjBUEghh0IoHf6V9U0+K4l4hI7EcG/KikMbxyNIZGaRjktmrL2VrcYfUb0kDknFsKdUKWPVlPsuiLEJHhlCgbOoODXruksJNNtSBs0RrzjR7d7J50t45ZbNt0Y7b/zr0bQzxaZZnh4fARjy3rHLs5fUfijH3oUXbhU4MGg9y39sKE8Ixzo3qRJvZMDADGgtyhN6rcJK43ONq1iQilFKY0cLjcnnvUdo3FdXBbmUB2qaCAS8ZcHh4jjh6imxwEXc2ATGU4Qasov6YwR0ZjgBwdq1hR723ZBK6pnwyA+L44rG6c/1coshbIYEHFbCxguY7ySTI+rvvlgOL8uVZTNYdMu26OkQWUqWG3hGBipcelI2eE8IyegPWkEgwS3hA5k7Csyh1NZdjjGT50ruqRlyfCBnIqldXMX1eOZ3EaMMji50JDirZOIwhLMSSdqo3cXETwggjkCdqY148caMoJDnHCeZFWZNNuLjgcShV58JquuzW+G5MrrCZcKVDnyVaka2ZFGw2+6vOiUNqbeI+N+I9RvVVpJraUnDFSebDnRyEsnJ/EyXacmG90e5A9i5Cn3MMUbkZgrFVywOAB1rDdvu0jS3jWMEAUxSK5lY/eG+woIPpA1W3u1+sJbzQE4ZODhOPQijmujXlW2ekzM0Dh2CM55KMiplmygcAYJwQf5U+GQSwxuo8LqGA57EU/AwNuXKqNCvMsR4luDxKdwzch6VlNQura3lEth30Tgnxch8K1k4LBlbAjAyTw5NZLtdFdiGCK0lhMrniW2ETO8oHTbkPWnFW6E3Q3TtYVoXLI7uWJJzzNSSagY041UNI/TOyisZDdSwylv3JJ3iPIHyrQWpaREd4mPUhaFVihJS7G3NzNK3FKc+QIqrneiF5cvOMIgijQbCqLMXOT+laI2TJwIO4PjYPjkFz+dU0Y95jrVu27rfvCV9Rv8AlUd5BEZQ0LuD14xil5J8iYKnDfKkOOlIniwKP2/ZPVZoVkWFFDDIDOAabaXY3NR7KVpqktpCI4UiGOZZASaIW+uLDbkkyyTNuQ2AM1FB2Z1KSSSPulSVBngdsFh5joaN9n9Fsnt5I9TsbiOdTwl3JCn3VEuJnLJCvsz97rVxclCoEQXopzmtd2Nv4L+A210klxcqN3lXiAXyB6UBv+zgjv5YYZT3fDxRlxsf4c0R0HSNVspENtcxwmUZcFeIAVMuLjSJy8JQoM3PZ1G1KOe1kEUH30I4t/TNWDBbmcLJAS8W6v3ZAz6Gp769k021Et0omQe08eFP+k1FqOrR2sUD4ncT44ECEVkrOWLk6J1ZHO2CV/KoLsFZEMOC+d1BxxfGqv124aZVe2Zlc44VO6+pzTJpWbwDIUH41aRqsdly5kkaCX6uF7xf4/51NBIJIVfBBI3BqhEzwrxcLBT0I2NJPeO8g4RjhGxNFD9u+i7K6SQsOPh6E+VeV6tFwateD7qOdz96t/POpbjkYKOtYLXuP9uTni404iQPhTSoyzw4xMBrcc73s2WjALZAYHNDW76JRnuyvpmifaEAXkvjPebH2j+lCxDxjLTuPQNTONiFZ3AIEfpkmuL3CbFY/ma50aLHDOzehI2pywswBM7flQSep/RxE47D9neJWAOnWxBB2P2S8xWk7iAN3zRKG/FjehH0d/8A4Admf/6Xa/8Awlolq8jJCvd3SQEnG/Wuc9SOoosQywy57p1OOeKIJBCLKSaaRg3JEQZ39fSqNtFG8SeISDG7c81fnlbSz37xNMVGVCYwffQKT0LY6ZJKqpc3dol0wysStk49fKiC6Mqs9s8Ed13qHErDMae8UC1BLvtBZRax9WtkS3Y8cSkiRlHPLVbve0mmX+lRwd3e2mSP3fhCj39RTo5HOb0Bdf7KW2h6Sbie8lN0x8Kxp4CfLNZfT4prqfw4cr0Y9PSvTbtre10+IaW9tfxHmLqQyEe4VjdTse5DXcSrFIx9mIYVT6elOLKx21bFa3mljCW57uZTjjB3FX+zgvra+kF4I50kwp7w54fUVS7PPLI8jSo5ZjjjA291GyMb9aZvSltl3XLXhuB9jbtEN0IHiz60DZZ2uH7qR4/4XUcPwopCklxKqLksaOi2Xg7mZIHbHNNjS6D8VQDtrCd7dZHdOHkWJxUtppsEhYg58XiwOZrRWmnQRgEsnuO9Wr1bWFAr8MZbkQMVNmTzbpAO5WK0t+FAoOOQoBLJxseI0Tv7c96VEi5O4yaFXULKMMpPuNUjeCSO2HKkzvUPfhWCsvD8af3ilTgg4qqLJKmn01r3SbgRbuUIqrFJxDJ68qL6TepbcQlICHqaRnN60eVaVZSWd20M68Lqa3Wh4+sRAelUO1vcR6yGRhmTlgZzVjRb+1ivYopZkWXyYEVXaOGfZqO06h5YAcexWZuESM4U7+VaTtBKkk8JjdWHBzBzWfuYWYlwc46UQO3B+KK670oGTgdaj38qliidxkCtWbMntLd5LuOLhHEWGzcq3ttbXMiBBOsSKMYjXFZawnwqxyRIwP3iMMPjV641S10RUMO7zNgksTvWMrlo5s1vSKM1q2iduYmduG21FCpPTjFayXuyQIR05+tZHtpfLqOjLOmFubRxMm++3MUX0zV7a9t4ZVfaRA2PWopmUYS8mf7aWksM8d5GOFmIGV/Gu6n4jIovpGqGXTk7tGmKr7Snodx/T4Va1W3XULCe0AOSMqeoPQ1juyl7JYSz2jIRLxFcHoCf5H9aaVl1TNTp17Kb5xIDiUYG3I9MmqcM7aLqd5ZtIojuFNxBxDA4vvLV/TEDQzJkCbORkbjFJqlk17aR3GzzwvxqCOQ6rR5CSpj9Nu4pbB2kmUvuSkjbD4VJYX8V9bupRI+HYAthT7qqWGlcUyvsqtufQVNPYRWbPm3jmVuWfL3U6QaB2prPZSK0sQMLffU5BqvbXU1xNIsblYscs86i1BO5kLDiMJO0ZY4FR6TZy3c5MHCcfd4sVXgq2ns1ehuzW4iWYqyNllxniFGRxOfIUB0qZ7Ed1doELHmRy+NGHVZUzxcStvlWqGjGa2SqMNgHG+ajmiWTUbRGJOzGuQBAFBY/5jvT9OZZtTcg5EUePcSazl0Zy0rCNwhaMqmxOw9KrWdjHaRFYxud2bqTV8kAZNYrtf2zg0wPb2hEtxyODstVGNk+nxZMz4QRb7T6hbadavJPIqnGwzua8W7Qa9NfysFJWLOwHWm6zqdxqM7S3UrOx5ZPKgM7b7UpyS1E+t9F6NYI72x0I4pOI71bBqtAMLUhfFYHeyV5Aqkmh8rmRyTT5pOPYcqhpAjsUlKaSkMXFdSV2cUCFFd1pDXUAKNufKk7xPOq8845A7VXEnEedAF+aL6zBJEDuw8PvHKobbLxAsMN1FLbuQ3OpGZUnI2Ak3Hv6imHTO4aVRg0pNLGjyHEa58z0HxpBKSStikim7ueFQWPkBmpkexhP2jyXsw/ubb2R/mc7D4VHcz3l6BCgjsbc7d1bbs3+Z+fyq1jk+zhyfyEI6hsEQaW972us5bYZkiUrN/CvTJr1CxtEtowBu3U0P0Szg06yWKFFUndsdTRISitoY62zyc+d5Zciyq551IABVdZQKUz1pRhZPxU1mFV2mFRtN60UBYZxUTS+tVnm9aryz4HOihlxpvWoXl9aHPcE8jURmc9TRQ7LF1JGRhkUn3UC1i9tNNtWnuCF/Co5sfIVB2g1yDSIGeU8c2MrGDv8fKsB9YuNZvTeXrEqPYTooolUFbOr02J5pfo7UWm1O6W6vMheMBIxyVaupHHGvCiKB7qiuziAkdCD+dTZ3rinJzds92CUFURBEinKqFPmvh/SpCrOBxO745cblsfOk61ct08O9TbL12UhttSjnVm6h24l6VU60yWyV14rd/Mb1TQZOKIwDiDDzFUFXhkYeRpiZxSoFjeC+gmhcxsWCsehB86uGmSpxxkDmNxTTozyR5RaDEnGHYSKVkXZl/mKQMcbUYuYBe2cE8WFmKAgnkduRoK6lXZSpVx7SHpVSjWzD0nqlP4S7HrIw6mrttdZwH2odTlODUHoVZprVg4BBq4n5VmbS5aFweY6itBazLMgZTsapMykmghE21Wo25VRjNWo2q0YyLucofdW4+ia8ImntyduYrCcQCEmtP9Fz8GrSyE4RVJJoZw+ujy9PKz0tD3vaeYjdYbcKfexz/KpdeP/Vrr+Mhfmai0FOOOe8YDjupOMf5Rsv8A8+tO1w5W1T8Uy1rLs+VXaB+igP2i1FxyRQgotL4tUiH4Y2b+VDOyo431Cbq8xGfdRKPxanO34EC/zpPsqf5A/tO+IIk82zWPlb+1yN0jTHxNantK2Z4k8lzWVjXvGbH97Jj4CritHRh1E2/ZuHudHgU8yOI/GiROAT5VFZp3drEnkopL5+7s5n8kNQcz3I8+vn47uZ8+05P51Tk99TODzO5qF/KtjvRA3vpjeYFSNjNM91NDILiJZo2jbPCeeKK9jdKti1/K0fH3aKo4t9zQ5tq0HYbxWOqserj8qUuicjaiOeNckBQB6DFZ/tQqmGKBQOOVueOQFaRtmNZqcfW9TuZ8ExwL3a48+tERwKNv4YUHPAwKM9l/+3LbPUn9KDLsmBRXsqca9ab58VRIc+mEe2A4Zl/zUCtsd8nvrQ9txiVf81Zu3OJkx51UOiMf4lrK8P7w/Omkr/iH51IC+NlHM9aaS4+6PnTKK7lcr9oefnTSV/GfnUsnESuw5+dNYv8AhHzpgyIlfxn51EpTL5c8/OrBL9FX51COPifZefnTJI2ZM+2fnQrUyO8JBOOGi548nIX5mhepD7TxY3WmxC6JvP8A8FGj7NBdE2uF/wAtGn5HFAmRLsOdc27ZqNThdz1qQEEUyRknsNmggP8A1jD1GaNz/u291AF8N5A38dMQYnHI9aYNzv0qSY5XaotgDimAiblsU9eVMg+8elOXb+lAEi6fLqLdxABxEbk8gKIQ2UWlXMSaj9qgXYpyJ91B7m5kgjLQu0b45qcVZ01JLm3hlmYscAksc5ooqKvSNUsRnthJp0z26tyHCCPkaklRY7T+0yGSRRgyYwSfhQiOVkUIjFR0UVYjsXZlmuCVTmST0pcaOpRontVunh4zKUTpnc0NkJZ2JYk+ZrQMqyWpEbELjYihlnaxywSl/bGRz5UJlJg5H4gfCcimvF3yqccjncURt7Sxmj4eJkk65anw2Y+tCJmHDjII61Vh/YPiivZLlCL9hv8AfOAPgK9S7O5/ZVqGbiI4gT51hILRo7piFDhOWdq3PZpi2mQll4TxsCKxyu0cXqkqVGd1tCL1gQcZO4oFfCab7OLwqfac/wAq0+vbXLe+strMnBb4BOSelaQ2ZIZbWkduPACW6saS5t1mGR4ZByYcxS26lIFDOxY7k86dIOJCveMueoFPyMpWr3ZdobhT6PjlW3E5mVY7e7jDIv2mVORisdHMvdSRd6XdRsWGCa1ttG9zp1rFhIWlXJPBkkVMzaBcWWVrRJoh3j/gU7EVQvb+eCVm7maOFwAXZclT6A7VaNkbOEvFEXMZBUKTkjrWf1G9knmcIZY4m5xsxNTHZrBKT0XtO1aQ4gdo1UA/aNsf6U291JHtQo4JyDgiQfnigmafFBJMjNGrNjmBVUdHBLZfivpzE6rwFuHwYOy0SsO0YcrbhWeRVwWYe0fdWZOVcq2VI/Kr0JW3j7xcZxuV60mEoJ9mkmv5ZSoIKHnj+tc9/MQuSox6UDjvldVVCIc+07HJq1nK8Uzo0bDC7EZ9aVE8IrwecduLbGvTu2wbDbVj9WgQMSMjrzrddud75GCgDgA2Oc4rG6oMxg+YrzM82snZ6GKEHj6PYOzlwJez9hKzc4V95xtRQ9OnvFY7sPeRS9lraNlVmTiQnkRvRczyxS8cbM+2ME5r0YSuKZyN06Lt7K6YaOUKOqhhQW4dp3USOWZM8J6jPrSShzIXI8ROcc66IFnyAOIc87VQUBb7QAxDWvCj5zhuVGLSxVIMBmEhXBbp8KtNLwAB1GfSmkyBS6EKvM8XKgzSozWrFbESGTiKpzbOfyrJdpNaYhbe3n8GOJmB6eVabtXePFZTzBAWI4RgbE15dHaT3FwwaKTC7vhTkV040qtk5puuKN/oOoR3cMfEMsoGQTjNGb6a2EYKswAPNiABXmw1OS1n4bYlAo4QSOVGNP1SC7uo1kZXEyN3yN0ZeWKmSpihmVUzUqwyCp9QRV4aleSOvfXU7ICNi55V572d1OSO7lTd4GfhHpvXoFvY3EgRljLIx5rvStG2PJHIjd2l/cXsVuIwEt9hwRnBYf5jVue4bLxlCFPNS2cfGqdlbiK3WOCQRAblSTgn0qZ0lkMYtpYTg+PvM8R9xrHyQ0k+hYbcMVZ43PCcqcZ3qee5cyqB3sRQ7jbxUzgYFolkLOTkb5ro2W2ldbmHjYjz5UCe2WjboUZrlXPXMhyR7vKkm1GKWNoMOXUApJjYH+tSNdxraoSquc7qSQaHkJJMxiQovlzxUpX2Zxhf5I6a5lkbCiZwBvIWC4+HM1JD9XFt9oXVVOO9k5uaikAjcbcS+Y6n1HSo72WSdAryQ2tmo8chGTnpsao0a+ieK/WaEwtxiIHGSu+KiYxB27vJXzau0+0M2ki5Ba5l3wI/CG92ayt3qEkl19XMUsca7MgPiz600rKgottIP3NxaLbtMU77vPCscbe2R6Vg7+7jkvJGC91KW4O7JyV99aJtNhvJoDZhhHnDjJUD+lBO0lmkGrNHGjK3CrcXu602jL1EUomG7SdzHfsCvECoJJXO/voJI1vw+FMHzC0e7RlzdjukDJw9Wxn+tBEMsSYEI4f81I89kSrakeJcnzINcRZg8v1qR5JJE8MBI99cryBcfVz86CT2n6NoA/YPssskgiVtLtTxN0HdLR7WLbSmSNraRriQNwEFcrv+lTfRwLVfop7Irc8IjfSLTfHXuUo7p8OnvD9XtyJApyS43Nc9nV7jaTKFhoNvYWLNNLxpji4kPsihIe51ZLmHQhCURgC0rAP7xWsOm2O8MqKwkzwozH8qs2FjbWEQitokjT0G/wA6LM3kfg80/Y3aIyvBJFctFkGQK2FYfzra3OmRXEtr9egiTTrZBwIN+Jv4vICtDVF9PhXvGBYK5yyg7E0XZPLk9iCayiiyIolixjIQYqg2lwaiGdlaDH3olHA4+NWWUAABMKBgDFNkec2sqwJJxEYBFBfGtpmfRE0+7dbPgOTgELzohxEOv1+ANIR4VjXJNdNojtbAm4CSEZYBc4odb6JHb6iJZ5p5pSMqY8gj4Uzbkn0T6pHb2qq8YaORuWDS6Vb8Qa4mMvoc86LvDYuE+u4YnYBxhjU8Js4EKLlY+i+VFieR1SRWtu6dlki8YJ5+dS6iIrxVWaM5XlvyqlqV5b28WbfwgdBQOLtIGnbZnjX2iByp0w427CVzZxoMqgOOpoNeyufCADRj6/BdwFoXBUjfzFYfW57mG6UxEtGTlSN804o0UmidwQSWBpjgsCASMjpTjJLKq94RjHIUmM1uv2bra2B5b27064i7xi9uTjejGvXZk7PXDQnhbgyGqvqFot3b92SAeYPlVK/jkt9Cmid+LC4yPKnJJoylGkwRpdxPqTxSTzScSDAwRWu0rRYLrUIppJJuMfxDH6Vj+y64C16LoAzcx++spaOCTLmqWiWt33YYt4QQTsaA3swhuI4m4lMmy5POj3aw41HiD4KoNqyms97O9pKqluCTcKN6rGjtx2oJoIRMEYrKpx+lTd2eHit328s0rS7gPF4ueami4cZC8LHmBQ/s2sbaO4J4+frQjtJOPrFrEMsQ3FgbmjIljdiFZWZdjg8qoTaaZdUS7aTKryXFEWk7ZMla0dFaS3rd7e8ax/dhzsB61H2dLWxurFiQbeTwf5TuKJBGD8QkYjyND7v+yazb3OBwTr3Ln16VLdsTVbNDFfzovCrZGefWg2q95b63HqUMeRKOCRfMkc6JQrxEYFFbewSePhlUMOmRU9EzqiWwSR+6liiMblB3gzsT1omkBLFmGM7nFOs4O6iUeQxVmobOdsiSJUGANqp3+Apq7M4RCTyoLqM+c4NNFQ2wfLaQ3scne3EcSqeZO9dpFtb2dwyoVu+LYFTyoTf280r8WEwPKiHZfS7nj+tSIBBvgM2OI+6qfRUnT2E9XhkSLvAw4AdkLZIp+hTlEJaU4B8MYGSasNEtx3qS26hwMhlOc03MlrZqpiVW5KVO4pXqgu1xEuLq5ineThIRuQYVc7JXBuDqE8hGe9wfTAobcS3Kp3cxJB33FT9n8wWGrMBjfjHyqZK6IyRThQG7adrZkeS1s34FGxYczXl93OzszuSSeZNXdWmaS5kZjkljQa4POlN+EfTek9PDDBKKK88pOcVUO7VJIaYuC4rFnckWFHCoHWopCTtUrbDnURGakRHSYp5G1JipKGV1KRXUAJXV1KBQITFVrqYL4FO/WpLqbu0wvtGh6K0j4G+aOg7EbJOafGpq/FAiAZ3NOdFxyFIZDDtT5lWVCjdeWOYNNyF5VHcX8VnbSzvguBhAerVSTbpETlxVlNbu5ubyWztigaHAlmYZAPkB50TjtAyATu8uPxnb5cqH9m77T5EaFJOC44uKQPsWY8znrWhMRyNq6oQo+dz55ZJOyuECqFRQB5CiGnWwDd6w5cqiWIA70Si4QoA5VpRztk4cind8RUl3LbSpCLeDuWRMOS2eNvP0qmT5mmJMtpdDkTvUhl22NB5DvtTVndTjJNIYVabNNM1UBPTxKppMdk8k23OqsshanSFUQyTyJDGPvSNgUEvu01jalksojeTD77eFB/M0UxX4QW4DwNIxCRruzscAfGsvrPapIuKDSh3j8jOw2H+UfzoNqmpX2qP/AGuYlByiXZB8KoLB4z7qLS6KUG/yB+ol5i7Tuzs5HEzHc70UijCIFUYAqnqkXBalh0opGMopxzANc2a20ev/AB/TRVu0Jt5B6VJGcqvqBT5gCpUdRio4v3ae7FYnoeSaMcTVfjXxKuQAdsnpVOD2hyq2aRSJrqHundONH4TjiQ5B91C54+BvSiK8t6ZcxoxIQkr0JpiKtq3j+FQ3S8Fzno/609MxyAHpU13F3sXh2YbrQDKddyIpFbiUH8qU7YxTEajQ5S+nqh5xsU/pTNYRXVDgrL91x09PUVHorBZJ4/MB/wCVE3RWGGAI9a6sbTWzwM8XDI0jOOssShp4mVTydRlT/SuR1YeFgfca0oGBgcvKq9xaQOjEwxlueeGoeK+jpxfyE4KpbBC5x51asLtoHypyp5irBsrNkVgpjDDYq5FRvoqvvDdSofNgG/Op9po6F/JRemg/a3CSqCrCr8bAb52rJR2Oo25ypiuFHVDwt8jtVoXrEBJWMZG3Cw4TR12axz48nTDtzeBvs4znzNeh/RfYGbvMj7Mj7Q+Q8vjWS7F9kNQ16cOsTwWo5zyIQP8Ahzzr3PSdFttK0xbOzHCBuXPNj5moT5vXR5X8p62Cj7WN2yRsWLhkH9lc4IHJD5+6qeuyYuLQbbFpPkKLRQAQmOTDg8x0rMa5HLaOwlOYFhdYXJ6n7tdCS8Hg49yL/ZFOHSA55yOz1ds8M80g+/Ify2qPRk+r6Jb52xHxVPZLw20PmQWPx3pCk7kzN9pZMXEzfgTFCNJhL3ECEZIwPiaudo5A87rn95Jj4VP2fi47yI+ZLfCtfB0r4wNcBgYoZ2jk7vSZsc22onQHtdJi0iT8TZNZrswgrkjIP7qhfFTvVeTatTuRE1RHnV6OwlljV+OJQwyAzYNO/ZkuN5YP9R/pRY7Bsh4UJPQUf+j/AH0q+PVsNQbU7J7eylcyxHpgE9fhR7sHCYtKussrZGNvQ0Seicn4EWozi1tZ5mPsqSPfQqygMOkr3n7yTMj+81Prp7+7trFc/aPxv/lFWLzBiYYOAOlCHHoy0h4Sw9aI9lX/APvhsvV6iTSmmXvPrSIGJ2KnIq3o+nix1S3uXuUcRtxcKocmpl2VJ6YW7fbMP84rKW7/AG8e/wB4Vq+0zQ6tjhkaHBB8SZ/nQNNKhR1YXmcHOO6//wCqcdIzxuo0x/h8WWYbnqaYSn42+ZqUFxxY4ccR6mmt3nTh/OmUV5CmR4m5jqaRinm3zNPl4yB7PP1pCX/h/OqQmRkp+JvmahynG27fM1O3H/D+dRZcO3s/nTERMY882/OhuogGQY5YrQ2i/ZSSHHEDgUpJz0+VBDZkredoHjZBnbFW21OXlwj51oCdjy+VN4j50xWZz9oSY9hce+lXUpuQRcfGj0jHhbfBANJFIptICpbj4RxZ60CM/JqEzKRwL+dU5HYKjBTxBs4GTWqZzjc1Hxt0JpiAP16bH7rPvzWhXSbtuzh1Vu7C9I98kUzjb8Rqf9q3Zt2sTJ9gAGA686HfgDMjUJwNoOfoa4ahcjlb/kaOcbcuI/Oml2P3m+dMABNd3MqFTbkHz4TWk0SZms4UkXDBeeMVDxN+JvnScZA9o/OmVGTi7C/GsZDMcAc6szagLpV7lh3O24POs67MVYEk1ntKuJ4biWNJuFSTkYoNlms9Rnvo448RkMxHTkKFJM6iTuyMuMGhGn3wGI5SoH4qljtJdQ1AfVZwka+2VNFJFqarReAIAB51PDI8Th16VLc2qWoRRM0hI5sKi4dudNOzVO0WQb24mM0KBUxj2t63nZlj+yYeL2hIQc+dYaJmNt3VtIUuH5EDOK2nZSKSHSI455e9kExy+OdYZeji9VfEpdoB/aWrI6uA6n05Vse0I/tBrJ6nwoF4jgVcDGIg2jTfG1NLc/Hj4VU1OaSGKBonK1aUu0IbjOSueVXQxluyS8S8XFj8Q3rYcM8VqgtIlEgRVEjkkFfWsNpdzLMzpLg8P3utejQshs4A+4ZFwPhWeTTNI6ZTaSUuvFL4BzwN8+h6UN153vbkR28JYRDLMBv860NxZoIiwXcb4qrbku5HEqA8yABmpTvaN4yT+S8GMmikjbDoyn1FNDMAQGOPLNHtatXnm+xZSiD7xxQErjiGRkfHNaJnTF2iNvzpRK4xvkDoaf3LcIY4CnrmomwDjOaRQquqklkDVL9bbgxgZ6elVmpKKCkB+1bmWOFiBkAjNZG/HFbitj2jUGyU78QasfcDNufQ15PrFUzswP40E+wuoCFZLXhcs0mQQcgfCtgiXkUs0lw6NFzUBgCo8iKxPYmfuJL7CM7ABgFG/OtpC5kCSOjDIyUb+dd2B3jRx5I/JjNMku7tpZeFVtifCwb2qBa/2mXS9Sgt+5JRt3ZjyrU2snczLCsahHPEAByqle6PBqGpPJd28ThV4QZBnY+VdEGk9kU0qs6fVI5rRDEDkgEEcqqzdpLGwhEWpS4kO6gDiNCdUhPZuOclzJaYzCDzVvw+6s1oOiy6/qP1nVHkjtnPMc29B6VrGMat9ClLVRWwzpPaHVtR1R+OKKXTuI44oxgDpg+dFZosl2CKpbqBVnT20nSriWxs4jI8WC2TtRcXVvdKEI7vPMFc0pN30EPjE8N1JJPrUrOvNjvVFlOc17h2t7M2B0D6zAo48ZJFeMNFicjoGqk1M4ZLyaTsrZRu545RH3Sht+pPSt9aatNbKBAkSLjHhXn61leyKBbKeZ0Vu9fbIzsKJzaiszgRuQ/Ih0xUypM68NY4q/JrW1a5tjD9atyA6cS5OS3rR6zdriGN5cBnXPAF4ayVjJad3GL6RZcj7qnK+ma0FrqVuY0jhkUFhwji3IH8qho6KbQYWNVVDERGBsBknHxpk44ieZfmSxrMXuud06x2i57s4423yKvaXcX9/C0zxxRWyHxzSHhUDyHmaXGiWuO2EJpO5TjILdNqt6W0s6vhCnqWBBoJLr9rDed0FWSAc5UySfcDVS87TyuSllDHEg2Dlcsf5CnxbBxlJUjTSRyRPmWJj7+tU7m4t7mFrW4uVtlbmFABI97VY0nV7T9gqZrhhOwIIJ4nZvMCqXZvSIbjjvtQYSRg4jSUgj3n+lR12ZcqvkVbLR9UxJ9Q1ArZA4WTjIDD0FV7fRpYb1pJpmYg7spw2fOjuq9qbKymW2t4VnjXZipwq+g86tWGoWuqxzQ6YrRNw571otgf507ktsFknFXJAa0ieO8ma8mWe3AyqMMY99ZvtfZR2N+rWwdIp4+8biYtgZ5DPSjGr6TrUaSpI6TQZ4zIGC5Hu6VkbudpblTcTSScKAKrHIHoKKvZOepQ5Jmb7SIxlhZWKqVIXAFAAs75HeBfevOtD2nEYEJnxxEnbiIx8jWcMduN+9YA/wAZpnnMeUmRCe9B/wCGuVZ2APeAenDUSJC2eOYn0D04xWw5ysP/AHhpCPpH6KZoLj6MuyUWVcrpFopUjqIUo1HBPaXTGG2iWBjvJxZYemKzn0TT2dv9HPZKOM8U8mlWnFjz7laP9odVewtx9TSKWYHJDbhR/WudI1UX0gyi8mbduhI5U8bms3oWtXN+Q89jIgAwX4sA+4UbN0BkBcGig4MtKTxEFcDoc86bNKIgMgnNU0uG4iS3wpyzscl918qVB7bJDdr0TNVJG4nJAx6U9pEJ/dgfGrUoi+rgeEe6mV+PgitliCFnILeRoVcxN9YeeKbuANsk4FW+XTNQ3MEVygSdA6A5waaNEqdgNbuOHUEkmja4QZ+1U5x7qnuLwSvkAqg3HnT7+NyWihsoAmMB/L4Cq0NpMPDKFK45g1eqNVXYO1KSNomLEMT1xQyOVY4eG3UInp1rQ3WnTRxfZRrIp+5QK5tpYHIkVEzuFB3FXBpmkWmLYz98jRlWV/dim3sQRhw9KgBxuNj51atLxEUxzxCVOh6ir41tDqiiw41xyNSrFIy5Az7qnaKEqzq7YznBFJbSd2xGMg/OixtlfGOY3qhrwP7Mlo6saStngdTzORiqPaZCdKZEGST0pcjOcviZbs4pAXavQ+z4/tcVY/QNLuFVWMZx7q2+hRMl4nEuKiTPPkR9qcPrbgnA4VFDu5RSCJcVc7UHOuXAzywPyoTjy3q4rSPQxfggpCMgd6QwHI12ArHhORQ9J3RMLjFWoiAoaR8n30nE0o541QmRI8v1x1qCzu1uppYyuCnrzqS6nMdtJKGUqqk0P7I2VxcLNc92xLcvWqSSi2yG6aQXeRIxvz8hVO/H121aNVPGMMp8iKM21nHdkxtE5mHJgdl99HrCy4Qr3ESGVBwhscx51m5JCnNLQL0W0E8EcpBDEbj1rSQQiNQAKjtbdYeIKNic1bArNuznlKxMVxpc1BPIEU71JK2Vb+cBWU9RWXW4d2eNt2jOPh0q9qtzxeJDll3x5ihFwwjuI7gHwN4W9x5GtYo3iqLywNPxBG4TjmTyoXJ9YtGXjuWk4T7GTg0TQFnCruTUz2LvLwd348Zp9DkkyxZ649zGwWAIy8+opkkrSycbHeugsplfhCEE8yaebO5FwI+75/e6VOhKkPuLp50RWC5Xr51PoUqmW8tXIHfRZUHrjnSiwZQOZk6Y5U65tGaJbqBO7u4jxL0B8wfQ0myW01R5Lr8JttRmj8mNApzWu7aosl4LuIYjl5g80bqprITjOayn2fUemlzgmVHByaYNjUpFNIPlWZ1DeI5pQxPOl4POnqmaQCYz0pCh6VOI6UpiiiSqV86birXdljhRk042jKMuKkOSRSxTZXEaFiaW8mhtY2knkSNBzLHFZO97TW9xP3dqssiDm4QkfAdafB9sl5EtILSuZHyTzohaxd2mT7RoZpuq6RDh7m21GeT+IKg+WaMf9LtHjA7vSZCf42FLi39EPM1pRYhbFNOXPCoyahuu2zMpFnplrF5F/FWd1DVb6/Y/WLhgp+5GAg/KnxS7YKc34oN395aWW1zNxzdIIjlj7/Ks5fPJqDh5R3arska8lH8z61VhQLO/CAAABVxdqOVfiJRvctlPs9Ym4vLjiBKLJufPArY20l3ZDNrOyqPuOONfkeVV+ydnw6YZSPFLIzH57Uakt/AfdXRC2rPBy05MamsMcC8ss/x27f8A5J/rVuDVLA7G6aH0miK/mMiqZgBGccxUMtvty2yK0sy4LwaCO4tpP3d9aP7pRTihb2ZYT7pBWbe0GSCgO/UVG1kmD9mvyp2Lg/s0joE9qSEf+8FU5bu2jPinjP8AlOaDCzVQPAM4HSl+reQpWPh+yeXXbUTNFEsjyD0wKqT6vePnueGEfwjJ/OqMtt3etoOkiA/rRA2/pRy+hqKBVwJbh+K4keVvN2zTFttmONxii/1f0pFt/EwxzX+dT2UCRB6U5bbxHbp/Oi31fblTkt/Fy6UDsA6haGSxmUDfhJqG2b+xQt1KD9K0zW4KkEcxisvjgXu/wEr8jWWVaR6HoH8mjs+Leu4OF2XyNN61ejUF3JHPH6VznpkEXtCrlRmIcQK7VINhzoGOBpaaKWgZDPEH5c6dFngGRuKkriKABV0nc3Jx+7fceh61w3dffV27h76Ij7w3U+tUbUlp0U9DQKqYcsG4L+LydSp/WjiqWOFUk+lZ3i7uSKT8LgmtVZ3P1aUsF4s7YroxPVHjfyEeOS15IMefOuxtvT5pO8lZyAOI5q7pNgbybxZEQ5nzrRujhuuwCYDLxRk8Jjbb1BohAvAirzwMZqfXLMWOpxsgxFIOD+lRJTtgt7LEXOrsWDgEA+8ZqjGeVSySyR8PAOfXFNKwbPdPo31v9paT9VnYfWbUBfVk6H+Va6vBuy2qyaTqVvdrnA2kXzU8xXulrPHdW0c8DB4pFDKR1FZtUeX6jHwla6ZNVXUbOK/tJLedcqw5+R86s11I51oDrMVsWtJBwzxgRkeY5Bh6UQcBFGOQGKh1O0MpjuIQPrEJ4l/iHkaa9ys1i0yZHhOQeYPUGmaLZidSJm1FUG+Mn4mj/Z6L+0uQNlXAoBZDvryec8gcCtT2fTEUr+ZArWXR0ZHSoK1l+1z8U8KeSk1qDWN7SScepPv7IAqI9kYvyAknKoGOSB1qaU4rrCIz30EYGeJxWh2+CXUm4YeFTjgwux9KGGRurH51oJ3cSyDCYDHp6+6oS8n4Y/kP6VKdDXRjtWuW71YhlhsTvWy+j9Xjs71JOfADjPLesu0TX3aJ2UACIgsG9PKtWt89npWouQveMgROHqxOBVSfgMquNA/Tz9Z1O9vNygPdR+4c6sXmDEwGOVdZWxs7KOIc1Hi9T1qndzPwNgU0rElbMjqDMJpACdjyqfsvKR2j0/iJP2q86LWLytCSH+8epFSs86suHI/4jUyWzST1Qa+kna3JX8S8vfWHiJEybN7Qo+090d2lJ+JqLv7jiAMh5+ZppUZwXFUSnh4mzxZ4j50jFP4vzp54+J8Ffa9aQ8fmvyNMRXm4eH73501uDoG/OpZQ5XmuPdTXDg8x8qaEQng6BvzqI8HG2Q351OePnkfKojx8bbjl5VRJU1XUhY6a6wEieRgB6Dz3rNNrOonP9rlA9Mf0rS6haG4j+5xDllaASwlCwZVBH8NS0NJFU6vqOM/W5fy/pSHWNR/75L+X9KnSPKD2P9NSR2cksMsqKhWMZbw0qFQPfVtRIx9cl3939Kj/AGtqKqFW7kAG2Nv6VaaPxqMKP+GkaMdeDP8AlooTRUbWNQ/75N+X9KjbWdRB/wBsl/L+lXe6GDng/wBNRCIHOyc/winRNFN9b1L/AL7L+X9KhbW9SBLfXZcnbO39KImFfKP/AEio5oU4TtH/AKBRTFRDpvaK4iu1bULiea3+8qsAf0qnddoL/wCsSGC+nEJY8IYjOPlRHuI8co/9ApPq8ZG6x/6BTpioEHtBqpP+3Sj4j+lINf1XG9/L8x/Siv1ePj9mPl+AVwt4d8rGf+AUUFFew1LVrg8RvZ+6HMjG/wCVF9JGZyzRkkjckDeqapwp4WAHlgVe0hSZAe86elUkNBqC2lnDGK2ZlXc4A2rTdndJhuIVlSR1kByyL/Oh/Zm/Nld8PCZlk2KLjJ91b6ytLKFxdW8MkKuftMgrg/GnNtaNIjJLBpICoVeDHFnPKs8FPFjG4rY3N1EsRNrG0uT7UZAANJYWHdSNcTvlm6Ng4HvqFLj2aqbitmWtoHclkOy88HfHurednkEdiVU5USAgmhNx9Vsb3v2RArryVd8+dGNEuEuIJmi4eDjXGKjI20c/qZOUbKHaMfbmspqNt9ZVRxcODnNa3tIPtjWTup4opAkgPE3LbNaQ6MIlC/jt3MUMspUjlirAjjEeB7IGM1DNdRpdrCYt2HPFULdFkv5o3yUOdsnFaUXRdsbeGIuYn4iedbLTbh2soSw4gFGBWTS3gjIVAFbmADvWj0tiLKHhJBAxn41ElZvhV2HY5Zmx3iBUPnVGVUkuMREDPnsM0somaENI2VHLJpBwwoHjlzJj2QuahKjSKraIbq3wQkqqw546UOuLXvMhVSMdeBcE1fdy78TnizUbHLHAA91UbRvyCP2XlTiQ5qFrAInDIwEnpRp2CnB29aHXz8LgvLgAbA75oNAXdIe9wuCQN8VBwkMAdj61ZW4AmJbAB8hSTcUj8SOnAOh2NIOgb2jAawbMeCCPFyrCzDMUg8q3+ojvNOn73iJ4fCc1gZQe8cdK871q2mdXpn2h/Yt+715kP34yK36oSRtn415z2bkEPaez4vZZ+A/GvU5rZNu7IX3mtvSP4UY5nUircQSoveKeKQKeAA15xBqXaCy1uKfU47prZHPEHXwhSfOvUhmGIg+0B4TigXaS2v8AU9EuoY5ERSM5PXHSu2Mq0c003tAPWe0ljqur21nAoeJTkTHfDegorhY0OAMAdNqwfZfRrltTWWeNokhOTxDGTW9dQ0bDfcVbrpDw3TcjH9nJBL2gu3cnibOM++tRczfV7eWUbcKk1ltCh7jtAwO3PHrR3tI/d6TNjmw4a1krmkKDqDsHSdrpJdHa0lJORtWHl8TMd9zmpnU5PlTeDiIArZ40ro5HtG50OMRaVbKBjw5+dSz2uxaMDi502yQQW0aA7BRvVwbjNczV9noqNxSZHbOTGOIcLdRU4JHI4poA6VnNZ1CVtUhs7cgDI4vX0pdBKXto0oNE77WJrqxgswFit4RjhT7x8zQGWaS3KgqDHjGw5VYjYFcrtR2NSUnvwS8WOVHdGh0L6oX1O5lM5/u0BHD/AFrNsz8fCOXPOKeScDcA0nscvkqPQtD0RLKX9oRXTW9uwyiyqpbh9Sav61o1rqECytLFbljkzKMBh0yORrzCS4nYojvI0Y6FiQKvafCb+/ia/wBVeCyjXDI7ZHpjOwqOHmznlja+VlvtD2O1G37u7spo7i3hPE4U4Yr54qzpnaibTdOFrb20OQc8Zzv7xRC9ktbq7jtZtaeXT44+IrG4iB8gSOdZC57tbqQQEtDk8JPUVStqpFY/lalsJXmuXF3azJPhnlOWfPTyArPO8bXnhYs4UgY61ZJPFw8O2OfSg8NwV1nueBVmZCeXTzpNfRPqXxhSIe0DMsUftSPxYbAz0rNBlUtxRPz5FK1OveOxjMWMBxliOtZvjmLFVCZHXpUnmELSRFSBG2T5JTEMYXDRuT6pU6i4XPgj8+dNE0pGQi/E0CPbPo006+m+jrsxLDEvB+y7XBZsZ+yWtlaWsFzCTPZBCu3EHzxeooR9G7NN9F/ZGK1nBcaRZh0PI/YptmtPPcJDagOgBUYwo2Fc9nTGUpJIdEicCxxRhVQbb0x8cgvDj1qu92kdqZmwqkZGedV01GKaPNuQ0v4DsaOLLUGXwK4McEDkaYCzpuCppVGPWgB1dSUlIDj76Q0pppO3PFAHNknJ3qPgUnPWlPjQlGDegNDbfWbSWeS3ncW8ynAV9s+41Si30ARZio8I4j5ZrNarbC4vHeNCrD2sbjPvq7NrCQSsq8MiZ5ih93qErsDa5EXljatIxaNYprZWaBGXDLg1RliMb4xz5VfWWVt3Ub9RUNzHI7ZCD4GrTpmiFgtmjYMW+FTSRqw3AGKSAtwYcEEbb1KcAZNJ9ibBUurrDJ3c8LpjrnOaM6Zbx6gsRzxxk53FVXijkfLxKx8yKeuqR6VHHKFAXixipatGM7SZvLWxgihCiMDA8qikt4VmVlABBoTb9rraeAcOOLFLp+ofXbwDfhzWdM5E1ewJ2gjVtVu5CGJLAD5Vn7iKUuHifBHQ8jWo1M/9ZXY6CTH5CqErcJXEYY56jat4vVHdj/FIFqCccWx60VtLGMSK0uJoGG7xn2PfRZYUvLAwfU3SYDKkrgZ9DVqwuLe1tFhm7pJhswB2JpOTfQ3N+Afc6FD+zJIT9pI34m4cCo+zsFxbKYbWSIBD+7ck49QaMu8l04Sa2iEB5cTZJ+Aq3aWkNrGUiGF5774qHJpUyHKlspwRdzeSXEbF2f21AwBRWEmRQ2SPSuCrt4dqkG3Ks27M27HClzSV1Ig5mwM0C1O84XZAfEBkDz9KK3LEjgQHJ61m+0Ei2Zt5fs2kDeIcW9XBWykUUNyzM1xHwxtumeopscPEWtpAVU7qT5GidtqMXA8aIJ7dfGCNyFPT4Gn6oGuY4preFu6h3LEYyvUCtLdmilobplmsykNMeKLwsqjfNW9ThlEaSRNJ9mMFl54qEXNpZXUUsbAQzKA3D0PQ1WmuVku2S0eRwwyQKmndiT+wms0J04SrIxRd3wfFmp7S6WVA8MokXkQ5wVobZac0kTNJFIqtzw2MD3Vfjs7VbYxEB1A9vYH50mkJtdE897HA+M8WRnaq813JPbs0MqxgcwRvT5oLeK0WOQ8R+5xHcVFFp3CxE7Egj7lLSFoD9oezf7Ws+/s5VN1jxKT4ZP6H1rzS50a8jnMUsXdyA4KuQp/OvWZLgWjD6vNxoNseXpUckyani3uoIZd9mdcgfA0njs7PT+ryYVS2jy+HsteyjOY1HvzUrdmJYRmWRSfQV6LJo2lcZt5rCNZOQeElD+RFVJ+xdm9ysa32pRBgTiO7bb4HNT7S8tm6/ksnk84udNWLzqsIAK9Iuvo8ieFmtNe1QSKd0k7uT9VFZ647GaiSRFrScI595ZLxfkaFjXg6Mf8AJRa+Rl2UKOVTW1jLOOM4ihHORzgVoLHsP/aV/aWuXrJn2YIUj/PetT/0W0rT2idrOe5I8Qlu5DNn4HYfKn7S8iy/ya6gjznUNQ0vQ9Nkun7yeNNmkjTIJ8uLlWEv+1+paqXXR7DuYRzlk8RH8q9d7TaPJ257RWlq0QTs3pil51jbhV5uijHl1rDdsHtILw6fpkaRW0GxCDbNZuSVqC68lemk8z+e2YMaZJcyCbVJ3uJOfCTsKuiCJVCqiqB0Aq0y1ERg1i23tnppJaRXe1RuW1UprZ0PmKKgUjrkYIpDA6ingVPPDwnIpsScciL5nFAEaRlFGebeKnNkIcc6ITWvHKxB25D4Uyztme/hiIyCwz7qRE3xg2bHSIFiskiOxUL+lX2hBU7dKpqSJmHQrn4irUE/JW5V3RVI+bbbdjEh+zXPlUVzFwwuR0GaJRAPGCOQJFNljDRsuOYIphZQMXH4gNjvTTB6VetkzbxH+EU8xikFgwRiRFYeWD7xXfV/SrUSqktxH+Eh8ehH/Kh48QW5cyzSSHCQxvwkDzAz0o6Q7KGpQFdX058bNxJ/OiRgqPUhtbSHfuLlQxO2x2/nRXuqPIWRadpDXsdy6ywx9wnGRI2C3oPWqiwL3noVP6VeZVXnUMmeNCOWaKC2U2jHIUqRjxbfdzVkwMRkDNQoSHIIwcHNIZGI96yOpw9zf3C/xcQ+NbRRWb7URBbuOQD21wfeKnIridfop8ctfYF91XoWDBT5rv7xVHFTQOVHoDXKe0y5S0g86WkUjqUZJwASasWFpJeXAjTl1PlWwsdNt7RBwoC3ViN6W30O0uzHLazsMiJ/9JqJ0ZDhwQfUV6GFA6VFPZwTriWNW94p0xckef4qncR91MJANid62Go6AAC9qT58JrOXEJHFHIpBHPNA++iKQd5A3DzI2o/p8pmsoZDzKDPv61nLZijGNz7qMaE5NvLCTkxyH5HetcT2eb/IQuKkWeO4e+SJEyrEADHOt7ZQC2t0jXoNz60E7O23HMZmGycvfWi6Vvds8Sf0DO09p9a0x2QZkj8a+8VmYJBIiuOTDNbsAOpRuRGKwEvDZahcWbnBRyV26HlVJWEH4LiVchNUozyq5AGIyASBzPlQWErdtxXpn0a6zgNpk7ebwk/mv868vgNFtPuZLeeOaFuGSNgynyNJqzHLDnGj3aWZIsd42M8qkUgjI3BoRpF1DrmmwXW4fGHA6N1FFlAVQByG1Ro8tqtC0C7QpLa2txPbqWR1+0UdD+KjtIyhlIYAqRgg0J0OLp2YOyi7m1RTzIya1OjJw2KfxEmqZ0mJLl4jIyA+KMAdPL4UVtoxDbogOQoxmqk7NZS5Dz1rBapJ3l7O5/Ea3Nw3BBIx6KTXnszcZLHqc04GmFFaQ70S7Kw97q6HoilqFyHf0rSdiIctczEbbKKqT0dGR1Bg254e/lGW9s+fnVeRkQElmwNzuat3Qb6zNjh9s/rQzV5Wh06djw+zgfGpRrHpA7RVEktxduzHvCQvPOKltZpNR1QR2sEki22ZGR8+Jhy/Op9NiaCzgQcI8GTnNX+wMouNT1eQEElQPgDVfsMjpNg+cazOx4mSPzAIGKo3FrqiBi0vEB04s/yrXTYEje+qd1jhbPlVqTIjNmY07Pcv3obiDnPOp34Ay7P8jT4Qw7zhK44s7imyB+Jd15+VJ9mnZExXHsv8jURKhgeF+fkasMH81+VRMHBGCvyoEWGKmR8qxOfI0h4PwP8AI04hy7YK8/L0pCH8x8qCCGbh4PYb5GkPD+BvlT5g/dnxD5U0hvxD5VQiJuD8DfKomC94RwNjHlU7cWfaHyqBlbvfaHLypkiELy7tvlVa4toJd2hPyq2Q34wPhUZDEe2PlTEUEsbcIMQtTo7eONHVI2VXGGHmKsKG4B4x8q4g/jHyp0Fg97K341HcnnStZW45QE/Ciphg+oGV7kC4D4CYHKqp3BxIu/oKCbKQsrf/AAD8hTfqdvlvsOvkKsnI5yAU1c5bMvX0p0BWNnBkf2f8hUc1pbhD/ZwD7hVx/PvR8hUUuSh+0GfhTokgNrBneAfIU76rAP8A2cfIVLjfeX9K7H/jfpToCubWIybW45eld9WiHK3X5CrVtby3N5HBA5eV/CoGNzWqtOzaLYXNvqJ+r6iTxQu7gBh5DoaTaQJGM+rxf93GfcKK6DZ6XKrDUZntcDw8EfFn30/UdLFpqaWS3qNIQvESQArHoTRB+yGpwPAjOpWRgvGh4gvv2obQzR6L2XseGKdDIzKeIOR4XHoOYrQPZQSyPmZ5IwMNGW4uH+lY3s5dan+2TaSXjz9xlTAZlXix5bVo7W8aTVhBfJ9UuBukcYzxj1PWsmmWmW7CzsW43tgzRkcJDjIz8aJwpwRhMggbcsUxLWGOXvI0CtjG3KpqzbBuxqxrwEFQQeh3qfTUWLvwihVypwKiqa027/3A1L6Mcv4lDtIMSfCsXqUatMjEbjlW27S7EH0rFXwaS8jRfZAy1b4+iI9A+7jkbU43VGwMZNQWYL6lMcbb0Wu5e7jJAJY7KBzJqrY2pgRmk3kbc+laXouylYIJb1+8LMRnBzuK2emN/Y4xg7Z/WsnYRcFy7Z3YmtVpZzZJ7z+tKR04fyDtqiva4aMZ8z1oZI3dk52xSMG4lKuwA5gHY1BJCshfvCTncKDgVmkbRhxbZIXPAWHLoTVe4Ez2wDmNSdy4JAFVMXy3asFJXkoO4A99WuELNICrGFhgg8s+lUag27a8KqsjcaZwrAbH40y3t0m4lnnKuvIdKtz3ktqhSaJix/dkAYxQm5k+sSB5FXiHkMUFEqDu5tkZ8cj51JJxzYMcfEBzBqorsgwpIHPY07vmDF3cjz3wKmhNEN0WmSSDhAbhPhArBzoRcMPSt/wPeO8hkCog/eDqKwl4yG5JibK5Iz571xetXxRv6eXyoEWxEWtWjEgASrueXOvcm0tS6sLmw+M3KvBtUTDk7ihpmkz+8mx6UvRbTRz+tbi00fRT6YhbxahZEf78VXudLgkiVDqmnxqDkgTbYr5872T8U3yruNz1l+Vd3E4vcl9n0FLp+nLFwDUdL97TUMl0uxyc67pajy7zNeH5J5iQ/CkAJ6SfKmkHuS+z1q17OaNa6uLybtHpzIDngBNd2m03QdSWJYe0tlbou7DgZs/nXkhU/hkPwpvAeqyfIVSk07snk+jdP2Y7Pr7Xay2/4bZj/Oo00Ps1BKrv2oVgpzgWp3/9VYhojnIEn5V3deayflVe5P7Js9Pnv+zAAxrMhx5Qf86hbV+zSrj9p3De6Ef1rzbuv4X/ACpO5H4H+YqLNfen9m+k7Q6CpIS5umHn3Y/rQKK60GPUvrjXl9JJxZA7tQP1rP8AcfwP8xXCEfhf/UKLJeWT7NXe65ot1LEzS3wRDnhCrg++rB7U6OPZS8PyrG90Pwt/qFd3Q/C3+oUh+7P7Nj/0s0nmILs/Ef0qtc9pNKnlicw3i92eIAOMH37VlxGPwt/qFdwL5H/WKA9yb8mubtfp33bK5J/z/wDKi8TLeWgZ4iiyLuj7kCvOkQCVCBjxD7wr0lPZHuq4nT6eTldmOuYZ4datrOSTjhVsxjyFbPPlWU1GVR2wtVDA8gc9K1bDhJ8h1rWTujTFVsgu51traSZ/ZQZrFdnbyS77StM7EGRW38hWhOv2M16bLDuWPBnh8JPlT49Js7O5E0ahS7b+QHlUPoxzr3FcX0JruJLBiGKQhhw42J351mBEMkrcH51p9adPqDtIcAEcC+mfKsqTbu5Lez/lIrI89j1RyxAn2HXakFtIOU5x7hXd3aAZIx86YO7/AB0CPo76L4Qfow7IkbH9kWhP/kpV/WJLpIyYhH3WMMzc/lVL6L//APGPZHibA/Y9ny/3CUU1B7dCqXGJA3LbOK549nRiYMtoLKeIKTNO564Ix7ugrodDCzcZmZVB2UDei1uY+6VYSoQdFPKpDVOTNeTIUDA8KcZUfeapBxdacTSVNk2ISFBJOPU0xpFVAzsAp5GlkQSRsjAEMMYNRTQBrUQhuCMe1128qEBDJeoJ1iidXc9AanZgXMQdWlxngFQzW8aw5tIYC45FhQaO2v4bsFEYO2+Qdse+rSTKSTC8MFsUkhRikjnLqHwwNBbnR4NQkkSCGSCaM4MrPxA+8UXuo2e5t3jj+0Tdn5j3GpLrvGCyRKeJdyB96mpV0FWZiXS7yFmRomkC/fQbGrWnXv1VO4uYOOPoQNx76m1fVpDAZLVJEePJIDYJ9KEabqUeoqzK5Mo9sNsa1pyVstPVMvysskjMnLOw8qglZlXwDJpZYg5BB4T50pQDfrSRViW4Z1AI8XKr0thNEMkA+gNUFCxZYZFKl85JCyuD6mk030JjuBQ7c+Lrk0A7VhfqaKp34uWaKO0kztwOpPXBqqkEMuoW8N2PCzY3qqrZE/xYG0TIUDr5Gt72YH9sXJobreixabMskGDG3QUV7LD+1Das5O1ZwtlfUhnUrv8A3hqSLSnn4WSfYblWQrTNRP8A1jdHke8O9MW7ZpQzTMcc8N0ppOtHdC+KC89i5SMW13IoB9liWU1R1HS7UTopmMcsg9kDK5ohA8M6IYLjhkUch5e6rEFpb9zjBkyckscnNTbQroHaVowjHeXLGRx7IDHAo7EpAwfhUSupchQ6n1GM1ZjU8yaiTb7Ik77FpRSkU2pJHZqKaYRYJ5Gnk0O1gl7J2T2k3A86aVsKLkj55YoJqmixX7tLtHMRjiG+asaRdi5tQC2WTY+7pV6q3FlIyWmo9rEVcBXhc8eNyyE4Yfoa0d3wzwcBhn3Hh4RtQ/VI/q96syr4JPa9T1HxH6U+1a4cCESHuoiFJVtyvQ/Kqe9gnsqafp4dbmC748oPApG/pVvTUW3tZZOKC2lJ4Sz8wRU15GLXgubbiMqc1Y54l61WuShuP7d3QgmA9ggnPSn2PsPaXxR2UYaYTZyS/wCLNCrnR5GupJLeb7MniWM8gad9bS0te7tiJY1G2eYFV7TZBcSfWkyc5jbKn30kmtkqNbJtLW4uWkWd1+zODt4gf6UVdzFATLInqTsDQmeVoAbi0iVUb2iASSfWmwX0eqIY3iRByLF9/gKGr2En5GGA3F4O5iUxrueBtiffVm701Ei76I9yVGcAZOaIQGCJFRGUbY3O5qped2YiLqUlGyAy5wPfStthF2AGZwS8hZvIg1NaXLLOGHgY7cXOq8zLCxWCYSr58OMVX4s+la1ZrVBv6x3EhKSFpG3yDTTODCysi8THPH1oZFKU+7n1qeOUu3CwGDUuIUh0gZ2DDDAVHItx2gvvqMUzJbwgfWZ/8JfwKfxH8qjvpgimNJEh2y8rcok6t7/IedZbtB2rC2Q03Qla3sl9p/vynqzH1rKe9dI6MWCeZ1D/AJ+gl277V2ujWA0Xs6iIFXhLr08/efWvHZcklmJLHck0VuIZ5m4xE7n3UKvYrmLeWCRR54rCc09LpHu+m9PHBHjEqSHfFMIppkBPkfWlzWR0UPAyKQ10dOPOgRDKgZSDyqtZKWuiR7MY5+tW5TwqT1pbeMRRqgHi5sR1NAidSCat6OFkv5HAz3a4z6mhd9KtvbvK3JBminZJCNKWRx9pKxdq0xx2cPrstR4ryGyCWXHSnIDnam4YDIHKrEShRk9a6jxyZWaNEK+uRU8cquN9mqoh3YeRpx9kn0oEW4ECwqo32p5X0qraTfYx538IrpJWc45ChARTOseownmsimNv1FUGtLq2nRrWC0uBGSYpJmKvHnpyORUupuIoI5c/u5FP51bJpNDKU9tK2lzRyOJLh8uzAYHFz29Ku94zIpJ5gUhPhb3H9KpaHKbvS7aQHJK4J9xx/KjoC2Rk7c6lSHbJ59KnjjCDzPnT8UgG8AzmmSQxtuw35ZFSxHjiVvSlkXwE46UADntXQ7eIUF7T2jSaZJKo8cBEnvHWtYuGUMORGagu40ccMoHA6Mhz5Yo70VGTi00eW89xyp0Yy2PPamKndtJETvE5T4Dl+VOXOa5JLi6PooS5xTXkvwEmMZ59alAyQB1pkYCtschhxD+dGOz9kLi7DuMom5qGaroP6HYi1tFJA7xtzRIjNcBtS86pKkS9nYrq6uNMVHc+dBdc0kXKmaHaUDcedG6Sga0eZXsTJlsYZOYq1pEwOoxcPKdOA/5huK02vaWJVM8K+P7wHWsVPxabdQXS/u45Vc+m+9C0zP1EPcxuj17TbcW9oiY3xk1apkEizQpLGco6hhjyNS11Lo+XfZw2rLdr7FBe217jZvs29/StTVfVLRb7T5YCNyMr6EcqaFF0zHoaIWtzJHE6RthZBhh50NiLYwwww2I9asxHemjZoJq0eV7ri5DPF51et25Vn1E/1oEE93+VGYGqmiDcditaOm3wjlP9mmIV/wCE9Gr1QEEZG4NeC2z8q9S7Eax9csxaTtmeIeEn7y/8qzkvJxeox/6kaiq913vh7rOOuKsVwqFo5CpfW7T2w4Twzp4kb1qOxuVurcOBwuDwuv4WHMVfrHftA2PaCdmP9mlfhceR6GtIxcky470G9ak7vS7hv4cVgWbatj2rlC6Xwg+2wFYl2OedOC0dmBasZIc1t+x8Pd6QGPORi1YRzlsCvTNIhEGmW0fkgpSY/UOopGOvQv1uYYbPGfPzrOa9cK08NqgYksC2etae+D/W58FfbPSsvft3muQbKRGwXOOtVE6YdBC6eKCN2fiVVTnvtS9h3ljs7qSziElzIrb4/WoNcJFjMH4TxLgbUa7DWws+KIHOYiTnzoekTkdQYLkttXmZmnukib8K7/pVWey1EA/2ziPqK00/718nrVK5Ix8KtSZMZszlmGCSidWLhugp0gXK4RuflUq5Ly8JUb+VMm4vDll5+VD7NBjcAH7tvlULBMj7NvlU7A49tflUThwPbXHuoEWW4eNsxk8unpTCFz+7b5VIeLJw4Gw5j0pjBvxj5UEEUoXgP2Z+VIeHb7I/KnSA8B8Y5eVIckD7QD4CqRJGQp/uzn3CoSB3v7s8vIVMcg/vB8hURJ7weMcvIUxCMFz+6/IUwqvSP8hUjb/3g/Koyf8AxRj3CmDIkUcI+y/SuIGP3X6VyHAx3o/Kkc55Sj8qCSOYDwkRYOfSmgDH7r9KV+a/adfSuYg8pf0piGEcRH2X6UwAcb/ZfpU1tC9zOsMUnE7HAGRSXdtLZ3MkNwzI45g4o/QiIgAfuh+VRyDwMO6HL0p3hJ/fH5imS4Kn7Y8vMVQhwBwPsgR8KntLaa7mWK3tTJK3ILiqwKgD7YjbzFEdM1a40xZFs5ljZ+b4Bb3Zod+ANHY6DYi2YXkdzZalEOLKtxZ8ioFWdD1STUUbT9QNu7qSqiaJmdh5+Qqfs3e6jqUUUpkH1eM4c94BJM3v8vSiUtjBC02psjafcBTl+MNn1I5ZrH9MoGXenpoGnzSWtjFfS54nknQAKPjWTi1/US/hmkhgJ3ihfAA9B0rS6xHdXvZRru9vpW4sMiRqFXGds4G9Z+27M3JS2e5uIraGcZV5HwPcfWqi15AK23aDTxEV/Z3dLH4kZXzK7erY2otY6YdaMGpKTYNnP2chZmHvztQzS9Es9O1SIahd29xE+yFZAQG9RWivLi2tz+zYNQNndsRw8EeefLO2KUv0MPoOFQMk42ydyaQkrk5yOnTFUtPPCXtZLjvnjA42xgk1Xuzdm3lhe3aU5zE4Gc++s6HQVMihwhJDHltsasWvtTj+D+dY271K4EkZkMsdxGd1Iwo+FaLs1ePepO0rJx8Psr0olClZOaDULJe0g2U+lZGYcLEqhJPM1r+0e8SH0rIXLEcuXuq8fRzx6Kz8ZOSig+ZNJ4yOSfnUMnfFwyscdRw460hWU8W7gHljG1aFkirwtnu1z6GjWkHNqR5ORQFe9RVGScYzkUe0RS8DhRnxmpZ0YHUi8OdSSQ4UMjhxjf0qvLiCThdtzvzzTY5o5QSjAgbE0jq72ifuZSvEEYg9RvULD3bflUlveMkjJC3FgZPVRUDShsyca8JPPOBn30Djd7KF5ZM8fiMjuzYDMchR54qtNYRRs0UJfjUcRLkBfh51V1YmOUhZmZW/DJmqDNK4XLOwGwyeVVRoStIq5ydweVVNQzcWs8aNwgoR+VSFGYHizn1qG6mt7Kxmurs4ijHs9WPQCjoUmktmLh1u503sillllnmZgpO54M86h09i9jATuwyCc0EvbuS/u5LmU4LnwgclX0/QUX0rw2GMY4W5eVcvrFcLMvSS/wAwj1VDvQXbkQ5PoaP6kCVzQE8XEcPwj34rm9C/k0beuWkxMDGcSfOuwOiSfOl4XPOVf9VKFbP7xf8AVXpnl2N4f4JPmaULt+7f50vDnnKB8TXcH/iD86BicGRtGx+NN4f/AAm+dP4Nt3H503ugT4XyfdSATg/8M/Ou4D/h/nViHSr24YC3tbmXP4IGP8qL2nYntBcgd3pd2B5yR8H60AAAm37tfnXBP4E+dbmy+ivtHcsAYoos/jf+lHrX6FNScj6zqVtGOoVCxqXJLslyS7PKQn8KfOkKfwx/OvdLP6FLBMfXNTnk/wAihaOWf0T9lrcfbQS3B85JT+gqfcRHuo+beEDn3Q95pyRNI3DEiux6KCT+VfTz9l+yekKvdaVYox+8yhj+dSpeaTariFbaMfwhRVK2rNoQnNWkfNUWg6tLju9LuWzyxbt/SpZOzOuRqWfSLsKOv1cmvoO77VaNA3DNewKfLjFSwavZXUQeCZHU8ipodo3WCXlHzE6tFLwOAkitgqUKsPnXpVlBLcrGkKNI5UHYelavtjpem67b8M6AXIOIZAAGB9/lQ657Q6H2SsVhdvrVwAAxU7Z9POrhb6N8WOUXSKsXZJJruK4uhGkqnIK7n4mir9nImYlrtl9BGP61itQ+lONj/ZLPhHQ5oPcfSXfscxxLn13q/bflnUvT+Wzet2L0g3qXLvN36HIZAq59+1EJOz2nlVLPctg55r/SvJ3+kLWXXKKg/wCGmS9uNelQZn4R6DFHtL7H/hYfZ7HZ9i9L1RnadLru8YJ7zHwG21XU+jfs4nOC7b/NcGsFovaXVTpFvi5ILDLHPWrT65qrc7x8f5qzcFZ5mTFHk6Nyv0f9mk3OnMx/inb+tP8A+gnZj/8AQ0R9TM/9a88OrakXAe6kK/56lF9fHdbqUj/NRwRPto2X0VXMh+j7svEctGNItMFRy+xTY1oZ7aG7fwFlIPi2rzr6Pu0t/a9hOzEC6NMyJplsoliw3EoiXBxWts+1lrJOEuZDCTsUmjMZHx5VhQovSNFDDFAvDEioPQc6fUUVzDKoaKRXU8ipyKfxp+IfOpCx1dXUlIZ2a6ond1k9lODHtFuvup6nYE4+FOgodSUhNdnzooYhG2wqpd9+7IsEndjkdqsvIFwMMSegFVLy4kt/FCiMv3mZuVUhooy2fe3rQxFmwMvI/LNCl7PW9jePcQzccpzlE5Ci66oxbiRI8nY461Ab5o5HFuBGH3KjetVyQymwycHPwpCwG3WlmfgRnILEDOBVLT723vwWQcMi+0p5irUbVlchJ5ZG5KQn61ARlutEpJEUYBGfKo4tOu7gcSW7kHcHHOqTpbHyrsgsNOlllBtbc8ROOIA4+dD+3FjeaXDZSySRlixK8DZPzrc9ntRMsdxpd0jxyQAbhgm3l51lfpNV0SzQyGRBnhHCBwiotuVHNKbdlGw1G6vooxcSFuEVseyq4uRnNebWL3aSQraRhkPtZGf/AKV6Z2WUi4H9aiejnZXuYGbUZjMpELykBgc1IughQ0gckjdQmN6PW9kkiu/CuXY5+dSPFIDwooUDbiz+lRzfg6Y5NAmaK+hEZgMcg5MeEK1VdXmu7KNCkyqh+797PrR+C1mEh7xwFHLrmgvaOKIeBUDXDdeEk49KqL2VGabJdHv570eKIALsXzzo5HuMHnWQ0kzQypHIJBGDng5ZrXwnjXiIxU5FT0LJ2c1R53p0h3qnLMnEyyEIoHtFsVCViSLDNQrUrbvCGWVYxjcMeddBc276g0UNyZH4c8HMD1Bp31q2+vsrTIJUXGDy+dXxaZSMnYXY0rWQtzIUg3G/l0rVWuqWl0qmCVWBOAelZXtwzfXbY3QDW5Bw0YGT6UQ06+0s6TEiwmNwuCF55raUeUU6Eu6DmpIr2rh5UGN1Pk3ShNlM6SxzpLwIMRyBhnAJ2+RoY8y98rAZCnPvpby8hn1RWZCls/tpnkepoWOhyjWzTahK8MDO11CJADgFBuPKg31aa9sTCLaKGVR3kbs3jK9OXOpxrK939XeCOYKOAnPP1pJTe2DQ3UoEyD2AD7KnmtRxaE0XtFtbiKyRpJOJ8+KMkY92aIQXHemWOKPg4Tg4xgUG1Xv1hM1vaMWmAKsj5APrUuhXX1a2SC6bxk5GB1NJxtWLsl1yW9RBFZQt3LDDyAc6xsnHHIR4lIPPlXokxljBJnRQeQ4Mms7e2E0xdzC7LnOSuM/CiD8MEkwRFGzgPJIzbcianRjHGIg7cHPhzXcPCMAYxXEA863pGySR2KcK4CnAUirHRAlhgZ9KsM4hCgIzO5wkYGWY+QqtxFCgiDPO54Y41HiY/wDz1ra9ndD+pf2q9IlvnGM9Ix+Ff69a58uSnxj2ZZMigrZ5prOnzSXTw3zFcEO0SHYHpnzxVFdPtoTlIVz5kZNa3tZGBrdwR1xQCVa55Lez2vTTvHEpOoHIAfCqsyK4KuoIPmKuSiqz1DOyJnNV7O2tyrNGndv0K1jdQsp9Ok4ZgSnRhXp7UP1SwjvbdkYDJG1S19G6l4Z5yreRq3YWF9qU3dabZXN3J1EUZIHvPIVSv4JLO5kiYYKnBr1LS9SuJtJsYYX7qIRKCsfhB25nHM0Ri5Oro5PW554UuHkzlv8AR9rUnC97Pp9guclZZu8f/StEoOwdnHvda1cSnqLe3CD5sTWkiUhakIrZYo+Tx5+pzS7kZxuxmhN4Z4ry6UHOJbjAPwAojFoejwxqkOmKFHRriQ/zojjFd8KahFdIxc5S7ZXTTtIA8ejxN/luJB/Ollsez3dnj0y7iPQxXbfzqVjwgk0LurrvH4eQHSqUIk1YNudLj75msrq7ij6LIwf9RUBtr6I+1FcJ5AcDf0omDmnb1RoAba7iQiCYmKYEjgkHCT7vOrbN5Vdu7aC7iMV1EkqHowzig8ulXVp4tNuDJGP/AGec5/0tzHxosYzWSG0ycNyI/nVmSZIYuOVgqgDc1Qtpl1LVbbSrq2ubZZcmUsuNgM4U9ffRm90iHvrdY1dvFkcbFsUuSvQfpg4X0TK3AsxODj7JscqHdgneCzksbpWSaNi4Vxg8JJrcmzhaMqAM459azmpQKFYuSrxZKuOa48qe2CarQWzSg0F0q/vbu0hc2EoYr4nchAfUdaISG8wO6SAH+Nz/ACFCafQqZPbHwMB0YipTyND4o9TTiIS0biOfbYfyp0r6oqeCxgkb0uMfyoTQ9lmzbjtkPvH51Q1mbHdxr0bxVSiuNchiEbWEEYGfFlpOvpUDR3k7jvr2wibOeF4nU/mRSUohT8mX1WLuNWJ24Jh+dRpH4q1F/wBlru/VZDfW/Em68ERwfzoFwFSQww4OCPI1hlW7PZ9Bk5R4fRLEmYD/AOGc/A861/Z2Du9PDEeJzmhWi6U8qF5gVRhjHmDRrQ+JLUwP7cDFD6joayW9nfLQRpx6U4jNcBvVEjcGkIqSmkHrQNDRS12Me6kNACEVnO0GlIVeVUDROMOuK0uD1pHRXQqwyCMGgE6KPYy+zYrp0zfbQLiMn76dPiOVG7aOZZWMmeH1NY26tZbG6VoiUZW4opB0NbDRdRTUrTjxwTIeGVPwt/Q9K2xy1R4nr/S+3L3I9MugdacNt6XFLitTy2ZHXLf6vqDMowkviGPPrVSM8q0mqwC9gYKMOniX1rNoMHfnTN4u0XImq3CaoxVaiqgaCcD4xRTS9UazvonhJDow3oLC3KrsAXjD4HF50f2ZyV9nuGkahFqVkk8RG4wy/hPlVyvMeyWsnT7sLIT3Emzjy9a9NRg6hlIKkZBHWsWqPNyw4MUkAEmvO75xNcz53VnNbnVZxb6fcSZwVQkV51xnG/Oun08e2KA651OSW0isZ93hJKt+JelD2OKdqMZeMTJ+8i3HqOoqLOQD51WWPHo78DtUS2Uff3sMePacCvU1AVQB0GK877Kw99rUOdwmW+VeiVysy9S9pGG1Uol5ckqdmJO1ZmGPj+rSsp4pZy/Lp0o72rkZJLlAwDSycAHvqp3RSa3iUrwxqd8fCtV0dcPxRS1YLLPaQBSOJ8nboKP6Pcx2k8spjYgRtsBzoEvFNrLniGIU4Rt1NHdHtxc3bRSv4GQ54djQwyVx2Z287QSySs0cccYJ5NuapvrNyfaaL3cNag6fa28rJDAigbcsn51BLZxNnijUg+YrRSX0JTX0ALGYTtKWjyduQqeULgfZHn5Cljt1guJhHhBttiulzgfaDn5ClLsYwhMfuT8hUTKu/wBkfkKnOcfvB8hUTE4P2o+QoET4XO8efCOgphC/4X5Cn53B7wDwjyprbf3g/KhEEb44T9l+Qpm3CPsunpT3OVP2g/KmqRwj7Tp6VSJIiP8AwvyFRPtIMR9PSp2bP97+lQnAkGZPPypgJtjaP9KQjzj/AEp3EP8AE/Skbh/xf0oEV1XOfshnPpSgc/s/0rlxwn7XqeoriV/xfzFNEsa+WH7vkQTuKa2f8P8AMU7vOAEiXnsc4pjFT/en5imIRXZCGRMMORBG1OvL25vZA1wON1UKCSM4qIlR/en5io8rxt9qQMedOhCHj/wx86bIGKnwDl50vhx++PzprleHHenOPOmI5A5UeAHbzq5pl19TvI55bWOdUOe7ZsA1SUrwrmVuXnXEp/iN7s0wCeo6vdXWqJeRxx20g9kRHAH9TRTQOLXdTca1dSGKNDJwmTZsfpWVZkDJ9o3zpTIqHaV9+eGNJrVDs9XsdZsptIuppHQWsTGMLjHhxsPXNYCbWbq5046f3avAJS0ZZiWUdFoOJAEKd7JwnfHEcUa7DxNNrSCOOOd1ywSVyoHrU8VHY7sHTRTwOFlgMbY5Nkfyr0DspqdjHYiEODckDJcZJPv8qMazp9hdLHPqCR96gwCz4Hu9a897QvptrdI+nOe+B8aoSUqU+emUtHo0kdvG6d40LGVsEk4GOvLnQy91OIQPbwiQOjHgkRsDFZvTNRk1eSO38RZB15KKKXcdjp6A3twQTyGNz8BS4pGsePbK8kryuWkdnbzY5NaLsO39quh5x/zoVb6fE4SdpCUYZA5ZFGOyqJHrFwkZ8JiP60pu4sWeSeN0GO0Izbx+6sZeyGMZGK2uvjNpGfSsHrX7oD1pYto4odAxri5nmKwOFUbkkbCo5ZrldlnDHoVwQadGAyJbgMeJsvjbI99TQ2UcZkCYJ6b5xW10aWV4bm9Kkkr7mXnWm7Lyd5azSTW7A8WWdf0xzrPkYODRrs1dERSQqSWaTAA93WpltGuLbD0vgLBC6Blz4edZmC87pNSu7zgIhYmJWABKgdQOZo9qM8NrJE9zerGvLuzjf3DnQfUzaXFqZIj4lJHhHP31MUdcaPPO03bS31KxSPRxNbXEzhJFVipArVWlxPFpUVoG+zVQN+dZLtfoAtbiPU7eII0JDyRqMcQ8xRKfW/sYJrWETQyLxZDgEelWEXTfILY/FuakDY4QGJ86qaDc/tO7SBuEF+TDkf8AnRC+tzaXLxMR4TzpXujXkmMyTsWCZ5cVec9s9aGp3Ygt3JsoDgfxt1Px/SivbXXe4U6fauDM4+1cH2V8qwqBpZFjRSxJwAOZJ/maVHLlnbpEqNjB2LE+Efz9wozo2DbTqDnDA5PWtx2Z+jqzhhS57S3DvKwB+qwnhCDyZvP0FbO0g7N6Sn9j02zi/iYBifiazyQ9yPFBh5xlySPILiGSaJe7jdyeQVSaqRdk9fvH4rXSL11PI90QPzr6D0btDppSSRHt14TgBFG3yqzN2tslGUct7q58fp3ilaD1GfJk+LR4XZfRf2ruRk6esIP+NKq0cs/oX1uXH1q+soB/CWc/oK9Kk7aRf3cbH41Tm7ZyluGOMA++un5s5OM2Zu1+hOBBxX2tSEDmIogPzJq7D9GPZi2I76W6nx+KbH6V2rdrL6WzmSEhZCpAGOteZXPaTV52PHcSKeRA2q4Y2+2dfp/SvJfJnrsXZnsfYAY0+2OOshLH8zVgat2a0xSIYrGIfwIorwqe6v7hRxPOTnqTVWexu2IPC5z51r7KOxeih5Pc776RtEtBhJQ2B9wVm7/6Y7KJiLa2kkI6k4ryl9JvHbaM0627M3bsdgc0/biaL02KPg9b7N/Sheak1wyWsaqgGCTmij9u79t8xqPQV5f2Z05dPvil5Mkccg4SSwGD0rWtbaXHlZ9WskA6d8uf1rOcY30cXqMUVPSDUvbPUX/vcD0ofedptRlODdyKD5GhVxqPZy3PC+rROR/hgt+gqlcdpuzEG6td3LeSQkfqRU0kYVFALtxq199Zgf63MVKEbMedZh9Tu5RhpJj8TWu1ntPoF9aqsOmXfeocqZOAD9TQn9uWhjyNNOBtjjH9K1U1R34fVQjCmzHXd+8M4hlU8LHn1BPrWg7K9oLzTHwsrFM8iaBdo+G7mFxFEIlUgkcWadp4PGffVJ8jfFlWW6PTdR1+S5Am4yqpHnArzDVdTNzePJOSST51qdaRrOwOTu0S/nXntweImm9aRrP46QasmNyQsYBHpRNdHun3RdvfWV0iO5n1O3tbOQxyTOFzjOPWvX7Xs/bxRqklzfS4G5M5GT8MVNmfuVqjL2+hXLYDELVtezxIwzn5VpP2HYjklwR/FcSf1qK50ewW3du4OQM5Mjn+dLkDzUroI9mtOhFuLS4kKsPYJ6+laQaDCEAIb34rz1rOykt2kSEhF5YY5P50EbCLhzce4yH+tZuR5U/VJu1E9hj0O2A3UmrCaLbKv7o14eXiB2WbHqTXGSD8MvzP9aVkf4n9Hsf0cMR2A7M4yD+y7Xf/AN0tamzaMO/1lvsyOXDnPpWU+jvb6PuzJH/6Ltf/AIS1olbiGazrRovxQUis7GcH6taCNSd3U8H6VXbQ7JpGW3urqKQc+Cc/oc02K8lii7uMgDzxvVizkt3CxvGTKx3fOPzqXGhOJRk07UoQ/wBQ1adynNZolYfPY0kT9pEXi4bK5XoGzGTVDtV2iOku1nprKZjvJIx4uD0HrWSTtNqpfP165ffOMkj8hVRxNqxcTfXWs6rFA31jRmTHN4mVx+tDpu1yIF7wXNsPvd7AR8iMisdc67qN0T31zcsM8sH+lRPqd+yhTdXJXOcHJA/KrWKgUa8npVr2ksbqLitJYnI5B5QCada6tCrSyXTyBzyRRlQPSvMrjUZ7kD6w3GR1aEZ//Zqq5BPEsksbf+EWT9KFiDZ69peqQ6ik7owjaMkcDncDzIoFLr6Xge3NnE4QkB8HB9R5V50izd4SmoX3Edj4/wDlVhLu7iUJ9bmZQeTY/pTjiSBJ+TX2yvAW8ecnb09Knil4GY4yTWP/AGtdjnckY/hH9Ks6VrEnfBZ5BJG5xxY3U/0rXiaJo1azs7+LAXkRVYWdrbuWt4wHJyWzyopBo1zJFxkBB5GnJpM6yBnjDoDuOLGajlELRUtdPuLpS1vGXA65rb6RFILKMSsBKgwQOnpQ6wsoCokSCW2cHpJuf+VFBty/Kspy5aM5vlobJDE0ru8MRdhhm4Bkj31gvpSWMPZKh2Cn9a9Ft0ViS5+FecfSfw/tC2ReifzpQ/Iyl9ArRVwq4+dbzsuB3u+9YfRscI5Vu+y4+0Pup5DBh6zGbXyyW3HvpJ5O4gPGz7D2xgmoYrlYbEvwyNw5OEGSdzyFAIe2FrLfpbNDcKc4LyL3bKfdUQhKXRok0aDTXaWEu7s2+BkcJ+NVNVmt4mb604ZHHgUjIyKuahNbCDFzP3ccmyvnGPjXn74F/cQCVJRG20iNkMDV44cts0grezQ6ZI09yGfxIDsuTgVpcgJsMVnNEUq4yRg8qOythcVGTspq2RyniBxQfUri2MTW+oRMpI2bGc0mpXMkYLKWUeYrPXc8s5xJIz45ZNXjx3s0SJOz9pbC8nMlzKhK8Mfj4dvL1orcjTLGQwzWrZI4u8xkt8azl1p89xZMyxngOwbyNRD61bBLfUGczAeHibO3StnFN3YtJnapqVnNem3gEjRsMAyD2fSq1q3dyBTyPhI9Ryqy4U4LxYYHqtQ3CeMEbB9s+R6VaqqQNVstjnvSSwiXOeeOdNgfvIw33uRHrU2cnJGKVF9oq27MJQSxG/CRR+XU5ZrZIZAAqkZYczQO6QqRKufJh/OrEEjMEccJGdwRnNDVkLWg0lv3qMLeWWQRAOqFzgr7vMGiEdxps9piS3KTAcwdwfQ0DurhXRZIIlt5UG/dEgOOu1NhnVSOLeN/1rJwsnj9h3StRW2kbvk75T1J8Qpt/rE0VyzWTkRn8aDY1R0+zlvrkraADAyS3IVefSL0953aJKq9QcZPp51LUU9g3BPYGmlaeZpJMcTHJwMUzrTpEaNyrqVYcwRyp8LKp8S5FaGvjQ+NI5BscN1FRXBMAHgZ3Y8KIvNieQFTGSFdyuBWo7NaKY5BqF8v25GIYz/dr/U1hlm46XZE5qCtj+y+g/UAby9CvfyDfG4iX8K/zPWtFSV1c6VHnSk5u2ef9rkxrEh8wKzkq861Xa5c6lnzWs1cClLs+k9I/wDKiDJxvVSSr01UpRuazZ6UCBudMY09qYdxQbGP7Y2gE0dwo2ccLe+ivY6573SoFJ8UTGM/yqXtBam406UKPEo4h8KzXY+9EOqXFoxwswDLn8Q6fKnHTs5fXQ5Y7Xg9PUUtRWsgkhB68jU3OtzwGNNIadimmmAhHEMHlVWTT4nbJBB9DVrfpSFqQXRQexK+w5+NRNbyqNgD7jV2WYL6mqb3Mn3QKdFWyBuJfaRh8KYZFB3NTd5MeZ/KkLE+0qk+6gZTuL+C2kgldkDBsDPPB2OKJNOhBkBHhXaqs0STIUZFwwwdqEWlw0RltJT9pEeHnzHQ06BhazueG6wx2aher3EYinkmbgjJ4ScZ5nFJJJiTY1xZJbhIA4JjHeOM75PIUMOi/Fd280K/VZFdFAAweQ91SJKAd1z8aZC/Dtwo49RVpRaybOhQ+YpBY+O5hGOKM/OrsN1AR4Rj4UPn04oveRMWTyqzaKOAYFITovZhf8J+FRyW0Eow8asPIjNKF9KkVcdKQroHy6Nb54rcNC3/AIbFf+VZrUOzMhu2njnBYtxMki4z8RW5HKmyxrIMN86TimqZpjzSxu0zMxTd1hJ4mhwMZPsn41G7C31NHBHd3A4Sf4hyo5JE0Z35edUdQ0qG+tXSB1tLoEMhP7pmHmPun1HyqHj+j0MXr2tTJgdq7NRW7vvDcIY7mPAkQ9D5jzB6GpMb1n0enCamrQ7pSE7UvSm4oLR1dtSjeuxmkMQ0o9aXhrgMUCIbu3W4hKNz6H1oFayS6dfC5iBLp4JYx/eJ5e8cxWlxQXV07q6SRdg361SE4qcXCXTNfbSx3ECSwsGjccSkdRUuKz+iXKw4YYFvIwWQdI5Dyb0Dfr760gXpW8XaPmc+F4puDIREoyQME1l9YtPq94WQeB9x762AWqWrWf1m0ZQPGN199WjODpmTQYqzEQeRFQhdsbjp7qbY2rRSMzNkGqVUasJxGrkJxVOMYFWY87UEMI28mCK9E7E6x3qCxnbxAZjJ6jyrzSM4ohY3DwyK8bFXU5Vh0NJqzHLBSVG97aF4bdfFtM4XHpWS48GmXPaP/pBdyHPD9W+yKZ+91NRk124oOMaZx8XHTJZ3+wk/ymqqt4B7hTp2zBJj8JqOPeNcjoKz9Qujq9P5NX2Fi4rm4mI9lQvzrZVnexEHd6bJIecj/pWhZgilmOABk1xPsxzO5s827TRfWu03dR+ExkuzYzSLG0XeSTeM42IXGBU0bC7v7y/BwZZCq/5RtUGruy2bqrZZyEHxrZfR2x6SKelIDEZmjJMrluXTpWi7OAftNcIV8Db4HlQpY+6jijVwAo4elFez3/akfjz4T5eVJiyO4sfdACd/fVWXcGrl8B9YYeZofISM5FNGcegPJj6y/h4tqhlxw/uuvpUj/wC1SeLh2qOZgFP2n6VbRsNIGP3P6VGcdYv0qRj/AOL+YqNiP8X8xQST7ZX7PPgHlSEf+GPyrhjwZkx4B1FISOXe/mKCGRuDwn7MflTVOEXEY5elK5XB+1PzFRqV4F+1PzFMRzZI/dj5ionHjTwb+8VI3Dz70/MVE7IHX7U/OmIcwI+4PmKaSw+4PnXErneRvnUblf8AFPzpiGqW8XgHPzriWJ9gfOo1ZfF9oefnScQz+8b500I6YtwbqOfnS5bfwrj31HKU4D42PxpTwfjb51Qhjs/4R86YC/G3hHLzpxCEn7RvmaZ4O9Pjbl5mgQ48eNlHzqOQuQfCvLzp5KDbjb5mmMUwRxNnHmaYhsbSd2uFUjHnSM0n4V+dNj4eBfE2eu5pGKA+0x+JoASQuWTiC8/OuYucNhfmajkKl1OXxnzNOXgx7T/nTAUM55qvzNaPSu0UNtp8cM+mQyywvlJQ5U/Mb1miYyfv/nTVK+IePn60mk+ws1faXtTPq8Qt4oY4bfmQ3iYn342rMSmTg+5sfWmEqfx/nTWKcJ2f86EkugsuRXFxBJxwyd23LKkiueaeVi0r8bebEmqvEmeT/I04Fegf5GmOy59dvG4Y2mJRBsCxwK3f0Z3kk+qSxy4JER3FecqV484bl5Gtt9FbL/0hdVVhmFuYNZ5F8WRN/Fnout72EZ9KwWuKWhHCCTxdBW/1jH7OSsdLzOFJrLFpGcejPWRuIHcm3kcEbY2qeKScyFjbSIp3wWoi2c+wfnTMt/htWrbLsF37scEKyjkdqudk5lDTxJ7ZPEAan36qw+FUZWMd4zRkrxIM4260dqjbA/lR2p9kLbWLqW51Zl7/AO41uxUgeuetVdQtdXsrCLT9HmjgjQYzIpdn95qxDq1zPdfVbdJ5XU4xGmce81sdP0K8aNZdRukgXGeFQC2PUnapcnHtm85Rh2eUXt/2ggQR6pbW80RHd94OZHlik7O9kdcvUlW2042loW4lkmYqvwzv+Vet3OpaHpTApGtzcLyYjiOfef5VlO2ParWLzSpxpamAY5rzx76alKb6ozi5ZJJLRBY9n7DQZIrvV9WxLGPCkZ4QP5mrUeuaJf3TrbQ95JjJdxkn515KLK7nuTLf3byM25Gc/nRXTJoLC4jMThZc8OC27Dyrf24rs9RenhH8maXV5tA1hZYJIIhIAcOFCsD6GsLpstv2cv7nULvEq2m0IH3nPI0txKR2hueA4XvDih/a6Hv7F1LcJHjx5k//AEqniVDn6eGilqn0la5qE5EMohiJ9kDf51NaSavqYDPPI+fWsK0Dhjw7EVveymnSzWEb3VzcFT9xH4AB8NzUSkscbIeRQo1/Yq0u4J2iuXKpIdmJ5Gtw2n2sCf2q6jQHnxOF/WvNRaxqXB42I28UjH+dBL+NRIcKM+fWvO/xvOVJE58Sa5nrD6j2bsXIm1K3ZuXhk4v0qOTtZ2XhyUuHkPkkTH+VYaxsbdrNWVA6sN2bnWduojDcSIDlQ2Aa607POc2evWfabT7+ULY6fK5JwGl4U/maKTdk7q6m71I7G2DbkEl/0Ary/sq8wuE4M8xXsrLqcqq0U7ovCMAVlkm4vTNcc5VaBv8A0HYr9rqCj0jgH8yaQdjrdP3l5cyH/hX9BU9yurjldSflQ6VdWPO8l/Ksucn/AKjT3JeSSbsnYAHL3B/96R+mKF3XZnTos4R2P8UjH+dSzpqhBzeSj5UKu7fVHB/tsnz/AOVCv7JcmyC40HTc5+rRZ8yMmhl1pNmgPDEo91TT2mpDObpz8aD3sd8meKdjWkV+zGQM1i1iiVuAAYoCTRC/aY5Ejk0M99apGLYufKpVOYHqE7VIn7l6KEipfb2j4p+knjuVHQsKZdgm3YDrT9E2m4j90E1rjPR9D0w32iumuLJ3Y/ewPcKw7jJzitlqi/8AVMQPM75rJFCHO9Wzuydml+jixEuuvcFciCMn4nYV6hXn/Ym+tdJ027ubiQd7JIFVF3YgD/nROz7SXuo3UkUFoCjAheE7qfMmoSs45Z4xlxXZob/VbOw4UuJT3jHARdz8qmuCGtXONiuaF6R2et7Uie8LT3Wc5bcA0XmXMbjzBodeBx5NNyArq/cGULwlxhEG/wAffWflE2ccEZwejH+laZOJQqjOSmxPSs5dKySPwyOTxHywfyrI8mXZEZJVABjX51FIJpG4u6H+qpRFKwBMxH/CK5klXYTE/wDCKRJ6b2C1C3h7DdmInDiQ6ZbbEYB+yWjT3d/BIzi1UxDfC77etD+wNvFN9H/ZfvY1bGmWpBI5fZLWkJ4R7qS6O1LSK1rqFvOMq4DdV5Yq3xDGfzrNa9bdw4vLbw7+JfWlsNRe8UKynK7Eg1SjYJ7pgbVlW57RTQvujNk+uByptzdtbyd1AFUL5CuVuLtFJnn4v0qndktcyH1rVIPJZXU5881+VSDVJhyCk+6h48PTeuGx2p0gCLalN+FM0o1SUDdF+ZodkCmkk8jTpC0EzqbYyY1Pxpp1RusK/Oh3F0FJzO5opAE11If4I+dQ3rRypHMqAOx4SapjbarUiD6nD595RVDPVOx92172ftXm2ZQU9+Ns0Z4VHKsR2O1IW2lwpPxGIFsAe+tJZ6xFdzAIe7hOwL8ya5pwaYmF15Y6V3M79KrR3kL3cluhcyR+14dh8ascQrOhD684+kkn9q2+MbR/zr0YEV5T9J94sPaGJGyT3I2Hvq8fZMuiTR9lXnvW77M82OeleeaHd8dt3oiYgDfDYNavsp2isXkkicSo+CPEuR+VOaZzM1tj4rdNt998+tU7/RrC/ukuLiFmmQYGJCAapW+tQqIkVWKfeb49KvjUg17FFAnfq4yWQ+z76njJHRx0Z/WNIvNQtJorC2MYXbuXmyffTexnZ9ktC17G0Tq5yNuY6EVo7i0nfU0vPrTpAi47mFcM/vPUVZgaNJn7mCVePd2fIFU8j48UTbIjbiGXjjCKvkKd3iu3CTS3G2y8qrx2kk6sskhVT0FZd9mypK2R3tgt3cxRhpO65tw7hap6/ofDCj6bbhmTdgX9oUat9OS0VngLGQjHjbariJwqSWZyd9/5U+TXRjKT8AHRLq1EX1WR7eCc7mMZGT/xVX1vTlgtHmV45JJTgs65J/y+VT3WnTy/WbuKKI3DeGNHgGfec1Wt9P1m2JmvJluUUZ7oDjyfLFUnu7EnuwPc6FNp9qss90jcW/CenpQ2ZQ8ZHxFa3UdNmu7EzNZpFcv04izD3DkKzd1oeqwzJEtuJWdc4XfHv8q1hNVtminSB9u5WXcYEn/7Qq6u5qrLY3NoxguVZJT4lB6GrVue9iV8YJ5jyNa3ey4S8DyoZCD1GKq26/V5jEc8J5Hzq7wBhuMincKK6O6kqp3xzoscvs5RvyzV6z0O6mkELhYRIC8fHtnzo7p9lZawy3IPCQmJETbD+f8AOp1guJbdlgvYpp7duKPI8Qx0Nc8sj6RhLK30BNLs9SE00Fuxjlj2ccWM1Lax6u0kkMLTAx8xxYAq7bPDc6pDNO7mRlwQF4MH574q7aIJb64i+vXCHqjABtvXypOTFzZkrnvmnb6wWMoOG4udMC1pNQTS4biSGaGYSf4gbiJ9azd86W8E0gJKKDg/pWilq2bwk5BjspYC+vzPKAbeA+EH7z/8q3VZbQWOn2UEaLkBBnPmdzRhNSU+0uPjXFfJ2zDPjlKVroI11VUvoX+9j31OsqMMqwNM5nCS7Rk+10WLmN+hGKyl0u21bXtSVaEYO4NY2461Eke/6FvggTNzNU5au3PtGqMpqGetjIQpYnG/WrFjYy34dYe7HdKXJY4JqqaTiKnYkdNjSNZJtaZV1GQQ2Nw7clQ15rpKo2s2hkyB3obOcYNeg64eOCK2G5nkCEenWsFrMDafrEoAxwPxr7qJdUOSuDPUrZzCzZ3Umr8bq4ypBoXaOJrWKUbiRQ3zFSDKNlSRXQuj5qUQn0pMVUW5ZR4wCB1qvNrlhAcSTLxDoviP5VXFkUEmFQvQWbtVbAHube4kPqAo/Oh0/aqbBK2sMQ85JM/pT4hT+jROmTUfdVjLvtXqDOsNoqSzt7KRR/1q5a2+u3icWp37QKf7m3wD8W/pSbinVlcZGjnaOBeKeRY182OKEXOu2seRbRy3LfwrhfmaWLSoIsEqZG/E5LH5mlmgHsqooT/Q6XkD3ep6jdKyhltUPSLdvmazk8ctnexfU2b6y2WkeQlsj1rYiFScgbDqay/F31xNP+NiF/yjYU3bLSXRZhvL3JJEG25OCapqsjXLt3rpce2kw5+oPmPSitpD9g5I9oVDpgX9oxLIoZWypHwpO6CkgnomsxSSC11Qi2uuj/3cnqD091apLMMuVmUg8qymo6SjxHALxcwRzQ1X0+9vNMbu+IPETsH9k/8A7p/Kl/YnHyje2cLwggyBl8qn7kBuJNs8xQHTdYguXWMs0M/+HJsT7jyNaCIkjehozehUFPFLiupEiV1dU6wD6t3zSDGccI50BZWdQVwaounCxFXnOBVC7lWNHkc4RAST5U0jSIDvL1D2mtrZpPEkDYHvPKiledXV3JPevqAyJO841/yjkPlW9065S7tI5kPtDeuebuTo+g9PjePGkyyDSV1KD51NHQIAaeABSZ9K7NFCHY2pK6lFMBRyoL2kPBHEfWjYFZztNLm4SPooyaaCPY3SbwQS4kXjhccEi/iU862+lS8SdyzmRkAKSHnIh5MfXofUV5rCxBrVdnb1yEiBBljJaLP3gfaT49PUU4So5P5D03uQ5x7RsAtLw7VwkDwCSPxKwyKdAS6ZIwa2PnTMazZfV7nvEGEk39xqogrXX9sLi2aM9eXoazJiaNyrjcHBqkbRdo6NasKMDPOoJZordOOeRY182OKE3faSNcrZR8bfjfYfKtseGc+kJsMQ3gHG05VEXfJ6UI1PXnlBhsiUj5GTqfd5UCuLqe6k455Cx8ug+FIua7seCMdvsON9hHR9QbTb1JhkxnaQeY8/fXokciyxrJG3EjDII6ivLM1pex+qlJP2dOfCfFCx/wD2a1kr2YZ8drkjYZyCDSoMovuqMnAPuq1p8feiBfxYFcfqFpMzwOrPQ+z8PcaRbJjfh4j8ag7VXBg0ScICZJcRKB5naisSCOJEHJQBQfUV+ua7Z23OO3Bnf38hXAuzJO5WZ+W2FoVtxH+7VQffjehV1ifUoIgm0YMjDb4VPrGoztqVyUKheMgZHlQWG7n76aYOvE5xkr0FapHfDrYak9tfs+vpRHs+f+tYvs8bHfbyrLfWbyVwqOGboAtEuy1zdHtDbxzPtkgqVx0ofQpr4sP3o/tDn1qjMARV++/2h/fQ+flsd6EZQ6AcuRePhc7VHNngPgx8RVPX7iW1mVoWClsg5GaCvq14QR3in/hrRm6RpDnl3Y+YqNic/ux8xWZbWL3q6/Ko/wBtXh++B8KVio14zhDwfd86Ri34B8xVbS5zPYQSSyYYqc7461YdkP8Aen/VTM2NYtg+AfOokLd2PCPnTmKf4rfOol4OEAyN86Yh/iO/CPnUT8XEnhHPzp+Uz+8b51G5TiU8bc/OmIcxbooHxqNuPlwj/VStwfjb5moyU6Ow+JpkjULZccI5+dNPH+EfOuHAGbxPz8zTWKHq/wAzVIQ2Xj7s7D50uX/CvzpspTuyct+dITGRzbPxpgKOPPJfnTDx97kBQcedIxQMcFvzqPiQOM8fL1ooRLl+oX5moz3mDsvzpCU55b3b0xmQcuPHxpiFjMgQez+dI5k8k/OmoU4RkN+dNcxk8n/OihHScfEuy8/WkPedOH86bJwcS4VufrSNwZ9l/kaYC5f+H86YneZbHDz9aU93+FvkaYvDlvC3PyNFAS/aeafnTH4+A+z8jSeD8DfI0jhOA+BvkaAJMSea/I04d55r8jUQCEDwN8jS+D/Db5UASjj7zmvLyrc/RoYf+kUPA2HMTBlI9KwkcXeP4IHbA3wtbX6PLKS17SWsrIArqRkeorPJ+LBp8WzX9uLm5toikE7RpjOAB+teUX17eO54ruc+neEfpXq/b1cxk4z4a8qWyur677myt5JpCfZQZx7/ACp4KUbZMegPczzYOZZSfVzQeR72WYR20ly8rHCrGzEn4CvWtK+jl2UTa7dLCnMxRHJ+LcvlWhjvOz/ZqEx6VaxmXkWVcsT6sd6qWW9RVlK30eS6J2Y7Y3EozcXNhF1aeU5H/Dua2Aj0vQYuLXdZe9mAxwMQB8FH86yPaDtTr+qXc8URa3h4iPDt+dZ+PSy8nHeTPM56A5rRY73I9bH6SEVykzb3X0kJHOsOi2SpGGHjI6e6tDLd6hqWJJpzwNuAeWPQCvNZUFnb8cUCqMZ54/50+HWp0skjeaYxseSMVAHl5/nUT4+CM/taUTfTzafYtm6mVpOYXOT8hQjU+05eMpZ2oCHbMnl/lH8zWPN1GZysCL5d4cgZq+mSi8RyeprOjFP6K7xiVw5JJByVOw+VU9SjKXFs5AA4xjFWJHMU7hVd+LBxjkffWv02/wCz8OhLBeWplvWOFLDO/TB6UW7RXJto84uJCdWmYdXNN7ZRMlrDPjPCoB+VSXURS+mYA7udhRjW7b6z2efIyQBj5V20eo9nncfduveYAJr0LSE7rTIR6A153YxcRCnkDivTok4bZFHRa5M/VHneobtEbjFw4oHqYwxo7LtOD5ihGqL4jXgdTO2XygS6NfiA9zL+7bkfI12s2f24lQZR/IcjQlDsKNaZfgKI59x0NezXk8O/Bf0CQWMyd8pU56ivVm7W6fZxxxzE8XCDtXk1/MiwHLA55UP7QyyNLCwY4MS1LipPZalx6PXrntxpWPvn4UMk7caVvtJ8q8XeeQHBc1H3rHmTT9mIe6z1y77b6Zg8CSsfcKFSdtrM8reT5ivNS7HmTSE+tNYool5JHoE3a62flbv8xQq91+GYHEOPjWRLHzppc+dNQSJ5tlu+uhMx4VABqhTia7pVJUR2NxUkY+ykpg51JF7EnuoGitcD7PbzFT6VGBHOw6Lj5mnxRd44B8ifyqzpkXDAdvbcCtYLR6foV8WTauM2qqvRRWUZcNvWxv4uMOMZ6VlLlOB2HlVUdk15NF2W7L3F/arczHurd2JB6kVvtP0+CwgEVtGFHU9T76Xs2jRdnrCNVx9kDn371ew3C4ROIjfbfNZWckYRg3JEY2pjjIPup1/HdW2ntcC2ZmxkITjNZ2z1+WeBxdWxVuSsgwPjUuaQPIlou2xUxsicyMlueBWav1t2upQSBhjuCaM6WOO1UgkKueInrQjUTm4lAjfBO2OVSeRLsoyCBSOCXBzv4zT1FvgZlOf85pyMir4oj8VrjLHnaBj68NBJ679HoP8A9z3szw+1+y7XA/8AdLRuGXvSylSsi8wax/YLSWbsJ2cddTvIy2m2zcCuMLmJTgUfj06eNSY9YuceTKppLo64t0h2qy3CLwmzE0THG2+aSKLhCS/V/qx/CowT6Goe5vgCv7Q4x/FCP60L1q/vLNVjW7E1w+yRLBzPrvV0wba2wdG2dfnbGw46tdnreK71Rkn9ljVHSRNJdyPc477gPHgYGc0yCd7e47yJiGBrSr0VZqO0fZg2UJuISWTnisFdOTK2CQRtXoUXalbnSpbe7HjxgGvO7g8dw7AbEmpxqS0xWQlnI5n51wZuhPzripzsdqKRrhF26VoANEki/eYfGpYrqQbPgilvt5fcKrqM8qYBeFldAy7g1cm/2OD/ADGh1iCIh6miU4xaW++/EaBm67I6RaXOiQzXDNKmCSmMAHPnWgteGONpUcGyRfAhUDGKy/ZeNn02EuJTAFy/d+/yrXwLBPbgRZEQ24SMYrmnpgMe6UQC5nAi4hlEO/F76pS3M92kb6dETIGAdGYBQPOiUtjFNAIpCxVfZOdxSW2nwW7Bok8YHtNvUWkLQ+3mLytE8fA6jJB6+6vKvpFVLntIGeIgiMLhvea9bC+LibBboQOVeVfSGcdpjw/gWqx/kTLoZo1lb90B3EeDz2rZaBoGmywyt9WCPgniQlSKy2ip4RxE5rf9ndrSY/wmjIcwum6dDbW8bwKvecI3feq15a3M92B3bW/XvrU7n35ovaf7LD/lFAO0Op6pZECG24FZsI6HvOL0IxsamFtnTdI1NsoVFDMWIGMnmffT3Q5ypqpa3R+qLJdR9xtllY8vfU4uA6gx4KkbGs2nZFMrzKS24qzbrhaYoLtvirSLgUmVOWqFrsbYFLikZlRSWIA8zUmRWvzOLdvq0SyyHbhLcO3vobF9a0q0ke6klu3ZvCFBYIKN5BGQazXbHWDY2vcQSTx3MuysibfM/wAq0xpydAFLS8R7V51mW4AyfAMEDyxQHUtTjlGbJp4JOLLkY8XvqbSLRbbSFMtlK1w/MyNnJPXI5CqsVj+y7iWW/jUwzAgPEOIIT6VolFNmka7M9qF1311h2Mrj7+TkelMiuAk7DhPC++B0NavT4tKSLuLOBJpiN3mGM+8mguqWNxp0/G8cZVzlWQ8jWiyJ6BtrZagsppbX6wFAiJwCTjNQcIOx+NaPTv7dpkbXRhitEH7uMnOR5mh/cQXt2f2dG/crsTjbNJT+ylO+zrXU2sVjNpwqT4JIyNjjk38qZeXs0939YwIpMYym1GI9HjROKQbgUH1EoZSExtsaUWm9IUKvQPMkiTkl28ZyGzuGqYTzStxySO0g24id6glIkBjUEnz8qWNuTHmPCw9a1ossHLHJJPqaD9q7qGz0+H6zIkUUtxGjMxwAM70aUYqbR+z8XaG/ju9RhWTT7R8wow2kk/EfQVhmmoR/suMowfKXSIG7baCj8Au3IH3hC5X54q7adpdFuyBDqdqSejSBT8jWufRdOdcNZw49Bih952P0e6BzbBfdv+ua5OX6JXqsD7TRVV0kUNFIrqeqnNMeR09liPcaH3XYBYWMmlziNvIExn/0nH5UIuYNe0rIl76RB1lXjHzG9K0bQeLJ+Mv+QlqE0kuzMaDXAIBqJtcfGbi1Y+ZiPF+R3qv+17G5YpHcIJPwN4W+Ro7PQx45RXRBcneqUnOrVw4J2Iqo5qWjvx9EJ50009qo6tdiysZZj7QGFHmelKrNrK0P9q1eSTP2dsOBfLiPOhPbfT+9hS7Qbp4W91HNGtzbWEYk/ev4395p2rcB0+5D44e7Oc+6hLkx3QD7Ma9bposUMr8VxCTHwAjOOnOrVzrTsMJLbQj0bjb+lZzR7dItNiLonEw4yxA61djTvP3MfEPMDArphaVHz+SK5NoknvFlP2ss858t8fLlUDTsBiG34f8AMQP0q4LU48bY91OEKL0yaojSBMq3DIWd+FfJRimadpsmo3PdxZCr7cp34f8AnRMQPfXS20Jxn2j5Ctdp9hHZ2ywwJgDmepPmaiTfQN0UdN0m209MQRgMfac7s3vNXCoFWxATz2pfqqE+LJ9KEq6M27B6hpW4YRnzboKiuUCnuEPEx3dv5UTunEFue7AB5ACqEEPChLbs25NMEwLr8n1PSZ3TZ2HAvvO1Z/T7XjCr91AATRztSDNLaWycixkb4cqZDEIowo6fnTa8Fr7EVAFwOQoUo7rVYBy+1FGgMCqF7F/1hYuOsoBofQw9C/Cw6g8xXXumRzKWjAGeankaWEZkWiIONqQm6MdeRi2YJcL9mTgMfun/AOetFNN1m7sMLITdW4+6x8aj0PX40VvrKG9geOQe0MZrImK4sJXgfL92cFfMdCKYakeg2WqW17Hx2z8WPaU7MvvFWPrA8q8+hcORNbyMki8nXZh6H+ho3p+uYZYtR4UJ2EwHhPv8j+VFEuFGm78eVKZ1xVXYjY7V2KQqRJJKWrJ9s9Q4UWwibxyeKUjovl8a1RAjtri5l2hgQyOfQV5Sty17LNdS5EkjkkHp5D5UpPjG0dfosayZafgI6NYi8uhG+eADJx5UX0hv2ZqUunuT3ZOYyfI1N2Vt+C1eYjdzsfSm9qLfhSK8j2eM4J9K5Iq9nvv6D9dih2k6gl1AoZgJANxREsAMkjHvq0myboWuqhd6tZW3724jDeXFQ2TX55zw6bZyzfxcJx8zRVdsFb6NFioprqCAfayovpms48Ov3g8RSBD0JyfyqIdmruQ5nuDIf4jt8hS5R/sfH7YXuO0NrHkRHjas3eXrXM7yFJGLeS0THZy4RfA0XuG1VZ9PubY5liYL58xRysqKiumVopRtxRyL71otpkuJkeJxxqcjHMVSgHiG1EbeFWcFgD69acSmjfaXcCQgYwkymVB5H7y/Pf40TwFGTgAVnNMgnm7Pah9UkYXtoPrUG2eLGzLjrkVkbnULvUEDXFzLIjDPCTgfIV24MPuds+X9Vi4ZZRRudQ7RaZZ5UziaQf3cPjP9BWM1ztFczsWtLZYE/Ex4m+XIVSWMKMKAB6UpQMMEbV3Qwwj4OdRoDTySztxzSO7ebHNLGKllh4JGXmByrlXFdJokOUVKMjpTVHyqVRgUyqEwCKbxPGySxHEsZ4lPrUhFNK0hUehaffJf6UtynMr4h5HqK1HZaDvbuyUjOAGPyryns5fGzuZLY57q62UeT/8AOvbeyEGLpm6Rx4FcXqtKjjlH27NYxABJ5DegelNxQ3+pP/esQmfwrsKua9MYtOdY/wB5KRGnvO1VNaK6d2fEMe3hEY/nXnxRjFHn165Id/vMf1qFU4ECjpUk5451UbhRk0j8tq6aO1Mm0kA38anrmiOlRtH2uhPA2OLnjblQRZXgkV0OGXetDoWs9/qlrE8eGZsZzUST7RM7phTUdrh/fQuViZD5UV1Mf2p/fQ2VdjTiTB6Md2py00fCCcE1nHDDmD8q2l/ex6deCWSNpFI4cCoG7UWed7ST5CrdmttdEPZO3iezZ3jVmZuE8QztWX1WIR6rcxRgBRIQAOlb7Tb+K/h72CIxrxcO/Oshcw972muFPISFjUrsiL27NBp0RhsrdFAPCpz0qduPyX50yIr3UeWI2PI1x4P8RvmaoGIxf8K/OolL4Gy/OnfZ7+NvmajTgwRxNz8zTJYpL9QvzqOQv4ThefnSkR9Wb5mo34MDBfn5mmIcxk6BPmajIl/Cv51PaqjXCDxee5NWmY5PiPzouiWwWqy8TZA/Ok4ZT0HyNEyzeZ+dIWb8R+dOxWCZVl4CMD5GkCynGwx7jRUsfM/OmcRP3j86disElZsnYZ9xpjRzcY26fhNFyx8zTHY59o/OmKwX3c2eQ/0mm93MdiMf8JokSejH51xY9WPzp2AKSOUpuDt/Ca7u5ug/9Jonk49rakyfOixAmSObK7Z3/CaUxy53H/pNFD6k0wnfrRYAwxS+R/0mo+CRWbO3vU0XHstVDVHSKNGkBK56CnYiDDfiX5U11bgPiHLyqKKaGX2EYkelSOF4D9keXlTGOAYgeIcvKuHF+IfKmgLgfZHl5UoUFgFhYknAAXJNAEtvPNbTq8UgVseVafshrMkWv2zXLgx5J4VXrjpUGndj5J41m1CZLNSNoyvE/wARyFBtcjk0Xv2gdcxKe7cLgnPnSUVPR0YsEsjp9HpHaXXtOccWqzooA2gQ7n30E0XtrDJPLb6RZxxIq+Hbc/AV4vc6081ysrqzqR4w7b8XoaMaRd6lIVnsEWziz7f4v61osMIxo7Z4cWKFM9Yurq7vCWvbjgB+6T/Kg2oa1pGnA95IZph91fEf6CsvdXdzLHiWZjnnjYGs/eEDOBUrGkef7ldFrtD2he/uGa1gW3B2yTxE+vkKg0PUVtpZfrBd++ThLg7r60HlbflVmz4iUCKoY53YZqpfiCySk1bNNqLPdQwpwu8bj2lHSq8lvAsbQRjBY7DOQKhimmkQI5IEa4XJzXJOFmVn9r31gb39jnbuuBmARieEr+KpI3EU7Im6nc9cGheslzeKQSdgRTRevGp4PC/UHekLlQXnMrkCJlVepIyajsbhprhYmHEElGHAxVOzke9jlgd8SsMg/wAql0GzlS+SRseB8MtUuyotuSoZqZH1iUjYkmjF5gaesW+4GfkKz+sSl76QdOLH51opgOLh5YAx16V2eT1r2eYxJ3GsmEHnICPnXsnZ7RX1icwRuI8LksRXlupWZj7UW2P7yRR+dez6RqEWg3CuRxk7Mo54rj9TfSPO9T+QC7U6FPoV1BHPIkhZcgrWW1VeZrZ9utXh1m/jntixiVeEcQxg1kdRGUz6V4WRVM68LbxqwbbWqyqv28asfunnUyW0Zk7sXMfFy61DaWspkWYfug+DUKng1MHP369fG+UUzx8i4yaLrW8IbD3aDGx5069vLfjjTaZUQLxVHJYQyTuz3KoSc4NJ+zbYje9QVRJC15ZbZtQT76T69ZjlZrU50qyx/t6Vw0uxA3vlz6Yp6DZXOoWh/wDYkqN722ycWUfzq3+zbAc70H5VFLY2IHhuxRoWylJdQsPDbItVJXVuSgVbmt7Zc8FzxfCqbov3WzTRLYykxvS4riKYhvuqaL2X91RgVLANnz5UDRf0SzlvLl0gjaRxGxwozV62spYJYYZFKtxksDWh+iOHjv7+THswhfma28fZuzk1MzTF5GYFsZwBVRmo6Z6Ppcyxxpnlt7GFMgHrWMvIyZip3JOK931Tsrpzh+HvUPo+a831Tsr3OoRPDPxr3yjhZdzvVc00dMs8ZGqsp5LTurdkYxBFUbeQq9dSyLaO1sp7zmBnh399WpVjCkyYVV3ydsVg+0ptheGW0vnlWT241clQR6/yrmk6OaXxT2Sa52h1u6EtpqUcfcSKAE28ODzBG+aCxSvG2x+e9RLGkQ4w3GW5nnTtsVg3bOc0OinOmx8ZwnEcjzNU9V75btzhBsDjFXtBHBp6M+SeI8A/5VT1mFzd5MpXKjYYrpXRyS7B5M8qbBMeRzSqLgDAEXzNKYnRCRM23upirK4z3zD0wKCT6D+jTTrJ/oz7JTTwKzto9mCcH/BTyo/cWOnWFs7yQjgIwTjJ+dC/oxmjg+ivslJMwSNdGsyWPIfYJSz3Nz2gd4NPLxWPJ5GGzf8Az5Vzxs0T0MeaxltGttMtzMzAniZdz656AedZxNNaAm5lQs7ZAfGwHktbYpDolgBDbtIG2Z+RPv8AKs7f37zRNEu0I9lDuVHvrbFd2aQvswWn/wC2XR/hP61SJBOavaZ/tF22M+H+Zqk+xPWuldmnkgkGFY8sCh6AE7miN1/s7Eg0PUctqYMVULEbdaI4xyqnE3FKoPOrbcQU8qYAy4JMz++mjanNkuSeeaVUyaBBG0GIV88VfnP9lt9vOqieFAB061buv9lt8+RooZ6J2bubKGwtZC7I3chGAX2vWtDbNE8QeFsx+tYjR+BbO24+Lg4ATw8611heQTkRRd4SBvx4rmyQ8oAgK6qj3kEbSI0qRso+9yodpGui7EiSQyu0ZIaaGMmNvUGs+DasTdByvKO3ZD9p3I/Cor0mK/Nw4FpF3yH74PCB7815h22LHtPN3gwdtuLNXiVSJm9BDSvYFbrs9/sMp/hNYHST9mMVv+z3+wS/5TSynP5L9ttBGP4RTb2aKC2d52IQDoMn4etcGKxIVIIUDiA3NUNTvu6sLmWC4jd1UkKSEZfd61EYts6fAPjvbC57qynutQ7+Zsp9YQr7ugBozclBAbZ5lM4Hh+6c9K8vuO0moagsEN06O0cgZZOHDA++iOs6jKIo3Nx3knLizk11S9O7REZas9F003ScS3r94CNmXBA99SaNHHDblYrjvV4idxjG/LevPOzWvSWNtcK+ZHkYMrE8jR6fVl1OxVIw8UykElTtWM8TToEuRpxeq180ImiUL90jc/GnQuks06lZMIwGGOVJ9KzFn3ir3XEoD7EsB+tFLW2MUTQx3Qwx4mK7ms5RSL9sLCeOQkAk4642ql9b06/JjcwyNG2OGQDIPpmo7meOKyZAeLhXAwMZNVYkhaOO4t7KNpcYbIxipSVWHAqajOLS8f6ozKRtwZ2+XlVOFZ2VizvwNzXO3yo2GjMcjNEomf2hjlXRxxBAApqudKjWMAFJb4FGbOOH6ipilDFPFwyYJBpZbZDGSPaPIVPJaq1hwmJTIi7e+p5WKcQFq8QN+iQxxtHckMOAbqetbDSoJILZYnaIlR9xcbUBtLm0uLdrWSVIn2Zc7YYf86IjV4GtxG8pF0MrgDfiFXJNqjmlfRc1J/7O4ideMD2c7159PdIt4wZ8qdjjpV7U4Lx5w2oyGBX3Vc4z8ajFrEYykYUqeo3rbHFRRcURpPCAFQn/AEmnStwNxBGYEYbApLR2BaGX94n5jzqw5CIzNyAqm62Wtj9Pt5dQuI7RAVZt5D+FPOvRrWCO2t44YVCxoMACg3ZLTTZWPfTD+0T+I5+6Ogo7XnzlzlyOXNO3xXSOrq6uqTA6uO+x5V1dQBn+0HZqzv4JJIUEN0ASHTbJ9R1rym8s4blWju4EdlODkbg17tXkfaK0Nrr19H91m419xpNKj2f4rPLk4NmEvdLvrJ+80u4LxjnDK2fkf61Wi17hfuryNoJx91hjPu861Uy0M1Cxt7yIx3MSSKfMcqnaPo4yT7KX7YtQPHKo99Brm7XWNatIEz9WjPG2euKGa7o13pWZbWQ3Fp+CQ+JfjVPSL0xcdxwlHc8IDdAP+dDejTiuz0VpBQftK7SaTcQxMFlmXulPkTtXaGupa2eHTrKafGxcDCD3sdqPnsZM7RPqur2NrwNxd1GDK2fU7CnHb0cHqPWY8acb2YnSNDjsYYxc3E13KoA4pW8Ix5LyotkdK1R7PaKg+01u7c/wW6iqVzounKD9W1G9Y/xwJ/WtoprweQ8vJmfNRpDcXdylnp8LT3cnsov3R5k9BRKTSJCwC3YEfU91hv1xRWyVNPt2hsgYlf23zl3/AMzfyqm2+gbFsNCj0cCNpFmuWGZZByz5D0q/jamwj7Nc0+pSozbb7EppNOPrTWpgUrrxyKh5DemOQiEscAVO48bGgHaO5Z+Gwgb7SUZkI+4nX500vI/0DVl+uXUt0RhCeCP/ACjr8an4adHGEUKowoGAKeFoL6IwKq3y4ltG6LMKIcNV9RiL2rFfaQhx8DTGF9MtxPKeL2VFX5LJ1/dtkeRqPQCrpIRjfBFFsbVBDlsCPxxHEisB51S1WxW+tDcWyg3NuMsBzePqMeY51qGRWGGAIqH6mqOJIfBIpyDTsLMI1gXVZYW4XIyGXr7/ADqF2aPwXcfBnbixlT/T41tpez80qyTaWveEZaS0B8Q82j8x/D0oRwg8SsCCNmVhgg+RFCZSmmDtO1CTTsK5aWy8huY/UeY9K1MMiTRo8TB0cZVlOQazMumoGLW7tCT0G6/Ku0mS+0q4bgWKS3bLcOSAreYHl6Uwa8oOfSHcrZ6Pb6NbnM0+JrkjoPurXmUad1fBWyFk/UVrLxpLiaSadi8rnLMepoDrNoxhMsQPFGeMY9KJq1xRt6SXtSTNzYRrFbRonsgDHrS3cInt5ImGQwIqj2duhdaZC4OSBiiprkXR76dnm0ZvvrZto4lidX4DJI35gCtbb9nlZVN9dzzt1VW4F+Qqh2jgNvqCTpgCT9RWos5O9tYpPxKDQ1sp6RXttKsbb9zaQqfPhyfmavKAo2AA9K6lppJEN2LTlpvWnCgRIopxjVxhgCPI0i1Iopohgm70SNyXt/s28uhqrHbSW78Mq4PnWlWlaJZV4WGaa0NZWuxmgXP1O5jlA4gNmXzHUVnu02kjR9WItgx027zLav0X8UZ9R09KOrCYH816UQe3i1TTpNOuW4VchopD/dSDkw/nXTinwdo5PV4VkXOPZgQtO4fSp5YJbeeSC4TgmibgdfI/0pwTavUUrVo8hoF3kWHDeYqDg22FF7uLiiz1FUCoA3wB61onoa6IkWpAtE9L0HVNTI+oWFxMD95UIX5natbp/wBGGszANey21oh6FuNvkNvzrKefHHtkSywj2zAEbb7Vb0/R7/UWxaW7svWRvCg+Ne06D9HekaYyzXQa+nXfMwHAD6L/AFqO8K/WZeBQqhiAAMACsH6rlqJl76f4mN0Tshb2TJNeuLi5Uhlxsqn0r03spFw20sh+82KzbDNbDR1FtpEbPsMFzXLlk32Y5ZNoinAutchTnHbL3h/zHYUM7bS/Z28WepY0W0NC0Mt1JnjuXL7/AIeQrLds5u81Exqd1UJ/WogrkTD8jOxLxBn/ABH8qRvfU7LhQo5CoXHzrpR0WQSDO9Wez4C67Zf7wVXbmasaGf8ArqzP/iiiS0DejXantct76HzcvSiOrD+1P76HyYxWUSY9GQ7VqAFJ58VZWQCtZ2qH2an+Ksq9bVo2NX2S20v3SmqckIGtXrnmWwPlVvsgc6e/pL/KuvwBqc/qc/lUJfIyT+TLEGe6ThxzPOnt3n8P51HDjuo+LPM8s0rcHk/51VDE+0/h/OoQXwfZ5+tPYp5P+dQjgIOQ+c+tNIkX7QnYr+dRy95gZ4eY86d4QDs/51DKE4eT8/WmA+SWWFS6gM4BwF55oUdSt0JWTVLrvBs2Ixz+VEZUR1YfaDIxkZzQqPR7ZJVcG4LA53/+lJokcdUtsb6je/8Alf8AKmnVLfP/AGhff+V/yqC7J7zn9+g1/e3Md06RuAo5eEGnRIebUrf/AL/f/wDl/wDKm/tKDpfX/wD5dZo6hedZF/0Ck/aN3/iL/oFAGkbUYP8Avuof+XUbajAR/t2oZ/3dZ8393g/aLj/IKb9euusif6BTJ2aI38OcG91AH/d0w30H/e9R/wBBoXrM8yNE0L8LFRk4z0oZ9bvP8X/0igVs0pvYP+96j/oNNN7B/wB61H/QazZvL3/G/wDSKb9cvv8AG/8ASKBWzSm8g/73qJ/4DTRdQH/2rUBk8yprNG7vSP33/pFWdNmnmmdZZmZVUtgACmFs2tnbmF2+3llDL99s4qv2gH9iBzjDDeiEHsof4Kpa8ubA5GdxtTGBdLDd8cOOXlRRlPCfGPlQzTABNju+npW77L9kZ9XAuLlPqth1kYDif/KP50nJRWwsB6RpV7qk6w2S8bAZZseFB5k9KMXmp6V2NcQ8YvNTI8cgHsei+Xv51p+0l7b6L2cuLDs5EkcvBsRzY+ZPU14lZ6fcXt01zfFiSctxncn1q8Mee5Hf6PDGVymbS67TNeEy2jMIzvgnketUdTlbVNMldjkkFdvQVVhhEZlAThBGfean0lc2EynlxkV0Uq0ejFxaTieaEFXIJ64r0TT14NItBt7HzrDX8IS+lXHJjW7tUK6Xa7YPdipZxev6RFMfCdsUFvc4OKMzZ4aD3o2PKkeYB2J4qv2RVCrMAffVGTAbcZq5b8OE4jhc0pdFx7CmMjr86heLvMd4uMVOEcAMBsRkU9LK+u1LWlvJNw7twLkCuVuuzpbKRBMpPIKMAmqU5w4JCuOvrRBlPERJEyg/iHX1qK+gKwoSEUk4wKCXtFnTr0SBYYoFibqy8gPOiGjAXfaFLa18XenxFjsT6Vm1iZSVI6Z2NaDsCQvaiy2ySxGfhTsak0EL3sdMbssbmPJfJXhPnW4uND06BULW6MwA4mYk52qvNxG7wSfa33onrWVZhnoNqpzb7NPelLtmT+kHR9Me4sLy0jVJISu6HA+NC5iSSSSaK9onA01RjfvVoQWOKiSMpO2UZMmF89GqrejMIPpV6QfvR7jVScZg2ryfUKpnpend40AVlZLuNVJCltxTbg4vyf4664GLlD60288N2x65Fej6Z3jR5fqFWRiaoCLx8cjvVE5ohqi/2ji81Bqlj0rdHO+xgOBS867FKKYhQKQiuzXZpAMIpvWnmmmgBtcRg8qcBk06RcYoGiKpofve6o8ZqWEbt7qCkeofQ1bZstSnP3mVM+7et9bLm6kONgoFZb6KLfuuyTyY3llY/LathaJwxzMdyWxUPs6Y6oH3y5DY8qwWqyxx6hb96eFRMCT7q9Bvdo2xua8y7YssFzb8TAEsSds9KfSLuirq+om8LpEoMHFt3i9fPFC3gExVpCjBRjA2pBdW/ds0juxH3FG9UxqMIuCUJCMvIjka53smUr7Lrxxd3whRwrvwgUGmaHJLcfAScYODU2pamkyKLVXjOMMSd8+lVLKWON17xHZgwIdW3UddutKjNyNT2bnWazzxGSUNwqWOSB76g15bdbhe8Klypyas9mU7pLoBSA78Q4xjANLr4WOSIRxswGRletbx6OaXYAjjt2X7QqT0zThDaAfd+ZqTvsqQIXPTYUyMlVx3MvypkHr/ANHGn6j2g7AdlkvZHtdMh0y1WONDgy4iUZPpW0sLO9065PcxF4l2wWABFUfosdf/ALmnZNcgn9j2mfT7FK0xjiuI3jcgr13rBNo6EqQFvdalMksYjXuyOEo++D7xQoadPLbzOF4QqFsvsD8a0MVpb3UEka2wMibCQDhBNWbte50iZVRVZYzxIDkDar51pD5V0eOaZs14f4RVJhjJxmrlhnu75vdVQ5PnXUjQp3hPc4G2TVAE++iF6chV5dao9OWKoTGHc5G1J4icANVyxG7EGrXWihA+OGRgPAatwQBDlzk1YAINIeZ22p0NCD8qtXnht7f/ACmq43FWL0ZW3X+A0eQs1OizpPp0BT7qhT76Ixs0bhkJVh1FAYc6W8bYP1eVRnH3Tii13xPaMYnxkZBB6VMl5EpfY3UQXgZePDP+dE+zUmpEwxSlY7SMY4UQDPvpvZrSHuESS4yyryzWwjtViUBVArlyZfCJ5Ju2Drt4bMPOyZBG45V5B2nu4bntDI9upSNuQNesdp42ayYLua8V1BSNZIfII51WBeScjNXpQIRcV6BoWBpcxPLgOSKwGl/u1wa32kDOi3HTwEflSymK7BFnqFtbNx6WzujfvFlyd6Edqrgz28svCFLkbCqtlG9rckIjuh2J6VZ1xc2BUDcsOlb40k0dF3Ex8a4YH1q/b2sl7cqkQyTyycU+G1JIOKP6dpuLYycGWPKtsuRJWiIQbI30W6tIkkkiAjzgEEH9Kv2CSRqW4Ac7VPa2jjKOWx0XNEILTDDJ2FcLmdEYCwQHAL7tV2DMSkIBvSqlPC1k5WbKIpcEIpJ8iKagWFiE4sHpnlTuHeuxUWOiIJ4smpQNqUV1FjEzgg88UlxcoioeLfOTvikkOKoXCx5LSEMfKqikyZC6vHa3ISaBFLYySKzt6Ab+Pu2MZOPF5HpRaR7fiDrcBPNaG3aWwkYh3bPIqcgV1QVI5ZoKXbXV1YpBcSiYqcgsKSGIQxBUVR5hRgVUsr0OoiJ+1Xbfk1TtPKjASIUBOBgZp1WgTRX1KMrw3ER+0Tn6iiPZuEavqMW2YYftJB69BUF0yR20kkpHAqkk1quxNgLLRI5GXhluPtWzzGeQ+VYZ51HivIpvhFyRoOVdXV1cpwnV1dXUAdXV1dQB1efdv4eDVopcfvI8fKvQax30jRf2W0nH3ZOE/EU0r0dnoZ8c6PP5RzqlMOZq9cMFUliAPM0Odbi4PDbpwp/iyDA+A61KR9M80ca2wbq0im2aIL3kkgKqgGSaqdnOy1rarHPq8ZuZVHhtw2EH+Y8z7q0dtYw2uWHjlPtSMdz/AEqQ48x86v20+zgzerlk0tImnv7iWNYlIhgUYWKIcKge4VTIPU1IaaeVapM5NIZikNLTTQAhpKWu+8KBl9NkFKaQYxS5xSIENMp2RUU8scETSSsAooSEVb+4W1geRhk8lUdT0FZy3hYNJNMeKeU8Tt/Iegq5cTPdzd5IOFR7KeX/ADpoU02aRVEYFOAp/DShaBnRR95IiZA4iBk9KI61pS6c0aCYSiRcn0qrJKZEjUqoCDAwOdVbucgYJJY+Z5UJE7sl0a4FvMFz4VPCfdWoBBGRWJKtbokxOzHcennWs0uXvrRTnONqTFL7LY504UlKKCSSKV4ZVkjYq6nIIoxPBpPaNFF+Pq2oAYWZNi38j7jQXG1NdeIYNKk+yZR5AvX9CvNEf+1Lx2xOEuEHhPofI0GkStvZ63c2qNbXKrdWpHC0UozkUI1bR7d0a60Es8ftSWLfvIx5ofvD0prRUZSWpGWljqpNHkEHlRPwyJxIQQetV5o8Kao2TBvY6Q29xd2DH922V93MVraxIY2XaWzuOUUw7p/f0rbVzTVSPc9PPnjTBPaODvdNdx7UZ4xU3Z6XvNMj3zw7VcnhE0TRtyYYNB+yzFBc2zc42x8qhnT4D1LSUopkiinrTKcKAJVp6mo1p60EMsJUyDeqyGrCGmZSJSgZcGokzG2DyqZDTpEDKfOqi6IUqKnaW1F7p4v4xm4tlCy4+9H0PvH6Vn9Psbq/k4LOCSZvJBmtTY3XczjjUMnssp5MDzFei6ObS20BxZRoiRoThQBt0/8An0rqjnlCNI8v1sfZfJLTPN9P7EXtxaie7kjt4WB29pjR3R+zOlWBDpbrLKPvy+L5A7CtdwcGiwDG/d5+dCUJIwMCollnLtnDCbkma60AFrEAABwjYU6b2PjTLE5tIj/CKkm/dmsThfZDcNwQyMegNYaQ5Ynz3rY6u/d6fMfMYrGPzrfEjbH0IF4nUDqcVq9TytlBaR+3MRHt5dazmmR97fwL04hWkg/tOrSy847cd2v+Y8zRk7CQQRVijVF2VRge6vNtSl+s6rcy9A5Ar0DU7hbWwnmY+ypx7684UFVyebHJ99PEu2PF5Y1x51Xk61O5qBxmt0bIhYbb1No641a0I/xV/Wo2zjc7VNpf/adrjl3i/rTfQ29Gu1hf7W2/WhzrhSCc0V1j/am260KmOAawj0TB6Mp2oXKbHrWXcc81qO0m6n3is4y5O9dCWjZmh7HgmzmA6SD9KfqOBqUufSpuxkebW52++Kj1VcalL8KzX5MyT+Q+Anuk4SPaPP3VIePzX5GoYQO5XiBPi6e6nlU/A3yNVQxrd5/D8jUSh8NgqN/KnkIPuNj3GogFy3gbnTQjsPvgr8jUcokAJLLj3GlYKP7tvlUUoThP2bfKnQh7h+hX5VH49t1x7q5gvSNvlUbBRyib5UEsE3o+0P8AnoLfKDdyUfvU3P8AnoJfDF3J8KdCRTEfoDTWiHkKsgZ5cqRlp0Mq8GF5Uzg61YI54phG2aKJLWprxdyD+EfpVIRb+lEdQGTAR+AfpVdV3oolFZoRnlSPBtV103BNcybU6GDWjwp2p+kD+0yY6xtU0qngY12jJm7IPVG/SlRLNtbbxxf5P5VX1eN5bIpGrM5IChRkk1c02CW5EEUCF5GXAUe6tBNdab2WtjNO6zagBseYQ/wj+dG3pGmPFLI6id2L7Dx2MI1LtERxYytr5f5/6UW1vXpLthb2I4Ih4fDsAKyGj9pLvX5poZZDGhbKDz9KvajqMWmxNDaKJLnqeie/zPpUvE4vfZtLD7L+RNcG209RNeyAu3srnc+4Vl9Tu0vLkyKEiHQLj5n1qKWeW4k72fMkjc2Yioznl3Y+YrRKjGWRvSGggcXjLeGnaP44JRnnIf0pjbE8ShRwmotFkIjlwf7w/pXRH8T1/Sf9JGa1+Hu9VcADBOa2IUCygGf7tdvhWY7TRg3SPyPnWslUfVockewv6UpeDn/kP9IMnHhzQe9xvRqYA5wKD3wwDgb0jzQO2MnNXLMA8Odxmh11xZ2olonDJPGj8iamXRUew/pkcTTxq8jGMkArj2RXqj9o9D0XTfq9gySSKnsIOZ9a81t41i4wgJB5VWm/f5wVc8x6VyygpdnU42LeSPdTSSYUd4xYjyodfwrKMByZVGQvQ1dPFnCAADqacwIXi4QzgVVBQItmkkyGizw825Yoz2M4V7S2Bj9lpP5VUSM/V27w8LOSSuau9jIo/wDpXp4XYq5OPhQJ6RupgPr4HXiGfnRTtACHO3Sh9ww/aQUDkw3+NEu0OeI55UkSjD9o3xZxA9ZRQziol2lGY7dRy7yh4THOiRL7IiOJm/y1SIzEwq/gCQY6g1TA2cGvM9Uvkel6R3Az16OGQHyaor9gLlsg8gataku599UdQ3nBzzUV1+j3Cjh9YqnZLqLZ7k+aCqeas3WSkJ/hqtiutI5GNpKfim06FQlKK7Ndiih0J1pDTvfSEUUFCINxT7kYIxSJzFPuOa1NDIR61LFsT7qj51at7dpELIQSNsUdFRVs9x7EQ/VexenLj2wXPxNHrds2gPmc1S06HuOzmnQnZlt12+FXlUpaxrscLWZ0opXI8Jzv7q8n7ft/1nbxhclUZz6V61MfCdq8p7ZMr67PxAkJGq7etEuhy6Me+GcvjxHrVJ0K5LVfu2SNiEIyByFUnkLrggZrGjFkloQAwOBjflmlPELqMx4LdAAarhmXkcZonoFndX07Rwtwwn945Gw93rTSsnlS2aHs68syzo86SYILumcj0JNP18ylICiKqgkAnrRGKytrCIRoAkYXcDmx9fOqGvCR7eNpWMS8XhT+tapGEnbsBRrKpJ8GT76TvJugT5mkUFmI744HUGniDba4aqJPavottGj+jzsvO9x3JOlWpXbIwYV51pdNkmF7KrxrMrH9/G2wHqKH/ReQPox7JZxgaRaZz/uUozbz2a3RSLAdtyw5Vgm2jqXQReIyAFiwxy4TiqV+iwaTecII+zYnJznaiKHYYbIod2hkQaLe55903SoXZOzyKx/2O8PqP0qjyNXrYY025I6vVBiOXWu9I0KN6ftPdVcjfy99WJstIxGNtq5YwxwwqhC2ijuzjqasIMDelijVEAAqVcAetMBma4Uh3pFFMBwxkgirV0MyWy/wVUA33okVzqNmvCTlRt570mBqJYY5bMRykBSoG/SqWmRvFdrZXGWiJyjii/aG1l0zT1lkEZLnAXOSvwrKw3cq3CyMxJBzWSlaMpu+j2bTbVYbVFUbYqw6YrM6B2ot3gSO4YBgMb1d1btFa29sWVwW8q43ildGSbBXbG7WKHgB3NePXoLayxY5brWn1bV21G9JJ8PSs1KOLVSfdXesXtxQcrZqNLXCLit9YbaDcf7s/pWJ0yPwL0rcWoxosw80NcuVjjGzC2c08ad2p8NEmR7m0IkG4NLb2mSNqKw22I8E/Cm50dUYAm2sc9K0FtAI4lXyFLBAAOVXAu1ZTyWbQjRXEADcQ51Mi4+NPxS4rJs0oTFLiurqQHV1dXUgOrjXVxoAa1Qyqp5gVM1QSVpETB95awyjDBVPQ4qncWCfVeBPCRvkUTdtyTVNy/ES7jh6DFdULOeSARiVCODibB3YDmKNRbIpViwxsSc01AFcoQOE7imWwMMrQE+H2k93lWnZmtEWsz26/VIbyRYreSUGViceBdzR9PpF7OowjF4oA2BxtWJ7e2Zn0lLhNzbvxMP4TzrG28ewxuKwnBN20ejg9Liz47l4PfrHtfo14PsL2J/caLwX1tOPspkb4187R20ZOTGpbzxvRO0ubq2x9XuZVx0ZuIfnWTxoif8AGY/9LPfwQeRpa8o0TtXfJKkLiR3JwO7BfP8Aw8xW/szqd7CpnVbJDzx4nP8AIVhKk6PNz+meF7YSuLqG3AMrgE8hzJ9wqo9/cP8A7PZuR+KVgg+XOrNtZw254kUtIebseJj8TSyjc0jBUCZZdTY+Ke3hHkiFj8yf5UL1Oye/hMV9d3E0ec8IIUfkKOzLVGZaaNouujMtoGnp/cFj5s5P86gl0mxB/wBljPvyaPzKTsASaxXa3tbZaKXhUi4uwN0U7J7z/KrhCzoxxyZZVHbJ7yz063jZ5YLeNBzLAAVl7/WdJhyLWzSdvPh4VrHar2nutQk7ybfqF6D4UJk1Sc8uEfCr5QiejD+OytfJmlvtTkuSQsUMC+US4/Oq0F3PEfDNL/qJrPpqE7zRJkeNwvKjf1d+kp+IFUpcuiMuD2XxYVg1qdCBKqyr8monbanbXBCq/BIfuPsay/cy/jU/DFdwSciit7jTMeJtRypB7QrN2OoXFuQCGeP8LH9DReLU7V8cUndt1D7Uq+hbDYO1NZqGy6zZRL+9Mh8owWoVdavc3J4LVPq6nbjbdvgOQo412TTfQcu7+K1wGPFIfZjXmaFzyy3Th5sDHsoOS/8AOo7eARDOS0je07HJPxqbFIaVEeKUCn4rsUFDcU4LS4prtvwoC7+QoAjuJVhXzY8hVa0hNxLxP7I5+tW1sSzcdw2T5CrUcYAwgCgUNgVNQQFF22HSrPZmYpJJbMdscSe7yp0sfEhU0PBktbhJEyHQ5Hr6UeBdo19KKigmWeFJIz4WGRUgNSZjxS00GloArXS4w1Qo7IwZCVYHIIOCKs3O6VVplor6nbG6Zrm2QC75yIuwnHnjo/r1oMeGWLjTl6jBB8iPOtDQvWY+5Y3ig8LbTgfk/wDWga0ZTtBCWsHkT95CRKvwNanTpxc2MEynIdAaGzRLJGynBVhj51D2KlP7OktXPjtpGj+Gdqzyrpnq+hn3E0IoHD/Ze08q8knTiHvo7igHaUGC9sLoHGH4D8ay7R6JoqSuUhkVhyIyKWgDqcKaKWgB6mng7VGKE6t2j07TG7uWbvLjpDF4m/5VUYtmcmkH0PlSyXcEC5mmjQD8TAV59c69qd+SIsWcPQDdyP5VVSBZG4pS0r/ikPFWixkPfZ6A3aTSojg3asf4AWqSLtRpRO87L742H8qxMMYUYUAe4VZRa0WJEtRNdLqNlcMHtbmNz5A71oez2ruLSa3ySCOHH8JP8q80EKP7SqfXFEtJun0+5jkUs8anxIx5jqM03jfgyzQjkxuDPf8AUE4LJF8owKz0fOr+k3j6h2XtLl1YF4zgHngHA/Sh8YwTnNZJHz2JUmjXadvZRe6pZv3ZqDSv9gh91WJv3ZqDjfYF7SPw2QX8TCssxo/2ofJhTyyaAGunGtG8ei7ozCO4knI2iQsPf0rTabCYLNFb943jf3ms7ocXfTiLHhLBn9w6fOtW7BEZm2AGTWeR7Jn9Gb7YTlo47ZDt7b/yFZY0a1lmkhWZ8hrhy4/yjYUEat8a0aR6ohfrUXmDyqVhULVoUMfAFP07bULf/eL+tRv+VPsT/bYPRx+tN9DfRtta2uWoROdqL65/tJoPPyrngEOjL9oRlfiKBOmOVH+0AwlB8ZIzXSujRmo7ERZtrrHQg1T1fbVJNugoz2CTihvR7jQrWl/60k9wrFfmzFP5EUQPdDhIB4v5U5g+PaX5U2IDud1yOPlSsF/wz8q0LGMH/EvyqJQ2X8Q5+VOcKDvGflUYChm+yOPdQBzB8+2v+mopQ3AcuvyqUhT/AHR+QqGbh4T9kfkKols48WPbX5VGeL/EXb0p2VxjuTj3CmHhB/c/kKaRJQvc5by4qB6hj67IPdWgv12Y8txQHVBjUH8sCmJEKCnMuB61yUrHmKKGV2HOoyvlU7DIqNqYi3fDItj/AAD9Kg+8AOVXL0YitD/B/Kqx9taCV0LIu42p3BlTmpJoJo1V5IpUQ8maMgH4kV3ECnrRpjuyk6ZVxRjsV2cvdZ1AG2j4bdMiSdtkT49T6Ve7Mdmn1bivL6Q2ulIfFKdmkP4U/rWtu9aSO1i0zQYvq9pGOFQvM+pPn61DblpAouTBPartDY9kk/ZWk/bXPAA8v3mPr6elefqbvU5jdajKTk5w3QVs9W7PwT8N1cOFuxy2zxf/AD51TkskhspSwDPwnHkK2hKMY6PRj6iGCFJbBtlcIWEUTcKj7w2J91XCRnHen5ihmms31j2ennRUl/wj51Nt9nBPJLI7kRKV4B9qfmKcrKGyZM/GujLcA8A+dPVnB9gfOgldkM6AnKsSpBol2B0xNQS771yqpJyHM7US7KwpLeyNNEjFUyobfBrS6NFGs9z3cYTLb4GM0pZGo8UehHM1BRRn+0HZjT3gy0UhIPtBzmhF7EEQKBgKoG9bjVVzEwFYvUVw555oxtvs5c7bqwPIBg+VAdSZ8kIPjR+ceE0FvhzrYwM+7MCQ21ENJwJozufEPjVGd14jtkirmmEGROY3G4pPocezaZHdfZYBxlQdqpXUUs8cbjhjZDkmpuCKKTiaTxY24m6Us4aRRiTCHGfWsDs7IjDH3OZGJYjOxxQSW5WC5zbjMYGCCTvRy5yxaKONmYD2gNhWduYTHccEgKe+kTMI21yzw8TDhYHb1FG+xp4+1FmzYLeL9KzbToiYjBOB5UX+j2Q3Pa+14j7AY4HTajwJy8G7kB/a3Q5cfrRbX93K+tU+7B1SPAH7wfrVntDIFmw2OfnUoSMV2jHC9so38RNUhuKv9oMGS2IwRk8qpFW/Cx9ymmxEL7SKR51SYYmcURdTgfZyZ/yH+lVJIpDcnhilI/3bf0rh9VBt2js9LNJNMA6ivtUJujl1PpWi1CzuGzw28590Tf0oQ+mX8mOCxuzjyhb+laejTimmY+s+TTRXlOYYvQYqGii6LqskSBNNvCQeXcmpR2Y1tuWl3Q/zKB/Ou7Rx8JAY0w71oF7Ia83LTZR72X+tcex+vA4/Zsnwdf60Wh8JfRn8UtaAdje0GM/syXH+df605exmvty01/i6f1otD4S+jO/Cu5Vpl7DdomzjTm/8xP60jdie0K5/6tc48pFP86XJC4S+jMgbipJgdqOv2Q19Pa0y4+GD/Oq0+harCPttOu1Hn3RI/KlaDgwVBCz+Lhymd6LWqIJ4VERXjYL60tvbtagiQOAejoR+tFdDhS517T7fZmaZcD0zWUnbNYxpHsl2hWFFxgLGq/kKll2VQDtilvvHOV/jqjqLMjbEgUJWbR2dMwweWa8S7V3xHaG/Ee5EvCQeWAK9g79GQ4YAjnvXgmrzCbVLyRc5aZyTn1qnG0TkdIhkbvJC2AuT0qKmliRjrRjQNGl1OXbIt1Pikxz9BUOBzN0RaRpU+pS4RWEIPjkxsPQetehaZZx2NssUSAADarFpapawrDAgSNRgAU92CKWYgKu5NNKjNuyncSFbpQE4mCFsUH1oRGyDSktIWBxjIUeQq+k8txfF0j4YShVCebeuPKq2r/Z2LxwxZ4WBY5xVJEmbzbAbqB/wmoMw5O+N9tjVoNJxEmFvmKXvfOJgfeKqhHsP0ZLrx+jvsxwSWYh/Zdr3Y4Mnh7lcZ354rQNZar3vff2VpPLuxjPzqv8ARe3/AObbskoBz+x7T4/YpRe/uIVCi5ifi/wy2PiMbGuaNs6UlQNuR2l7yLg+r8AOTwgb+/flQntLedo4NPlW5hsTbyDhJQniAohHq0VvqUn1bjaNxgo55H0qh2ivrg6VcKXyrbYIzjet1jaasSSZkoMfsmUnbikNUSmN85rrgzJpKNHKy8UhGMA0NWafBzMxP+UV0JFhLA5EUhXfYChyzXDcpC3/AAilM9wMHj+HCKdAX/LkRSsQTjhoeJ5zuWGP8tKbmUfeHyooLLbDfalXehzXEx5Pj/hFcJ5x/e/+kUxWFFBzRFGKaratnHCF3Iz1rOLcT5/eAf8ACKPWiGXXbSGVi6sEz06+lKQM39vYWup30tzqxuZseyApEYHvH6VQ1Ls9JLJ9Y0207q0xseLiJ9cVrpIboWxhsofqrr7D96Cp9461lrjtPLaXskNw0kE8fhkUDKE+YFccFKTuJlZmNQtjbKqq/wBrzOKXTIRqCOss7d4v3fMUYm1PTrmRppHi4m55XFBb0xWt6l1YSqyk5IU8q7YxbVMTpbQLeNobhlOfCcUmm2T3eq8KAnJG9F76AXM6yxDImGceR8q1vZrSItMtzc3IHesNqzz5Kil5FGOxE0xbSGMH2+tHYl/6uZPNcVSZzcTcR5URTaHFefJnVGGwdBbqm2ATVxYgBT0XrT8VLZukMC4padikNSM6krqWgYldXV1AHV1dXUgOrq6uNMBjGoJDUsi561UuD3anffoK1grIm6IHlUyFetQXEZkThVym/MU+GPcu3M8qeR511rRz232VnhyobJLryNJLEZYVZD9oviU+vlVrFRoOCUr0bcUyWRgR3lsyuoKsCrqfzFedXOmyaNqZspjxQPlraT8S/hPqK9Gde4n7wfu32b0PnUOuadbajp7x3R4AviSQc0boRUy+zf0+d45GMij9KPdn+zl5rL5hXu7cHxTMNvh50a7H9jJZ4kuNaI7seyi7d4OhPl7q9IhijgiWOFFRFGAqjAFcWTNy1EfqPXV8cYL0Hs/Y6NEBbx8Ux9qVt2P9KL11dWKVHlSk5O2dTXXNOrqYis8Bb0qvJaDqaI1gfpP7W/sSxNpZMDfTLzH3F8/fVRjyZvhjLLJQj5M59JPbJNN7zTdJcfWOUso+56D1rxG+maRvESzOdyauXc7zSs8jFnJySetUGUtJkDYD8zVSlel0fV+l9PHBDjHsibc1Ja2ct1JwxKSepoppmkSXJDyjgj/WtHFBFbRcMShR51lt9Hb0ZRrBbXU7CJjxSFi5xyGBRwrQ3i7/ALWOOkFv+bGi/DXRBUjxfWTvKzkjUqMiuMA5g1Oi+EU7FWchRdChxSDlvVi5GDVc7sAPeaAs7FWbOItIGI8Ip8FqWwz7L5VZeSKEBSQPIDn8qXYNkopaiX6xJ+6h4V/FIcflUq2krfvZT7kGKWiRGIUZYge+kB4/Yy3uqxHaRJvwgnzO9TbAYAoAqrA7fvDwr5D+tToERcKABXE0+ONnPLA86QDFUyNtyqx3eBgVYihCrgCpO7oIciiyHrVW5gDrke0KLNGKqzJimNMg0SbgdrZ9vvL/ADFGgKATKY8TJtJGeL30agmWaJHT2WGRSaFImpwpopaBEN1+7qpVu6GVFVMUy0KKR1DoysMqRgg9aWuoGZs27Wc72rklVHHET1Q/05UP0Vha9qL635CdFmX38jWo1mBXsVuQuZbZxk/+G2x/PBrJ6kfquv6XdfiZoG9xG1TJXFnV6SdZEa+gvayLvdKZh7UZDj4UXDVU1cLJp88bkDiUgZ86xirej226H6PN3+nQON/DirprGaFr1rp+jp9akAI2xkdNv5VY/wCkF/qAxpdgVQ8ppzwr8uZ+VEY/ZlPNGPZqGkVAWZgF6k0Hu+0MCO0VjHJeTj7kQyB7zyFUY9InusPq15Jcf+EngjH8zRW3t4reMJBGsaDoowK0UPo48nrfEQY0Grap/t1yLOA/3NucsR6t/SgN7pK6NqPDEubW53jdjlg/VSevmK3SLUGq6eNQsJIDs/tI34WHI1aX2cq9RJStmTjX0q3ElQ2WXjIdeGVCUkXyYcxRK3tnk3ReQJyduVdCidjy6sbGlWY0psSVZjSr4kPIcqUX7I6JJ2j1sWcWVtosNdSj7q/hHqam7L6BcdodQNvbZS3jP28/RB5Dzb0r1nsfpdrpv1uOxiEdujiNcc2xzJPU5rLJkUVS7PP9V6uouMey9qEKWempDbpwRxpwoo6ACszbOx9oEmtbqwzbH3GstBgE1yx6OHB+JrdIOdPi91WZv3TVV0g5sY/jVqb903uqfJyy/IyXaJ+K/wAdFUChDedXdUfvL6ZvXFUJc4CjmxwK646R0I03Za34LNrhh4pTt7hVrV2LrFaRnDztwk+S9TVqyjEFnDGNgqAVT0/+03s92fYH2UfuHM1zt27M7t2Z/tS6/XkhTZIkCgUBeiGsymbUZ2/iwPhQ984rrgqSNV0RmoH5mpmNQvVoZEw2p1rtdQn+MfrSHekh2uI/8w/Wn4HZu9d/2j4UFlPpRvXN5V/yigso251zR6CHRnNeHh3+FCCPF5Ua132dzQsoN8kmuhOkaM1/0dniW/HkooXrY/6xc+lFvo6AD34z9wUM10Y1BvdWUXc2Yr8ilGT3Z3x4hStxf4g+VIMd022fENqRsf4X5CtDQY2esg+VReLib7QfIVIw/wDC/SohuzfZbfCmJnEkf3g+QqKTi4GzKPkKef8AdfpUb7q32WPlVIkTfA+0GMeQpvme8HyFOyQq/ZdPSmMdsCP9KBMq6gfDJg+VAdUP9vfboKM6icd57hQXU8/XT/lFUSiJRypxFNQnNPblQMjYDFQsM1MxzvTCKYmXr8ZhshjJ4cVstD0+27N20eoapEsmosOKKF+UQ8yOrfpTdF06DTtOttb1VcFEzawt1P4yP0FZLWtUu9Tuprks3h3HpThD3P6M7PRdQ7Uvd2INzFHcWkp4HUjoaxmrWNjocr3WoP3tuWzBbA4aQfxHoP1qxo7q+kIJBleMGsJ2p1KbUdaneViVRiqp5AVosST0d3pMKm+Ujb6Jrlx2j4reRlgEZ8EY2UL0AFEbrUrHRJEtYz31854SB931b+lYGLUCtrHHbr3b48RHT3etdYjF5A2PFxjOaidXoXqckVJrGbeO4kuVWWZuKQ5zTLvBtpf8pplif7OnvNSTj7CQfwmoOOzL6cy/WB4zy86Kgp/it86Gafx/WQCBy86L4cdFI99NDRDFwlfbbn51KYwCPG+/LeuhbA3Qc+hqSRiigk7k7CmbRgmg12ISQalcmRgV7vYb+darSR/aZ8jHi2rNdkGxfScR37vpWm0tvt5s8+KsZ+TWq0jtQUcW+fcKxOrYEhGd62l4WErciOlY3VQS+WA3q8RGbpASbrnlQXUOuOlG5xtQa+B3roOcz1wuWJ6Va0weMA8sjnUUw8eOp6UZ0Ts5rd+wNhpl1IOjFOFfmcCplJLtlLsI3MNpZ27lkUuc4LDJofDdyJZiN8kZHCevurcP2E1G5SJ9UurLT1A8Sl+8b8tqv2vZHsxab3d1eag4+6vgX8sfrXM5/R0XfRiJdSLQKY2WOTO6N191OsNA1jVZTJHYXM+eTNHwr8zivT7K40rTlA0zQ4I8cnYDPz51fOv3jx5Xu4V/hH86luXgdSZiLD6N9YnTivntbOLrxNxnHuGB+dXdC7JWHZ/tJbyQ3cl3cOGBfYKoxywKI6p2ksgjC/1GPA5gy5/IUG7N65p9/wBqYrfTpHkAVmYlCBy6ZppSrYv7YbiJGqseHPDJQ+01u0LSSX0ZedpDxZHIZ2FE7FQ+sk/+Jisp2u0JodYle3lliSRuMhG2z7iKqFPTEaf/AKSWCpiLTyR/m/5Uo7UrjEelZHvJrzadLmO77hru5MfBxACUr+mK5LSMtl+N/wDPIzfqabUULkelHtNKoybOCMHzJH61Que01x3ntWkY/wA6/wBaxv1aELtDH/pFV7qOMCMhFG3QCsMuT21aRthh7jo2zdpzwYN7Zr75FqGXtQvdkDVbJf8A3orB3yjh2A+VZ64yrkVODN7sqaKz4/aVo9VTtRbKCZtbtCfRif0FQP2tsU4sazEzHlwxsf5V5YOe9Ic52NdnFHH7rPUou2tpEwLaqW9Fganntzp3e8R1G5OeeLc15Xmk+FHFB7jPYW+kHTGAA1C4UDztzTo+3ml8JH7TfJ6mFh/KvHNq6lwQe6z2uHt5pqj/ALa4c+cTf0pW7ZadKCE7QWwJ/GpX9RXilOTi4hjY1LgkNTbPaYe0FvICBr+nOD5SgVfh1d+7AhvLG4Pksyk/rXi0durxDhOPxDzqCewTvlMQCJjnjfNZWaWz3Fr69aNmNoj58hxCqmnnv9f04Pp8UT97xd4EAOACfKvIbeOdDtcSxKvWNyOL5Gtx9EstzcdpZTcTXDpDAzASSFvTOCadlWz0iYGS+QjAAJJzQTVNSS31NUlXiCbkDnRy08d+7b8IU1hvpChuY7+G4snRW4cEODgjyoh3Q70aBda0uY8M0JAP4gCKqSdn+yN+G47OBC25KjhP5V55PqF5BCZZrSNlX2ik36AijnZ3U7e8tzKLe9QDYngDD4YNW0kJzS7DE/0a9mp97eeaP/LLn9avwdjPqsKxWV8BGowFKiqKajZLt9beI+UsbL+eKnju1bP1e9gf/LKP61NB8JEz9mNRXJWeFvepH9aG3/ZjV5T4kt3hG/CHIyfXI/Ki63V6igqXPuOamh1i8UkODj1FFMXtxfgy8mh6qsqEWjkAYJR1P86oarY3q2Esf1O5UjziJzv6Vvhr0iEccSsPUVMmtxH2oVyfKjYnhieHyGeKTgkUK3TjUr+tMIlO+Yvzr3p9QsZVHfQZ9CA361XaLQpjxtZwZPnCv9KOTI9hfZV+jO9hT6N+y0N3zGlWvCw6DuUxUupXc/gJmd4lbkaBfR3v9H/Znb/8V2v/AMJaPXaI9uyjOcc/WqxxSph/pB1uA2o+HlnNO7Rf9mP6kUzShm5YnoKl7RO40p0U4UsMitZdk4+jG3hxosP+8ahIYZyPjRTUPDpNsD+I8qFoCOmM1aRZYgaQqFjwq8y1OkxPOAp2UbnzpsdwyR8PdqR60sZaWZAoCE7HhoAnkR3tiEjYb7DFNuLZuBO8PBgdRXpnZrQYTaI044iR1oV27SytYxEiLx+lYLNylSB67MDejHd4xVXIB2FTzy95jw4x61CRuMV0COTJce+tBESNdhIbhKqm/lvQOIZkT3ijqoH19UYZB7sEUmBv31KWdRE1wWxvjO9PlntZbJoLqyhdjykwM59TQiLTlhve+R2C/hzU9/8AuNj1FYqKYn0QnSrJt+4HwpjaJasrcClSRtvRKMeFfdVmJM9KHNorimZi0ie2lCMPYOQD50ahmnu5h3hPCOQq3c2QciQDcc6lsbfhbOKwy5OQ446ZctouFRtVwDw01FwKfXK2bpUJXUtdipKsSurq6gBCKSnVxGaYxldS4pKAOrq6uoGdSGlprNgUJARyMAN6oyZlk9BViQFz6VGQFGBXTBUYzdjGHSm43p3WuxWyMWxuN6bInEvh9obipcUuMbnlRYiB2jNuzyEBMeKi3ZzRHkEd1qQyqnMMLdB0ZvWodD08XNx9bnH9nU5ijI9o/iPp5Vq0bNceXJy+K6M5yrSLFdTFNPrE5mjq6urqBHV1dXEgAk8hQAP1zUU0zT5J23fki/iboK8e1zQ7fV5Xub15RePu0yNg+7HLFa3tDqB1LUmZWzbQkpGOhPVv5UHl51slSo7MKcNrs811TspqFsS1q0d7H5ew/wDQ0FULaThbyF4XB3SZeH8+Rr1qSqlxFHMhSaNJEPNXXIpOFnp4vXZId7MnFeQPGO7ZQMbDlTJphg4NELzszp0pYwLJbMf8JvD/AKTtQO87P6hbjNtcRTr5NmM/zFLhR34/XwfegboQ77WtXn5gFIwfcM0e4ao6Dpk9jDcm6CiWaUyYVs4GMc6J8NaxPPzSUptoeq+EUvDtUqrsPdUc8qxEKcl29lFGSfhTMSpde36Co7MrktwmWVtwiDJFEoNKnu247wmGE8o1PiPvNF7a2htYwkEaoo8hScr6C6BUVhdTjMziBD91d2+dX7axhth9moz1Y7k/GrRJPsj41HJnHOlV9k2xrcI2FMJApyxlvQU7uQBTArkk0qIW91OK5O1TKuBSHY1IlznFWY02pI1zVgDApEtjQKcBTsUuKCSMjaqtwlXsVXnXNA0wa65BB61Bot1wd5bMd4zke6rrrig0p+rasr8lbY/GqL7NUjZFPqlDLgb1MZwBmlRNHXB2qrSyOXYk8qaDTopaHUopoNLkAEk7DrSSsdjpFD2l3G3svC4PptWI7Sxu2kRzxo7yQukgCLknz2o/c6g12XhtTi3Phkk/H6D09aRTjltVVWhwbjLkAoL/AFy7VRbWPdof7yc8H5c6m/Ys9yePVr2SY/4cWUQfzNGg29Nkbw1Ch9m8/UTl5BS2FhYpmG1hjA6hMmiccBwCaZDbfWJ0Lj7OM8WPM9KJFPSqpeDJyZWCU4JUwSnBKZNkaLtViNKVI/SrMcfpSFZle0NmLS9jvEGIpyI5ccg33W+PKo0Q8ulbG8sI76ymtpR4ZFxnyPQ1kbISIfqk6s97G/clFGWkboQPUb1vilemawyUtk0cdajReyV3e9zNeBraycFvJ3UDoOg9a2XYfsOtmiX2txo90fFHb81i9/m35CtBqh764mC/wwL7yd/yrPJnt1E5Mnq+T4xJNEtLfRuzMaQRLDGkZfA9fPzNW+z8Ji0uIt7cmZG95qHXATawWcfOZ1j+A50VRQiKo5AYFcr6OFvX9lPVm4bYnHQ1kYHDMTsK12qjNvvywaycSAEjApw6OjB+Jq9FOdPjx61buDiBz5A1T0MY09R6mr7AMCGGQeYqX2c0vyZ59K3HI7E8yTSWUff6jEnQMBW3ms7OONmNtDgDPsCoYLKCFYiIY1lJ4iQoBFa+7o0WSxmqzGO14I/3kp7tMeZp/Atlp5VNliTn8Krxf2zVWk5xWw4V9XPP5V3aGXutKmwcFhw/OpS2kL9GFkYsxY7knNQvyqZsConFdqNrIWqM1K3Pao2zVAREYro/3iH1FOIpqbOp9aBm61rnGT+AfpQWTBo1rW6QnpwD9KA3JxsK54dBj6AuuAd3nGaEMRii+tfuDQLi8t62a0jY2v0dN9tfAf4Y/WqOu/7efdVv6ODm7vR/4X86q68D9ePxrJfmYf6gcP3bb43G9ccDP2n6Uv8Advtk7UjZP92PyrYsjbAH7z9Ki4gHb7Tp6VK3+7/SoTnvGHdjl5imJjSR1l/SmORwn7X9KeSf8MfMVGxJBxGPmKpCGggqv2vTzFMYrn97+YpykhBiMcvMUhLf4Y+dMkHagcs+/TnQXUT/AGo438IovqBOXHLag14kjXOUR2HCOSk00SmNjalYjipBHL/hSf6TSiKX/Cf/AEmgLGucjlitx9HfZeK+Datq8Z+oQn7JGGBMw/VRQnsp2fbVrozXgaLTbc5mcjHF/CPU16G2qQ6jAltYhRbRDgCx7AY5Cs53LSCKUnQB7aR3Wt3cbW6F4VHDwL0HurDatcLbh7C2xttKw8/KtZ2z106NaGzsDxXkwwzjfux/WvNo+MnLBjnckitYyaVeB5KvRtLLC6SVG3KsS0PFrb5H3id63umQ95YMMHYZ/KsnJEq6tIeu+K6I7PS9B+DKSR4c8W5zuasQbXUOPxCoA5yfCeflTomIuodiBxjpXOzy5vbNlphJtl/zn9asS7xt7qr6UcwH0kb9asy54GwN8UiUZWx4frW5Yc+potlOjMfiaGWJf65jAyCedX7qbuQGfgAzvlqaLj3sZKvHGwilKODzzTN1UB2Zn6E01ZUMjMuykZPrVe4ulSLgU+NuWelB0pKKNd2NcnVmB3zEa1dkcXMwHRv5Vjuw3GdVAdlY92dxWyh8N1MTy5msp9lo66OWOeXnWbuLSe8cfVreWYn8Ck/nWkhv7BZOKK2a4lH335CpbjtF3QHeyxwJ+FcUlyXSIyLkZ2LsbfzLx3T29oh6yPk/IVYh7HaDDvf3NxfS/hj8CH/599Q6h2qtDkqss7e7A/OgU/bORZh/Z1jjHUHiI+G1XwyS7MvgvJubSLTdOH/VmjWkDdHZAzfM71HqGtTopa6vo4E8i4SvHNW7UaveM6vfyrGfuxeAY+FBopWZ8sxYnqxyapYPLD3Euker3faHSg2frD3DeaKWHz2FRaXrUuq6pHZabahS/J5Gx+Qrz+NzleEZBAojpd/caZdx3dqeGZNxmocfo1U21o0faq71XStSezknjUgZDRL/AFrLXV1dXCHvbiV/8zk1Nq2o3OrXj3V44Mr88cqoM3DsTzoSdbC/shHBaW/jOQT5Vrfo3RP+kaOigHuXPLB5VmeEeHKg45elab6NpeLtT3bKR9i+Ceu1OXQujfaaQdZj2A8eai7XR8UocA+Wadp5I1iPOThzU/aHhaJm58JrNdgujzfUVP7UX/d/zp6KAKfqR4tTzj+7FIoNVIk41Tux9kvoTV/hPlVS7UiJgRuGrm9QridHp3UyhdAGIe6s5eriStLKMwVntRXDg1z+kdZEb+sV4ypXUtJivYPIOGMV1dilxQAhFcN6U1Lbwl2XJ4VzzNS2lsaVjVidnChTxHlRFbc/ZE7OvtZ61ZtwoKjIZhyPlUly4RC4AJHWueU3I3UUirOzxMHCgoN/Wqst4yFiyBlY8vKmm7YsQrbHp5VXeVEYK/PzpJMGwhBc8cRLLwtzWvQfojGbrU5yi+GFUyPU15hBcAFwWyeYJ/SvWfomU/sDVLjGOOVUHwFNqiouzbWI4e9fHQCsp21jMgjIOOda6xBFrITyzWd7WRA24fPI0Q7L8GBazF3w2sxYI7AEDyrT2tvHbwpFEioiDAAFCbbD3kRIxgk86LPKsaM7thV3Jqp9nLlfyHylERmkIVQMkmgjW0eoyCWaJRbLui8Iy/qfSp5FfUZFaTKWy7qh5ufM/wBKmO554UdPOklRkVRbxKfs1MSg7FGIP5U8NdISY726jXpmTiz88047ElvZ6LXHixxMdugIpjtjP2hqUZB+sI4JxiSEE494xVj9tXdvGXuYLVuEZHDxKf51WcMArNu3ENqY+8cgcCRhkAfCiylkkvIkPbqzY4uLCdR5oQ39KuJ2v0UrnFyvoYj/AFrCNKynDRY+IqGQu7Z7l/mKuilnmen/AEfME+jzs27chpdsT/5S0ZtQ86CafbO6oOQFZvsU3e9hOylop3k0y2L+iiJa1yrwqAowAMU1qKLWwbpxxezKOW9QdqZglmkWRl2/Sp9NX+2Tk86AdpbkTakIwcrGCB761SuRMXSBtw4NnY45EmqckmSyDLMT1HKrtzZzyWVskSE8AOcnHOqS6fehh9kfgwoTRdll4+KAxnHhGRg1Jav3RhOdwM4xzqsbK+VgRbyknqMf1p4tL3b7CcEctuX50Wgs3+idpoorE96eEjbeslrmoNf6o7OAVxtWp7G9mob+wdr0MHJ5Ghfavspc6c5lte8ki/hGSK5oThGbQrtmUEaPCoOASTg1zRhZXPCCVUYFRGO4GB3M+FO32ZruG4D8Zjm4vPgNdVodkoQsYm4U5jdaL2m/aTHkyfzoNHJO9wnGkuAw/uz/AEotZSpH2gaZs92HXpjpQws20rIgy7hR6nFVL2ZJI4xHIrZO+DU08Nvf26l905huVUZ7GO2ZGt28J6E5xWceyJvQchXwqPSrsUdQWmHRSOeBmrqLxEKPjXNkkbR6JVQcNLBHw1Mq7U5VxXLJmqOApaXFIRUjs6kxS11IYlJinUmKAG11LXYoGJTSKdXUAMpa4jekO1MYjGojufSlZt8VDNKF8I3atIxJlI6R1XYkCqrSlyRCOI+Z5CnrECeJxlvI04ADYbV0xSRzybZGkZBJY8TGpAtLTgNqqyBAKjugRaykc+E1OBXJG1y7W8SlpCOQHKolJLsV0GtLcPY2zDkY1P5UQQ0F7PcS6VDFJ+8hzE3vBouhriaMX2WkNSiq6mplO1IhodXV1dSIOoF2t1A2tj9XhOJ5/CCPujqaOsQoJOwFec6vfG/1Gaf+7B7uP3Dr8TVwW7NMcbZQICqFXkNhVSeVUPiIFPuJuHZd2ofIvEeJ9zWyR2pWStKj8mGaruajkUHbFRZZOpK/pTK4j2NRyAFSKXjBGRUbtgUDQPuEw1QEBQScAeZqxO2WHMknAAGST5Cr1to6Lwy6lu3NbcHYereZ9KG60U3QMgiuLwAWw4IuszDn/lHX30WsrC3s1JVeKQ+07bk/GrbkscIvuA5U5LZmIMrbfhFS/wBk8hiI8x8HLzNSmBUHmfM1ZACjAAAHSoLh+EbczR2KyvKVXbrUQGTvTuE5yedOAoGNAwKjkOTwjnT5GwKdbR58R5mmAkUG2TTnjA5VcVBioJR4gKQrEiXapcUiDanikIbilxS8q6mAlMdc1LSEUAUZk57UB1qPxofMYrTSrtQPWF8CHyaqiXFklpL3tvHJ1Kip85obpLERSRnfgc49x3q88ixLxOwAooqyUHauZlUZZgB6moSs7R9432EP4mHiPuHT40MuJgxbgzwjmzbmmkFly41KONSUGQObMcKKGyTT6l7TFLX0GOP3elRxW7XDCS5/dg5SP+ZovbQFsEjbpQ39BRWSMRoFVcKNgBSgZon3S9aUQx/hpDsGAZOBzp7xlcLzc9KIGNEUtgDFR2icTNKw58qAsdBCIowo+NP4alxmnBaKJshCU5UqXhqVUoAbHE2M4OPOrMUfpUkSsY+DPhG+KswKQCByPOkxCQxZ6US7OWltY9qI9RaCMySx9w8hXJXyIPTyptvFkgDnWm0rTQV4pBzrOUqIyNcWmaO4lEEDyt7KAk0EscXFxaHnxFrhvToKm1W4ZdKuIiPtuHhHqPOh+gzmDSpbuXmq90g86lLVnHGPxsJxf2vXXbnHbJwj/Mf+VFqo6PbG2s17z97IeNz6mr1JkS7KmpDMB9xrJA4JwMmtdqH7k+41keUhqonTg6NNoJJsd/xGiVC+z5zZN6OaKHapfZz5PyZBOO8lSPpnib3Cq2rXH1eFnG7gcKjzJ5VagHEXkPNuXuoY4+uawR/dW2CfVunyoQR7LOn2/wBWtEjO783Pmx50H7XSYghiHMtmtAxAGScCst2i4bm7U99EiIuNzk59wrTH+VlxTbszrCoWqa54Yz4XDjzUGoOINyIrsRpVEZ58qj55orCqR2wdkVmbJ8QztURu0xtDH/pFJN+CqBxxypo5j30QN2n+An+kU366gx9gn+kf0p7+go1WsD7C3P8A4a/pQKYZznlR7WDxW1s3LMan8qBTgHOdxWEAx9APWf8AZ2rOswxsa0eqkiEtgYHQ9aHftheED6nBy/Av9K3fRqw/9Gj8V/eD/wAH+dR6+cXh+NP7GzvqV7PHEwsysfEWhUZPodq7VpZYJ+Fn73c7so/pWS/Mxf5AobpIc4GBvSkr/ifmKfLO0sbghdh0AFREt0UfOtShjFcby/mKgJUSH7Q8vMVOxY/cHzqIlu89kcvOqEMYqP70/OmErgjvT86kbiP3R86Y3Fv4R86YmRBl4R9ofnU9vbiWMuXcqDjY1CvF3Y8K/OrIuY7eyLXDrGvHgEmmyWRS6dbyZ4+8329r/lTF023QeEzD3PXftWxPK5jpDqtj/wB5j+dIkU2EI+/P/wCZVrTND/aN4lvA9wCd2bj2RepO1QWlzBfXMdtayLLPI3CiLuSa29wYez2n/Urdg97MMzSfyHpUyfhdglydIx/arV4wiaJowYxReFiDuT1yfOodNR9Mh4IJWjlcZbHT/nT7+ytNEPfyTxrNcHIDncf8qqftOyA/2uIk8yW51tySjxiJx4s6axikm715J+9/Fx7n8qRrFAD9tcf+ZXftOy63cP8AqpH1OxIP9rh/1ipAt6PIv1d0QEkg7/CsbL/2s4I6888q3Oh6fP8AU3uCVWPhLDJ3IxWGnI/bDjiwc10Y2m3R6vodRdmjgs17lD304yByenfUUP8AfXH+umW+o2QgjDXcAYDBBkFP/aVln/a7f/zBWD7PLlVsmtLeO3j7uIHGc7mpCNudVhqVjkEXlv8A+YKU39meV3b/APmCkSZ6DhGotkN7R5Zq7PbW0zBpUZse+qsRLaizIyFCxIPStHp+jahqO8EQWPrJICqj+tO0uyopvoARwxPxY2VTtjrQ+WznuLlI7WGSd22VI14j+VehW2haRZoEvruW+nHOK2GF9xb/AJ1ekuxY23DbLaaTanou7n48yank/B01aoE9itBu9Kulmv1SF3QgRcXEw9+OVaq2Xiu58elANGu4bnW17h5pPA3E8u3F7hWkslIup+mcVEylowevxNZ6nKkTyJE54uEMQM+6l1dV4YyoAPCOXuon2wh8YlxyOKEarxAwjzRf0reDtIyzdgWTwk5oRfHnR2/t3gfhlGGxn4UCv8AHFa9mDAk3tV0OxpJ85psGeIb0AFLWQoq7ZFWXk4XAIwp61XthGUBJ8XlyqVxxp6A7Gudm66OmDMwCk8uWcVcd9POmxhIpI7wHx8RyCKpOzSISgww5E8qSE99FxMopUMfEVKAry6Vpvo4kJ7TZKhYxE/iJ5nFZG2m4fs5MAg4GOoo1opZb5uE7d0/6U+N6KguTSPS7S7gh1RGknjC8RJ8Qp9/qthPFKouYzz5nFeS6d4dejIJzv+lGwxPeKfOtFgid8fSxQrzxXepytC6siqFypzRC2tJJSOEeHzNCOyUCpqd7Gy5A3ANbSMAYA2Fc2Z8ZUjhlFKTRWhsEjXLniNCNbjAL8IGMCtIwyKB60m2f4a5Z7ia4tSRmxvCQaA6mv61oEGVaguqL4W9K58LrIjrzq8bBQ8qdjJpBS17Z4ghFd7qXpV63sklAYyZXHIc6mUlHsaTZXs047hAUDjqCcVdn2lEYVQvTHSlmiWxi7yLBPVj7QqqsmAG9kk53P51jN8jRKgmLcKqcLAMDktVG5d8PGc8G+ajbUGR+HCupPWrEStnEjRlH5gCs6oq7AjxNjiwQucUxkYjc5NHb2OEBY5Tw7+Hpt76CucMQuDv0rRWQ1QyMDrsa91+jiIw9grcgYM0rNv13xXhZU4yRgede99mryzh7KaVbrPGGSMMwJxjrTkm1o0xxbujTxkrbDP3iTQTtBEZbQrtV+K9t2iiVZ4mOOXGKq6wSbUlRn3VmotM3cWu0YiBFt7p2cjCp+tWMd+A0g8PNVPX31AIw91O8nIMAB61ZA6t8BVPs4cj+TFlOwJ8K45edRPuQx552FSSDGC5z5CmYIbB3c/lSIInGH4ju+eXlSt4QDzc7AVz7OQDmTqT0rsb4U5PU+VMCCT2fCctkZJ99OfIJEWGYgg56VHcDwsF5DBLVJEvEzgbIep86AMVLHP3jeNNiduGkxOPvJ8qkvou7uZQsr5Dn71RCBmAJuJB8a1JN79FWJuyGizE7ppttGB5ARLWzbZSax30Tf/gPo/8A/I23/wAJa2Mv7tvdR9HTH8QTbSiGG6nP3RmsVcyNNdcbZyQzVqbv/se794rKSfvh/kNdMVpsxT2kaK3B+rRf5RUd5MttbtKRnGwHmalh/wBni/yj9Kodov8Asv8A41/Wuddm5W/bF3jwiEe9Sf5039r3mfEYSPRMfzocv7oVJH7a+8Vo0kBseyPauW0uRHdcPdt1AxXpUs0Wo6exiZWDLtXhD/v2/wAxr03sP/sg91c2fEvyQjF61e3ljqEkPBEADtkH+tQ2OrzzXUcU6R4c4ymdvnV7t9/2s1ANP/2+2/3greG4WM1XI8zQ+zRZ9fCMNi+D67URbnVDSf8A8Ix/vD+lEfII1FtDxEBldFjOFGdiKW7tFBMq5yTgjpV0chSXH7g++sr2JrRY00cNtk0Tt0wMkbmh1l/sqe+i0XsiuTK9msB4G1KBS9KU8qwNBtdSnlSUDOpCKWupANrqU9aSmMSkp1IaQxDSUppOlMaGk1FK+BT2qCetIomTogaQ8Xh3NcicO7btTIv3tSmt0jFsQ7muFJ1p3WrM2dyGcVDcXSwKDwk561OtRXX7iSpk6Vkst6NbXGpoHKGGHPtkc/dWqtLSK0i4IUx5nqffTdO/2GD/ACCrVcMpOW2c8pNmehT6tqd7B0ZhMo9DsfzFXkNVr7/t1f8AcH9RVhedUUWENWIuWaqJVyP2BUsmXQ6urq6kQAu19+1pp3dQsBPcHgHoOp+VYOZxEgVPcBWl7cf9p2X+7f8AlWVn/fj3VvFUjrwxVEXBgZbdjTOBpGCopZjsABkmp3q72Z/7etf81N6Ru3SsBzxtG5V1KsNiCMEVAVo92s/7duveP0oIeVWVF2rKzw9VOKrOkrOsaRs8rnCIObGiB51a7Pf/AIQL/uD+tTJ8VaCUqQttpQ0+PjlZXvWG5HKMeS/1pVgUElyWNXr39+/vqsKmqITOVQOQxS7Vw5UtMBGOAT5UPdu8ct0q9L+6b3VQTlT8DQ7FNc4FSVFJzNCGiIKZHAG9Eoo+FRVWz9uiC8qTYNjSMCqjnMlXJPZNUj+8oQkTqNqXFcvKlHSgBMUuK4866gDjXEVw50poAjkG1BNXX7AnyNHJPZoNq/8As7VSKiCtJSeW9mS3j4gQMsfZU+taGO0t7BO/uW72YfeYcvcOlJ2Y/wCyk/zGou0PtR0o/LbBu3QNvriW9l3JWPoBVRgO87pR4V3J9atxcqqRfvp/8/8AKr7LRZto+8f+EUSQADaqll+7Pvq4vKp7BkkKd5KicQXiOMnkKfPF3Mzx8SvwnHEvI1COdOXmKdCK9xmWRYlOx3b3VbRQoAXkKrQ/7ZJ/lq5H7YpMBVQnpT1Sra8jULc6Sdk2NCipUSmp0qePlTGSxJVyCPeoIqvW3NalgHNFsOMh3G1aeGIKAMYFUNJ/2daKp7NYN2cWaTbK17b96geMDvY91z19KoWGn8aQNKy90hLiJRjxevuozVWy9q4/3h/QUWYpui1XV1dQIq6htASfWseGVpG4TyNa7VP9nrDx/vW99XA68HRr+z3+yP8A56IzE8PCObbUM7N/7I/+aij/AL1PjUPs58n5sivJ1tLR5DyUbDzPSqmmQtFagyfvZDxufU12u/7PD/vV/WrQ9kU/ALozPbNL5IRPbzEW4wGRdiPXPlWRA1BxmON367DNej63/wBk3X+Q1l9C5L/lroxzaidGN6MvJdyoeGZMN16H5GoBP3j44sH5UT7Q+2/+Y0Bf2VrqjtWbB+3lcxqHYsAMAHbb31IIoMeJWX/jNVrH90vuqy/7s1EkMTubfPI/+ZTO7t8Akb/7w0+D9wtWLT9y/wAazk6Jm1FdGg1cZsbXBOO7X9KCSABMb0T7R/8AY9r/ALsfpWFm9o1WKFqyILRd1aMmEnj2qittZlFJjGcf4hqGT2TRTR/9gf3mtZqkVJ0iLS7waVPJJZKkbsOEkknI+NddX5uH4pe7LVXT71I3OpSXYfsVZUcSABR4ehpSyfjPzpIucn+U1L0FNEsgLJ/iH51ExTj/AHh5edWT1qI+38KpEkJKf4jfOmsUI/eN86nbkaTqPdTEVF4O7Hjb5mqGsQNcwqscnhQ8XDgnNFE6fGlbnTEzFPbhSB3nXHsmkNuP8Qf6TRW//wBpP+aoTRQqD/Z2e27L6FNq8hV7+fMduCPZHWrema5BLbvqmotJ3h3C8J8TenpWV7U/9m6P/lb9aIXv/ZFh7jWnBKNkY5NPQK1i5m1W9e5uZcsdlXhOFHQChzW4AJ7z/wBJooOdRy+wazobB4tAf70f6TTTY7/vf/SaI/drhzNNIVHr2gqr6VaoyBlMSg+u1C7uztVv2TuI8YPJB5UX7O/9n2v+7X9Ko3//AGk/uP6Vkuzri9HjN3pim6m4ZMLxtgBPWoBpeRnvf/QaOT/v5f8AMf1qFfZWtqORrYJGmH/F/wDQaMdn+zNxqdyI7WMycJ8cjjhjQeZNIteo9nP/AMAX9x/WolovHBN7KOmaLpWjlTHGdTvh/eNtEh9Kn1XU9gL6526QQ7D5f1p8H+xp/lrHzfvpv81EY+Td/FpIu3GuzcJjs4Vt1HIkAsf5ChU8zP8AazSMx6s5yfnT25VSvP8AYmqyjSdkWH7ZTByCjYrb2GfrU5PpXnvYX/tOH/I36V6JYf7XP7qzmrdFxVtAjtEizW8u+SpzWe12PDx4P3B+labU/Yn9xrO9of3if5B+lawjVIz9THjQAvpHmwZGyQMCgN6uxo1cUFv/AGa2ORgS5ANMh9vNPn9o1FB7dAjQ6dDGLdpeDvOEbDnvVR5GfpgUV0j/ALPX40Jb2z7652bvpEneYiCjn51D3jRRHiYnGScUp5mmSfum91IVj7Z4SS3CAT949aM6FIr3rhTyibl7qy8H7n/iFGuy/wD2zP8A7lv0q0tmmGT5pEtsCNZiyeZNHY1BklB552oDF/2xB7zWgt/30vvroPaQ3QB3evXY55QGtUm9ZbRv/wAILn/ditRF7Qrz/UfmeTP82T9KFayuYlPXBFFRQ3Vv3S++uZ9FQe0ZNNnYbUK1NMq2PKi39+1DtR9lvdXLHUjvnuBn13pc0xeZqW3/AHo99e54s8LyTW68EmXQHHQ0StXVSF7vhUjII61Rf2mq/H+4h/y1zyd7NVodcR97A6EAnzNC3i4A0RPFjbNFpPZX3VVuf3ze6pQ2CEj4JkUlR13q4Gw3PGOuaq3H7+P3im3X76X3VfGyLokvBK6ZeTIz7PPHxql7Dc9qmH7k1XNVETZqezWhm/hNxdKwgG4yccfw8q0+qIFtoEVQoVQMeW1XrL/smH/dD9Kqa1yjqsW2d/8AH7tkEpKyRDi2Ap82oXUEJaGdxjoDkfKo7j7vuqvL+5PurY9PsJ6PLLNYiecgvI5PLAq6p4TsOJj+VVNJ/wCzoPcf1q3Fzf3CuSXZ85kfzZyjHXL0kmdwp35k1IvtP7hUI6/5jSMxjY4tuXU9c0vMFVGF86jn/crUsnsD/KKAKlyv2TgbIPzqdcMuPZUDORUN7+5P+Wp/uj/IKYGL1FbYXs+VB8Z3xVTNoD0/OiWsf7Xcf56HjkK0RJ//2Q==\"\n\n//# sourceURL=webpack:///./src/ass/4efbc0992ccdbfb4.jpg?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue_dist_vue_esm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue/dist/vue.esm */ \"./node_modules/vue/dist/vue.esm.js\");\n/* harmony import */ var _app_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./app.vue */ \"./src/app.vue\");\n/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./style.css */ \"./src/style.css\");\n/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_style_css__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _style_less__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./style.less */ \"./src/style.less\");\n/* harmony import */ var _style_less__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_less__WEBPACK_IMPORTED_MODULE_3__);\n\r\n\r\n//要使用vue必须导入vue\r\n\r\n\r\n\r\n\r\n//直接导入css\r\n\r\n\r\n\r\nnew vue_dist_vue_esm__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\r\n  el:'#app',\r\n  template:`<app />`,\r\n  components:{\r\n      app: _app_vue__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n  }\r\n})\r\n\r\nvar a = 100;\r\nconsole.log(a)\r\n\r\n\r\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/style.css":
/*!***********************!*\
  !*** ./src/style.css ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../node_modules/css-loader!./style.css */ \"./node_modules/css-loader/index.js!./src/style.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack:///./src/style.css?");

/***/ }),

/***/ "./src/style.less":
/*!************************!*\
  !*** ./src/style.less ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../node_modules/css-loader!../node_modules/less-loader/dist/cjs.js!./style.less */ \"./node_modules/css-loader/index.js!./node_modules/less-loader/dist/cjs.js!./src/style.less\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack:///./src/style.less?");

/***/ }),

/***/ "C:\\Users\\VULCNAVSeries\\AppData\\Roaming\\npm\\node_modules\\webpack\\buildin\\global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "C:\\Users\\VULCNAVSeries\\AppData\\Roaming\\npm\\node_modules\\webpack\\node_modules\\process\\browser.js":
/*!*************************************************!*\
  !*** (webpack)/node_modules/process/browser.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///(webpack)/node_modules/process/browser.js?");

/***/ }),

/***/ "C:\\Users\\VULCNAVSeries\\AppData\\Roaming\\npm\\node_modules\\webpack\\node_modules\\setimmediate\\setImmediate.js":
/*!***********************************************************!*\
  !*** (webpack)/node_modules/setimmediate/setImmediate.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buildin/global.js */ \"C:\\\\Users\\\\VULCNAVSeries\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\webpack\\\\buildin\\\\global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"C:\\\\Users\\\\VULCNAVSeries\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\webpack\\\\node_modules\\\\process\\\\browser.js\")))\n\n//# sourceURL=webpack:///(webpack)/node_modules/setimmediate/setImmediate.js?");

/***/ }),

/***/ "C:\\Users\\VULCNAVSeries\\AppData\\Roaming\\npm\\node_modules\\webpack\\node_modules\\timers-browserify\\main.js":
/*!********************************************************!*\
  !*** (webpack)/node_modules/timers-browserify/main.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ \"C:\\\\Users\\\\VULCNAVSeries\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\webpack\\\\node_modules\\\\setimmediate\\\\setImmediate.js\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buildin/global.js */ \"C:\\\\Users\\\\VULCNAVSeries\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\webpack\\\\buildin\\\\global.js\")))\n\n//# sourceURL=webpack:///(webpack)/node_modules/timers-browserify/main.js?");

/***/ })

/******/ });